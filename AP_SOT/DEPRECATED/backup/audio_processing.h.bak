#ifndef AUDIO_PROCESSING_H
#define AUDIO_PROCESSING_H

#include <Arduino.h>
#include "config.h"
#include "audio_frame.h"
#include "goertzel_engine.h"
#include "adaptive_agc_system.h"
#include "multiband_agc_system.h"
#include "audio_metrics_tracker.h"
#include "dc_offset_calibrator.h"  // RESTORED: Battle-tested DC offset system
#include "enhanced_beat_detector.h"  // PROPER beat detection - not "trust me bro" 120 BPM!

class AudioProcessor {
public:
    AudioProcessor();
    void init();
    bool processAudio(AudioFrame& frame);
    
    // Metrics access
    const AudioMetricsTracker& getMetrics() const { return metrics; }
    void printMetrics() { metrics.printSummary(); }
    void printCompactMetrics() { metrics.printCompact(); }
    void printBandGains();  // Print multiband AGC gains
    
    // DC offset mode control (0=SensoryBridge, 1=Emotiscope, 2=Raw)
    void setDCOffsetMode(int mode);
    int getDCOffsetMode() const { return dc_offset_mode; }
    
    // AGC mode control (0=Single-band, 1=Multi-band)
    void setAGCMode(int mode) { use_multiband_agc = (mode == 1); }
    bool isMultibandAGC() const { return use_multiband_agc; }
    
    // A-weighting control for multiband AGC
    void setAWeighting(bool enable) { multiband_agc.setAWeighting(enable); }
    
    // Get reference to multiband AGC for visualization
    MultibandAGCSystem& getMultibandAGC() { return multiband_agc; }

    // --- DIAGNOSTIC HOOKS ---
    void printDCSample();
    void printAGCState();
    
    // Noise calibration control
    void triggerNoiseCalibration();

private:
    // DC offset mode
    int dc_offset_mode = 2;  // Default to RAW (best test results)
    
    // RESTORED: Battle-tested DC offset calibration system
    DCOffsetCalibrator dc_calibrator;
    
    // REAL beat detection - no more hardcoded 120 BPM nonsense!
    EnhancedBeatDetector beat_detector;
    
    // High-pass filter for DC drift removal
    struct HighPassFilter {
        float alpha = 0.999f;  // 1-2 Hz cutoff at 44.1kHz
        float prev_input = 0;
        float prev_output = 0;
    } hp_filter;
    
    // Adaptive noise floor tracking
    float noise_floor = 0.0f;
    float noise_floor_smooth = 0.0f;
    static constexpr float NOISE_FLOOR_ALPHA = 0.001f;  // Very slow adaptation
    static constexpr float NOISE_FLOOR_MULTIPLIER = 1.5f;  // 150% margin above noise
    
    // I2S and Sample Buffers
    int16_t* sample_buffer;
    uint32_t* i2s_buffer;  // SPH0645 outputs 32-bit data!

    // Goertzel Engine
    GoertzelEngine goertzel;
    
    // Frequency bin storage (points to Goertzel output)
    float* frequency_bins;

    // AGC Systems
    AdaptiveAGCSystem agc;           // Single-band AGC
    MultibandAGCSystem multiband_agc; // Multi-band AGC
    bool use_multiband_agc = true;   // Default to multiband (better performance!)
    
    // Metrics tracking
    AudioMetricsTracker metrics;

    // Internal state
    float last_total_energy;
    uint32_t frameCounter = 0;  // For periodic logging

    void initializeI2S();
    bool readSamples();
    void analyzeSamples(AudioFrame& frame);
};

#endif // AUDIO_PROCESSING_H 