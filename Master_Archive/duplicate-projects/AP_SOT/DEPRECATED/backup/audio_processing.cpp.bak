#include "audio/audio_processing.h"
#include "audio/dc_blocking_filter.h"
#include <driver/i2s.h>
#include <esp_log.h>
#include <string.h>

static const char* TAG = "AudioProcessor";

AudioProcessor::AudioProcessor() 
    : sample_buffer(nullptr),
      i2s_buffer(nullptr),
      frequency_bins(nullptr),
      last_total_energy(0.0f),
      frameCounter(0) {
}

void AudioProcessor::init() {
    ESP_LOGI(TAG, "Initializing Audio Processor...");
    
    // Allocate buffers
    sample_buffer = (int16_t*)malloc(CHUNK_SIZE * sizeof(int16_t));
    i2s_buffer = (uint32_t*)malloc(CHUNK_SIZE * sizeof(uint32_t));
    
    if (!sample_buffer || !i2s_buffer) {
        ESP_LOGE(TAG, "Failed to allocate audio buffers!");
        return;
    }
    
    // Initialize I2S
    initializeI2S();
    
    // Initialize Goertzel engine
    goertzel.init();
    frequency_bins = goertzel.getMagnitudes();
    
    // Initialize DC offset calibrator
    dc_calibrator.begin();
    
    // Initialize AGC systems
    agc.init();
    multiband_agc.init();
    
    // Initialize beat detector
    // beat_detector.init();  // No init method
    
    // Initialize metrics tracker
    // metrics.init();  // No init method
    
    ESP_LOGI(TAG, "Audio Processor initialized successfully");
}

void AudioProcessor::initializeI2S() {
    ESP_LOGI(TAG, "Initializing I2S on pins: BCLK=%d, DIN=%d, LRCLK=%d", 
             I2S_BCLK_PIN, I2S_DIN_PIN, I2S_LRCLK_PIN);
    
    // Configure I2S driver
    i2s_config_t i2s_config = {
        .mode = (i2s_mode_t)(I2S_MODE_MASTER | I2S_MODE_RX),
        .sample_rate = SAMPLE_RATE,
        .bits_per_sample = I2S_BITS_PER_SAMPLE_32BIT,  // SPH0645 outputs 32-bit data
        .channel_format = I2S_CHANNEL_FMT_ONLY_LEFT,   // Mono microphone
        .communication_format = I2S_COMM_FORMAT_STAND_I2S,
        .intr_alloc_flags = ESP_INTR_FLAG_LEVEL1,
        .dma_buf_count = 4,
        .dma_buf_len = CHUNK_SIZE,
        .use_apll = false,
        .tx_desc_auto_clear = false,
        .fixed_mclk = 0
    };
    
    // Configure I2S pins
    i2s_pin_config_t pin_config = {
        .bck_io_num = I2S_BCLK_PIN,
        .ws_io_num = I2S_LRCLK_PIN,
        .data_out_num = I2S_PIN_NO_CHANGE,
        .data_in_num = I2S_DIN_PIN
    };
    
    // Install I2S driver
    esp_err_t err = i2s_driver_install(I2S_NUM_0, &i2s_config, 0, NULL);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to install I2S driver: %s", esp_err_to_name(err));
        return;
    }
    
    // Set I2S pins
    err = i2s_set_pin(I2S_NUM_0, &pin_config);
    if (err != ESP_OK) {
        ESP_LOGE(TAG, "Failed to set I2S pins: %s", esp_err_to_name(err));
        return;
    }
    
    // Clear I2S buffer
    i2s_zero_dma_buffer(I2S_NUM_0);
    
    ESP_LOGI(TAG, "I2S initialized successfully");
}

bool AudioProcessor::readSamples() {
    size_t bytes_read = 0;
    
    // Read from I2S
    esp_err_t result = i2s_read(I2S_NUM_0, i2s_buffer, CHUNK_SIZE * sizeof(uint32_t), 
                                &bytes_read, portMAX_DELAY);
    
    if (result != ESP_OK || bytes_read == 0) {
        static int error_count = 0;
        if (++error_count % 100 == 0) {
            ESP_LOGE(TAG, "I2S read failed: %s, bytes_read=%d", 
                     esp_err_to_name(result), bytes_read);
        }
        return false;
    }
    
    // Convert 32-bit I2S data to 16-bit samples
    // SPH0645 outputs: [18-bit data][14 zeros] in 32-bit word
    static int debug_counter = 0;
    int non_zero_count = 0;
    
    for (int i = 0; i < CHUNK_SIZE; i++) {
        // Extract 18-bit value and shift to 16-bit
        int32_t raw = (int32_t)(i2s_buffer[i] >> 14);
        
        // Sign extend from 18-bit to 32-bit
        if (raw & 0x20000) {  // Check 18th bit
            raw |= 0xFFFC0000;  // Sign extend
        }
        
        // Convert to 16-bit
        sample_buffer[i] = (int16_t)(raw >> 2);
        
        if (sample_buffer[i] != 0) non_zero_count++;
    }
    
    // Debug output every 100 frames
    if (++debug_counter % 100 == 0) {
        ESP_LOGI(TAG, "I2S samples: %d non-zero out of %d, first=%d, last=%d", 
                 non_zero_count, CHUNK_SIZE, sample_buffer[0], sample_buffer[CHUNK_SIZE-1]);
    }
    
    return true;
}

bool AudioProcessor::processAudio(AudioFrame& frame) {
    // Read samples from I2S
    if (!readSamples()) {
        return false;
    }
    
    // Analyze the samples
    analyzeSamples(frame);
    
    return true;
}

void AudioProcessor::analyzeSamples(AudioFrame& frame) {
    // Apply DC offset removal based on mode
    // For now, just use continuous calibration
    for (int i = 0; i < CHUNK_SIZE; i++) {
        dc_calibrator.updateContinuousCalibration(sample_buffer[i]);
        sample_buffer[i] -= (int16_t)dc_calibrator.getCurrentOffset();
    }
    
    // Run Goertzel analysis
    goertzel.process(sample_buffer, CHUNK_SIZE);
    
    // Update metrics with raw audio data
    metrics.updateRawMetrics(sample_buffer, CHUNK_SIZE);
    
    // Update frequency metrics from Goertzel
    metrics.updateFrequencyMetrics(frequency_bins, FREQUENCY_BINS, 
                                   goertzel.getBinFrequency(0)); // Placeholder for dominant frequency
    
    // Update AGC with amplitude tracking
    agc.updateAmplitude(sample_buffer, CHUNK_SIZE);
    
    // Apply AGC
    if (use_multiband_agc) {
        // MultibandAGCSystem requires output buffer
        multiband_agc.process(frequency_bins, frequency_bins, FREQUENCY_BINS);
    } else {
        // AdaptiveAGCSystem processes magnitudes
        agc.processMagnitudes(frequency_bins, FREQUENCY_BINS);
    }
    
    // Update beat detector
    // beat_detector.process(frequency_bins, FREQUENCY_BINS);  // No such method
    
    // Update AGC metrics
    const char* agc_state_names[] = {"SILENT", "NORMAL", "LOUD"};
    int state_index = (int)agc.getState() + 1;  // State enum is -1, 0, 1
    metrics.updateAGCMetrics(agc.getCurrentGain(), agc.getTargetGain(), 
                            agc.getNoiseFloor(), agc_state_names[state_index]);
    
    // Calculate energy levels
    float total_energy = 0.0f;
    float bass_energy = 0.0f;
    float mid_energy = 0.0f;
    float high_energy = 0.0f;
    
    // Sum energy in each frequency band
    for (int i = 0; i < FREQUENCY_BINS; i++) {
        float bin_energy = frequency_bins[i];
        total_energy += bin_energy;
        
        if (i >= BASS_BINS_START && i <= BASS_BINS_END) {
            bass_energy += bin_energy;
        } else if (i >= MID_BINS_START && i <= MID_BINS_END) {
            mid_energy += bin_energy;
        } else {
            high_energy += bin_energy;
        }
    }
    
    // Update noise floor tracking
    if (total_energy < noise_floor_smooth * NOISE_FLOOR_MULTIPLIER) {
        // Update noise floor estimate
        noise_floor_smooth += NOISE_FLOOR_ALPHA * (total_energy - noise_floor_smooth);
    }
    
    // Determine if this is silence
    bool is_silence = (total_energy < noise_floor_smooth * NOISE_FLOOR_MULTIPLIER);
    
    // Detect transients
    float energy_delta = total_energy - last_total_energy;
    bool transient = (energy_delta > 0.3f && total_energy > 0.1f);
    
    // Update frame data
    frame.frequency_bins = frequency_bins;
    frame.total_energy = total_energy;
    frame.bass_energy = bass_energy;
    frame.mid_energy = mid_energy;
    frame.high_energy = high_energy;
    frame.silence = is_silence;
    frame.transient_detected = transient;  // || beat_detector.isBeat();
    
    // Store for next frame
    last_total_energy = total_energy;
    
    // Update beat metrics (after energy calculation)
    metrics.updateBeatMetrics(transient, transient ? 1.0f : 0.0f, 0.0f, energy_delta);
    
    // Update frame counter
    frameCounter++;
    
    // Update metrics frame  
    metrics.startFrame();
}

void AudioProcessor::printBandGains() {
    if (use_multiband_agc) {
        // multiband_agc.printGains();  // No such method
        ESP_LOGI(TAG, "Multiband AGC enabled");
    } else {
        ESP_LOGI(TAG, "Single-band AGC gain: %.2f", agc.getCurrentGain());
    }
}

void AudioProcessor::setDCOffsetMode(int mode) {
    dc_offset_mode = mode;
    ESP_LOGI(TAG, "DC offset mode set to: %d", mode);
}

void AudioProcessor::printDCSample() {
    if (sample_buffer && CHUNK_SIZE > 0) {
        ESP_LOGI(TAG, "DC Sample[0]: %d", sample_buffer[0]);
    }
}

void AudioProcessor::printAGCState() {
    if (use_multiband_agc) {
        // multiband_agc.printState();  // No such method
        ESP_LOGI(TAG, "Multiband AGC state - Bass/Mid/High gains active");
    } else {
        // agc.printState();  // No such method
        ESP_LOGI(TAG, "AGC State: gain=%.2f, floor=%.2f", 
                 agc.getCurrentGain(), agc.getNoiseFloor());
    }
}

void AudioProcessor::triggerNoiseCalibration() {
    ESP_LOGI(TAG, "Noise calibration triggered");
    noise_floor = 0.0f;
    noise_floor_smooth = 0.0f;
}