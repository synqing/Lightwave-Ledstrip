// LGP Audio-Reactive Effects
// Dual-core optimized audio visualization for Light Guide Plates

#include <FastLED.h>
#include "../../config/hardware_config.h"
#include "../../core/EffectTypes.h"
#include "../../core/PerformanceOptimizer.h"
#include "../../audio/audio_sync.h"

// Create a global audio sync instance
AudioSync audioSync;
#include <math.h>

#ifndef TWO_PI
#define TWO_PI 6.28318530718f
#endif

#ifndef PI
#define PI 3.14159265359f
#endif

// External references
extern CRGB strip1[];
extern CRGB strip2[];
extern CRGBPalette16 currentPalette;
extern uint8_t gHue;
extern uint8_t paletteSpeed;
extern VisualParams visualParams;
// Using AudioSync namespace instead of extern object

// Audio data buffers (shared between cores)
static volatile float bassLevel = 0;
static volatile float midLevel = 0;
static volatile float trebleLevel = 0;
static volatile bool beatDetected = false;
static volatile float spectrumData[16] = {0};

// ============== FREQUENCY COLLISION ==============
// Bass frequencies from one edge, treble from the other
void lgpFrequencyCollision() {
    // Get audio levels
    float bass = audioSync.getBassLevel();
    float mid = audioSync.getMidLevel();
    float treble = audioSync.getTrebleLevel();
    
    float intensity = visualParams.getIntensityNorm();
    float complexity = visualParams.getComplexityNorm();
    
    // Process both strips in a single optimized loop
    for(int i = 0; i < HardwareConfig::STRIP_LENGTH; i++) {
        float distFromCenter = abs(i - HardwareConfig::STRIP_CENTER_POINT);
        float normalizedDist = distFromCenter / HardwareConfig::STRIP_HALF_LENGTH;
        
        // Bass dominates at edges, fades toward center
        float bassInfluence = normalizedDist * bass;
        float midInfluence = (1 - normalizedDist) * mid;
        float trebleInfluence = normalizedDist * treble;
        
        // Strip 1: Bass (red) to mid
        uint8_t brightness1 = (bassInfluence + midInfluence * 0.5f) * 255 * intensity;
        strip1[i] = CHSV(0, 255 - (midInfluence * 100), brightness1);
        
        // Strip 2: Treble (blue) to mid  
        uint8_t brightness2 = (trebleInfluence + midInfluence * 0.5f) * 255 * intensity;
        strip2[i] = CHSV(160, 255 - (midInfluence * 100), brightness2);
    }
}

// ============== BEAT INTERFERENCE ==============
// Beats trigger interference patterns
void lgpBeatInterference() {
    static float interferencePhase = 0;
    static float beatIntensity = 0;
    static uint32_t lastBeatTime = 0;
    
    // Check for beat
    if (audioSync.isBeatDetected()) {
        beatIntensity = 1.0f;
        lastBeatTime = millis();
        interferencePhase = random(0, 100) / 100.0f * TWO_PI;
    }
    
    // Decay beat intensity
    beatIntensity *= 0.95f;
    
    float intensity = visualParams.getIntensityNorm();
    float complexity = visualParams.getComplexityNorm();
    
    // Number of interference nodes
    float nodeCount = 3 + complexity * 10;
    
    for(int i = 0; i < HardwareConfig::STRIP_LENGTH; i++) {
        float distFromCenter = abs(i - HardwareConfig::STRIP_CENTER_POINT);
        float normalizedDist = distFromCenter / HardwareConfig::STRIP_HALF_LENGTH;
        
        // Create interference pattern
        float wave1 = sin(normalizedDist * nodeCount * PI + interferencePhase);
        float wave2 = sin(normalizedDist * nodeCount * PI - interferencePhase);
        
        float interference = (wave1 + wave2) * 0.5f * beatIntensity;
        
        uint8_t brightness = 64 + (191 * abs(interference) * intensity);
        uint8_t hue = gHue + (interference * 50);
        
        // Different phase relationships on each strip
        strip1[i] = CHSV(hue, 255, brightness);
        strip2[i] = CHSV(hue + 128, 255, brightness);
    }
}

// ============== SPECTRAL MORPHING ==============
// Full spectrum visualization morphing between edges
void lgpSpectralMorphing() {
    // Get frequency spectrum (16 bands)
    float spectrum[16];
    audioSync.getFrequencySpectrum(spectrum, 16);
    
    float intensity = visualParams.getIntensityNorm();
    float morphSpeed = paletteSpeed / 255.0f;
    
    static float morphPhase = 0;
    morphPhase += morphSpeed * 0.05f;
    
    // Single loop for perfect sync between strips
    for(int i = 0; i < HardwareConfig::STRIP_LENGTH; i++) {
        float position = (float)i / HardwareConfig::STRIP_LENGTH;
        
        // Map position to frequency band
        int band = position * 16;
        int nextBand = (band + 1) % 16;
        float bandFrac = (position * 16) - band;
        
        // Interpolate between bands
        float level = spectrum[band] * (1 - bandFrac) + spectrum[nextBand] * bandFrac;
        
        // Morph effect for strip 1
        float level1 = level * cos(morphPhase + position * PI);
        
        // Morph effect for strip 2 (inverted)
        float level2 = level * sin(morphPhase + position * PI);
        
        // Color based on frequency
        uint8_t hue = band * 16;  // 0-255 across spectrum
        
        strip1[i] = CHSV(hue, 255, level1 * 255 * intensity);
        strip2[i] = CHSV(hue, 255, level2 * 255 * intensity);
    }
}

// ============== AUDIO QUANTUM COLLAPSE ==============
// Audio levels determine quantum state collapse
void lgpAudioQuantumCollapse() {
    float audioEnergy = audioSync.getEnergyLevel();
    float intensity = visualParams.getIntensityNorm();
    
    static float quantumPhase = 0;
    quantumPhase += audioEnergy * 0.1f;
    
    // Quantum states based on audio
    const int NUM_STATES = 4;
    CHSV quantumStates[NUM_STATES] = {
        CHSV(0, 255, 255),    // Red
        CHSV(96, 255, 255),   // Green  
        CHSV(160, 255, 255),  // Blue
        CHSV(64, 255, 255)    // Yellow
    };
    
    for(int i = 0; i < HardwareConfig::STRIP_LENGTH; i++) {
        float distFromCenter = abs(i - HardwareConfig::STRIP_CENTER_POINT);
        float normalizedDist = distFromCenter / HardwareConfig::STRIP_HALF_LENGTH;
        
        // Wave function probability
        float psi = sin(quantumPhase + normalizedDist * TWO_PI * 3);
        float probability = psi * psi;
        
        // Collapse threshold based on audio
        float collapseThreshold = 1.0f - audioEnergy;
        
        CRGB color;
        if (probability > collapseThreshold) {
            // Collapsed state
            int state = (int)(probability * NUM_STATES) % NUM_STATES;
            color = quantumStates[state];
            color.nscale8(intensity * 255);
        } else {
            // Superposition (all states at once, dimmed)
            color = CRGB::Black;
            for(int s = 0; s < NUM_STATES; s++) {
                CRGB stateColor = quantumStates[s];
                stateColor.nscale8(64 * intensity);
                color += stateColor;
            }
        }
        
        strip1[i] = color;
        strip2[i] = color;
    }
}

// ============== RHYTHM WAVES ==============
// Rhythm patterns create standing waves
void lgpRhythmWaves() {
    static float wavePositions[8] = {0};  // Track up to 8 concurrent waves
    static uint32_t lastBeatTimes[8] = {0};
    static int currentWaveSlot = 0;
    
    float intensity = visualParams.getIntensityNorm();
    float complexity = visualParams.getComplexityNorm();
    
    // Launch new wave on beat
    if (audioSync.isBeatDetected()) {
        wavePositions[currentWaveSlot] = 0;
        lastBeatTimes[currentWaveSlot] = millis();
        currentWaveSlot = (currentWaveSlot + 1) % 8;
    }
    
    // Clear strips
    fadeToBlackBy(strip1, HardwareConfig::STRIP_LENGTH, 20);
    fadeToBlackBy(strip2, HardwareConfig::STRIP_LENGTH, 20);
    
    // Update and render all waves
    for(int w = 0; w < 8; w++) {
        if (millis() - lastBeatTimes[w] < 2000) {  // Wave lifetime: 2 seconds
            wavePositions[w] += 2.0f + complexity * 4.0f;
            
            // Render wave on both strips
            for(int i = 0; i < HardwareConfig::STRIP_LENGTH; i++) {
                float distFromCenter = abs(i - HardwareConfig::STRIP_CENTER_POINT);
                
                // Wave equation
                float waveIntensity = exp(-abs(distFromCenter - wavePositions[w]) * 0.1f);
                
                if (waveIntensity > 0.01f) {
                    uint8_t brightness = waveIntensity * 255 * intensity;
                    uint8_t hue = gHue + (w * 32);  // Different hue per wave
                    
                    strip1[i] += CHSV(hue, 255, brightness);
                    strip2[i] += CHSV(hue + 128, 255, brightness);
                }
            }
        }
    }
}

// ============== ENVELOPE INTERFERENCE ==============
// Audio envelope controls interference intensity
void lgpEnvelopeInterference() {
    float envelope = audioSync.getEnvelope();
    float intensity = visualParams.getIntensityNorm();
    float complexity = visualParams.getComplexityNorm();
    
    static float phase1 = 0, phase2 = 0;
    phase1 += envelope * 0.1f;
    phase2 -= envelope * 0.08f;  // Different speed for complex patterns
    
    // Interference frequency based on complexity
    float freq1 = 2 + complexity * 8;
    float freq2 = 3 + complexity * 7;
    
    for(int i = 0; i < HardwareConfig::STRIP_LENGTH; i++) {
        float distFromCenter = abs(i - HardwareConfig::STRIP_CENTER_POINT);
        float normalizedDist = distFromCenter / HardwareConfig::STRIP_HALF_LENGTH;
        
        // Two waves with envelope-modulated amplitude
        float wave1 = sin(normalizedDist * freq1 * PI + phase1) * envelope;
        float wave2 = sin(normalizedDist * freq2 * PI + phase2) * envelope;
        
        // Interference pattern
        float interference = (wave1 + wave2) * 0.5f;
        
        // Color based on interference
        uint8_t hue = gHue + (interference * 100);
        uint8_t brightness = (128 + 127 * abs(interference)) * intensity;
        
        strip1[i] = CHSV(hue, 255 - abs(interference) * 100, brightness);
        strip2[i] = CHSV(hue + 90, 255 - abs(interference) * 100, brightness);
    }
}

// ============== KICK SHOCKWAVE ==============
// Kick drum creates shockwaves from center
void lgpKickShockwave() {
    static float shockwaveRadius = 0;
    static float shockwaveIntensity = 0;
    static uint32_t lastKickTime = 0;
    
    float intensity = visualParams.getIntensityNorm();
    
    // Detect kick (low frequency beat)
    if (audioSync.isKickDetected()) {
        shockwaveRadius = 0;
        shockwaveIntensity = 1.0f;
        lastKickTime = millis();
    }
    
    // Update shockwave
    if (shockwaveIntensity > 0) {
        shockwaveRadius += 3.0f;
        shockwaveIntensity *= 0.95f;
        
        for(int i = 0; i < HardwareConfig::STRIP_LENGTH; i++) {
            float distFromCenter = abs(i - HardwareConfig::STRIP_CENTER_POINT);
            
            // Shockwave ring
            float ringDistance = abs(distFromCenter - shockwaveRadius);
            float ringIntensity = 0;
            
            if (ringDistance < 5) {
                ringIntensity = (1 - ringDistance / 5) * shockwaveIntensity;
            }
            
            if (ringIntensity > 0) {
                uint8_t brightness = ringIntensity * 255 * intensity;
                CRGB shockColor = CHSV(0, 255, brightness);  // Red shockwave
                
                strip1[i] = blend(strip1[i], shockColor, ringIntensity * 255);
                strip2[i] = blend(strip2[i], shockColor, ringIntensity * 255);
            }
        }
    } else {
        // Ambient pattern when no kick
        fadeToBlackBy(strip1, HardwareConfig::STRIP_LENGTH, 10);
        fadeToBlackBy(strip2, HardwareConfig::STRIP_LENGTH, 10);
    }
}

// ============== FFT COLOR MAP ==============
// Map FFT bins to colors across the strip
void lgpFFTColorMap() {
    const int FFT_BINS = 32;
    float fftData[FFT_BINS];
    audioSync.getFFTData(fftData, FFT_BINS);
    
    float intensity = visualParams.getIntensityNorm();
    float complexity = visualParams.getComplexityNorm();
    
    // Map LED positions to FFT bins
    for(int i = 0; i < HardwareConfig::STRIP_LENGTH; i++) {
        float position = (float)i / HardwareConfig::STRIP_LENGTH;
        
        // Which FFT bin?
        int bin = position * FFT_BINS;
        int nextBin = (bin + 1) % FFT_BINS;
        float binFrac = (position * FFT_BINS) - bin;
        
        // Interpolate between bins
        float magnitude = fftData[bin] * (1 - binFrac) + fftData[nextBin] * binFrac;
        
        // Apply logarithmic scaling
        magnitude = log10(1 + magnitude * 9);
        
        // Color mapping
        uint8_t hue;
        if (complexity < 0.33f) {
            // Rainbow across spectrum
            hue = position * 255;
        } else if (complexity < 0.66f) {
            // Fire colors for low freq, ice for high
            hue = position < 0.5f ? (position * 60) : (160 + position * 40);
        } else {
            // Psychedelic
            hue = gHue + sin(position * TWO_PI * 3) * 128;
        }
        
        uint8_t brightness = magnitude * 255 * intensity;
        
        strip1[i] = CHSV(hue, 255, brightness);
        strip2[i] = CHSV(hue + 128, 255, brightness);
    }
}

// ============== HARMONIC RESONANCE ==============
// Harmonic analysis creates resonance patterns
void lgpHarmonicResonance() {
    // Get harmonic content
    float fundamental = audioSync.getFundamentalFreq();
    float harmonics[8];
    audioSync.getHarmonics(harmonics, 8);
    
    float intensity = visualParams.getIntensityNorm();
    
    // Each harmonic creates a standing wave
    for(int i = 0; i < HardwareConfig::STRIP_LENGTH; i++) {
        float distFromCenter = abs(i - HardwareConfig::STRIP_CENTER_POINT);
        float normalizedDist = distFromCenter / HardwareConfig::STRIP_HALF_LENGTH;
        
        CRGB color = CRGB::Black;
        
        // Sum all harmonic contributions
        for(int h = 0; h < 8; h++) {
            if (harmonics[h] > 0.01f) {
                // Standing wave for this harmonic
                float wavelength = 1.0f / (h + 1);
                float phase = normalizedDist / wavelength * TWO_PI;
                float wave = sin(phase) * harmonics[h];
                
                // Color based on harmonic number
                CHSV harmonicColor = CHSV(h * 32, 255, abs(wave) * 255 * intensity);
                color += harmonicColor;
            }
        }
        
        strip1[i] = color;
        strip2[i] = color;
    }
}

// ============== STEREO PHASE PATTERN ==============
// Phase correlation between stereo channels
void lgpStereoPhasePattern() {
    float leftLevel, rightLevel, correlation;
    audioSync.getStereoAnalysis(leftLevel, rightLevel, correlation);
    
    float intensity = visualParams.getIntensityNorm();
    
    static float phaseOffset = 0;
    phaseOffset += (1 - correlation) * 0.1f;  // More offset when less correlated
    
    for(int i = 0; i < HardwareConfig::STRIP_LENGTH; i++) {
        float position = (float)i / HardwareConfig::STRIP_LENGTH;
        
        // Left channel wave
        float leftWave = sin(position * TWO_PI * 3) * leftLevel;
        
        // Right channel wave with phase offset
        float rightWave = sin(position * TWO_PI * 3 + phaseOffset) * rightLevel;
        
        // Lissajous-like pattern
        uint8_t x = 128 + leftWave * 127;
        uint8_t y = 128 + rightWave * 127;
        
        // Convert to color
        uint8_t hue = (x + y) / 2;
        uint8_t saturation = abs(x - y);
        uint8_t brightness = sqrt(x * x + y * y) / sqrt(2) * intensity;
        
        strip1[i] = CHSV(hue, saturation, brightness);
        strip2[i] = CHSV(hue + 90, saturation, brightness);
    }
}