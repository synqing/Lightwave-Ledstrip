// Integration patch for Visual Feedback System and Advanced Transition Engine
// Add these includes at the top of main.cpp after existing includes:

#include "hardware/EncoderLEDFeedback.h"
#include "effects/transitions/TransitionEngine.h"

// Add these global variables after existing globals (around line 80):

// Visual Feedback System
EncoderLEDFeedback* encoderFeedback = nullptr;

// Advanced Transition Engine
TransitionEngine* transitionEngine = nullptr;
CRGB effectBuffer1[HardwareConfig::NUM_LEDS];
CRGB effectBuffer2[HardwareConfig::NUM_LEDS];
bool useBuffer1 = true;

// Replace the existing startTransition function (around line 124) with:

void startTransition(uint8_t newEffect) {
    if (newEffect == currentEffect) return;
    
    // Initialize transition engine if not already done
    if (!transitionEngine) {
        transitionEngine = new TransitionEngine(HardwareConfig::NUM_LEDS);
        transitionEngine->setDualStripMode(true, HardwareConfig::STRIP_LENGTH);
    }
    
    // Save current LED state to appropriate buffer
    CRGB* currentBuffer = useBuffer1 ? effectBuffer1 : effectBuffer2;
    CRGB* nextBuffer = useBuffer1 ? effectBuffer2 : effectBuffer1;
    
    // Copy current LED state
    memcpy(currentBuffer, leds, sizeof(CRGB) * HardwareConfig::NUM_LEDS);
    
    // Temporarily switch to new effect to render it
    uint8_t tempEffect = currentEffect;
    currentEffect = newEffect;
    
    // Clear leds buffer for new effect
    memset(leds, 0, sizeof(CRGB) * HardwareConfig::NUM_LEDS);
    
    // Render new effect to leds buffer
    effects[newEffect].function();
    
    // Copy new effect to next buffer
    memcpy(nextBuffer, leds, sizeof(CRGB) * HardwareConfig::NUM_LEDS);
    
    // Restore current effect (will be updated when transition completes)
    currentEffect = tempEffect;
    
    // Select transition type based on effect types or random
    TransitionType transType;
    if (random8() < 128) {
        // 50% chance of specific transition
        transType = TransitionEngine::getRandomTransition();
    } else {
        // 50% chance of simple fade for smooth experience
        transType = TRANSITION_FADE;
    }
    
    // Start transition with 1 second duration
    transitionEngine->startTransition(
        currentBuffer, nextBuffer, leds,
        transType, 1000, EASE_IN_OUT_CUBIC
    );
    
    previousEffect = currentEffect;
    currentEffect = newEffect;
    useBuffer1 = !useBuffer1;
    
    // Flash effect encoder to indicate change
    if (encoderFeedback) {
        encoderFeedback->flashEncoder(0, 255, 255, 255, 300);  // White flash
    }
}

// Replace the existing updateTransition function (around line 139) with:

void updateTransition() {
    if (transitionEngine && transitionEngine->isActive()) {
        transitionEngine->update();
        
        // Update LEDs are already in the leds buffer from transition engine
        // No need to do anything else here
    }
}

// Add this function after updateTransition:

void updateEncoderFeedback() {
    if (encoderFeedback && encoderManager.isAvailable()) {
        // Update current effect info
        encoderFeedback->setCurrentEffect(currentEffect, effects[currentEffect].name);
        
        // Update performance metrics (simplified for now)
        float frameTime = 1000.0f / HardwareConfig::DEFAULT_FPS;
        float cpuUsage = (frameTime / 8.33f) * 100.0f;  // Estimate based on target 120 FPS
        encoderFeedback->updatePerformanceMetrics(cpuUsage, HardwareConfig::DEFAULT_FPS);
        
        // Update the LED feedback
        encoderFeedback->update();
    }
}

// In setup() function, add after encoder manager initialization (around line 272):

    // Initialize Visual Feedback System
    if (encoderManager.isAvailable()) {
        M5ROTATE8* encoder = encoderManager.getEncoder();  // You'll need to add this getter
        if (encoder) {
            encoderFeedback = new EncoderLEDFeedback(encoder, &visualParams);
            encoderFeedback->applyDefaultColorScheme();
            Serial.println("âœ… Visual Feedback System initialized");
        }
    }

// In the main loop() function, add after updateTransition() call (find where it's called):

    // Update encoder LED feedback
    updateEncoderFeedback();

// Also in loop(), when processing encoder events, add visual feedback:
// After each encoder event is processed (around line 375-450), add:

                // Flash the encoder that was just adjusted
                if (encoderFeedback) {
                    encoderFeedback->flashEncoder(event.encoder_id, 0, 255, 0, 200);  // Green flash
                }

// For the encoder manager, we need to add a getter method.
// Add this to EncoderManager.h (around line 121):

    // Get encoder instance for VFS
    M5ROTATE8* getEncoder() { return encoderAvailable ? &encoder : nullptr; }

// Integration complete!
// The Visual Feedback System will now show:
// - Dynamic colors on each encoder based on their function
// - Activity flashes when encoders are turned
// - Performance visualization
// - Effect-aware feedback
//
// The Advanced Transition Engine provides:
// - Multiple transition types (fade, wipe, dissolve, zoom, etc.)
// - Smooth easing curves
// - CENTER ORIGIN compliant animations
// - Random transition selection for variety