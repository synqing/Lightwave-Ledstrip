; PlatformIO Configuration for LightwaveOS
;
; ESP32-S3 dual-strip LED controller for Light Guide Plates
; - Actor model (Core 0: network/audio, Core 1: rendering)
; - 100+ centre-origin effects with IEffect plugin interface
; - Audio-reactive via SPH0645 I2S microphone
; - CQRS state, REST API (47 endpoints), WebSocket control
;
; Build commands:
;   pio run                    # Default build (audio-enabled)
;   pio run -t upload          # Build and upload
;   pio run -e native_test     # Unit tests on host
;
; https://docs.platformio.org/page/projectconf.html

[platformio]
default_envs = esp32dev_audio_esv11
description = LightwaveOS - ESP32-S3 LED Control Platform
; Include WiFi credentials from gitignored file (if it exists)
; Copy wifi_credentials.ini.template to wifi_credentials.ini and edit
extra_configs = wifi_credentials.ini

[common]
build_flags =
	-std=gnu++17
	-Werror=deprecated-declarations
	-O3
	-ffast-math
	-funroll-loops
	-D ARDUINO_USB_MODE=1
	-D ARDUINO_USB_CDC_ON_BOOT=1
	-D CONFIG_TINYUSB_CDC_ENABLED=1
	-D DISABLE_ALL_LIBRARY_WARNINGS
	-D CONFIG_ASYNC_TCP_RUNNING_CORE=0
	-D CONFIG_ASYNC_TCP_USE_WDT=0
	; Suppress ESPAsyncWebServer internal logging (eliminates "Too many messages queued" spam).
	; Our own LW_LOG* and structured JSON telemetry handle all WS event logging.
	-D ASYNCWEBSERVER_LOG_CUSTOM
	-I include
	; AsyncWebSocket per-client outgoing frame queue.  With setCloseClientOnQueueFull(false)
	; overflow silently drops frames instead of killing the connection, so this value only
	; controls how many frames can be in-flight before a slow client starts missing updates.
	; 32 msgs * ~500 B * 8 clients worst-case = 128 KB (safe on PSRAM builds).
	-D WS_MAX_QUEUED_MESSAGES=32
	; Use FastLED's custom RMT driver (default) — NOT ESP-IDF's rmt_write_items().
	; The ESP-IDF builtin driver has a portMUX_TYPE spinlock that corrupts during
	; rapid effect transitions, causing fatal assertion in spinlock_acquire().
	; FastLED's custom driver manages RMT channels directly via register access
	; and ISR callbacks, completely avoiding the problematic spinlock.
	-D FASTLED_RMT_BUILTIN_DRIVER=0
	-D FASTLED_ESP32_FLASH_LOCK=0
	-D FASTLED_INTERRUPT_RETRY_COUNT=0
	; RMT safety: cap FastLED internal semaphore wait to 100ms (100 ticks at 1kHz).
	; Prevents infinite block if RMT ISR is swallowed (documented FastLED bug).
	-D FASTLED_RMT_MAX_TICKS_FOR_GTX_SEM=100
	; FastLED RMT4 channel budget is the *index range*, not "number of strips".
	; With default FASTLED_RMT_MEM_BLOCKS=2, valid channel indices step by 2
	; (0, 2 on ESP32-S3). Setting max channels to 2 only exposes index 0,
	; which serialises all controllers onto one RMT channel (~11ms show).
	; Use 4 so two channels (0 and 2) can run in parallel for dual-strip output.
	-D FASTLED_RMT_MAX_CHANNELS=4
	-D CONFIG_FREERTOS_ASSERT_FAIL_ABORT=1
	-D configASSERT_DEFINED=1
	; Stack overflow protection (Method 2: check on context switch)
	-D configCHECK_FOR_STACK_OVERFLOW=2
	-D configUSE_MALLOC_FAILED_HOOK=1
	; FreeRTOS task statistics (required for uxTaskGetSystemState)
	-D configUSE_TRACE_FACILITY=1
	-D configUSE_STATS_FORMATTING_FUNCTIONS=1
	; Heap corruption detection
	-D CONFIG_HEAP_CORRUPTION_DETECTION=1
	-D CONFIG_HEAP_POISONING_COMPREHENSIVE=1
	; Monitoring flags: defined in config/features.h (default 1); override to 0 in RAM-constrained envs e.g. esp32dev_FH4
	; LightwaveOS feature flags
	-D LIGHTWAVEOS_V2=1
	-D FEATURE_ACTOR_SYSTEM=1
	-D FEATURE_PLUGIN_RUNTIME=1
	-D FEATURE_CQRS_STATE=1
	-D FEATURE_HAL_ABSTRACTION=1
	; Network features
	-D FEATURE_WEB_SERVER=1
	; Audio features (always enabled)
	-D FEATURE_AUDIO_SYNC=1
	-D FEATURE_MULTI_DEVICE=1
	; Logging: 0=None, 1=Error, 2=Warn, 3=Info, 4=Debug
	; LW_LOG_LEVEL defined per-environment (not in common to avoid redefinition warnings)

; Shared base configuration for all ESP32-S3 audio builds.
; NOT a buildable environment — use esp32dev_audio_esv11, esp32dev_audio_pipelinecore, etc.
[env:esp32dev_audio_base]
platform = espressif32@6.9.0
; Hardware: ESP32-S3 N16R8 (16MB flash, 8MB PSRAM OPI)
board = esp32-s3-devkitc1-n16r8
framework = arduino
build_src_filter =
	+<*>
	-<hal/esp32p4/>
monitor_speed = 115200
monitor_raw = yes
upload_speed = 115200
board_build.f_cpu = 240000000L
board_build.filesystem = littlefs
board_build.arduino.memory_type = qio_opi
build_unflags = -std=gnu++11
build_flags =
	${common.build_flags}
	-D CORE_DEBUG_LEVEL=4
	-D LW_LOG_LEVEL=4
	${wifi_credentials.build_flags}
	-D FEATURE_EFFECT_VALIDATION=0
	-D BOARD_HAS_PSRAM
lib_ldf_mode = deep+
lib_deps =
	fastled/FastLED@3.10.0
	bblanchon/ArduinoJson@7.0.4
	esp32async/ESPAsyncWebServer@3.9.3
	esp32async/AsyncTCP@3.4.9
; Sync subsystem uses ESP-IDF native esp_websocket_client (no external library needed)

[env:esp32dev_audio_esv11]
extends = env:esp32dev_audio_base
upload_port = /dev/cu.usbmodem101
build_flags =
	${env:esp32dev_audio_base.build_flags}
	-D FEATURE_AUDIO_BACKEND_ESV11=1
; Exclude LWLS audio pipeline logic (analysis, smoothing, tempo/grid).
; ControlBus.cpp IS included: ES path needs Stage B derived features
; (chord, saliency, silence, liveliness) via applyDerivedFeatures().
build_src_filter =
	+<*>
	-<hal/esp32p4/>
	-<audio/AudioCapture.cpp>
	-<audio/GoertzelAnalyzer.cpp>
	-<audio/ChromaAnalyzer.cpp>
	-<audio/AudioBehaviorSelector.cpp>
	-<audio/StyleDetector.cpp>
	-<audio/contracts/MusicalGrid.cpp>
	-<audio/tempo/TempoTracker.cpp>


; K1-Lightwave v2: different GPIO assignment
; LEDs: Top=io7, Bottom=io6. SPH0645: LRCL=io37, DOUT=io38, BCLK=io39. TTP223: io18
; Build: pio run -e esp32dev_audio_esv11_k1v2
; Upload: pio run -e esp32dev_audio_esv11_k1v2 -t upload
[env:esp32dev_audio_esv11_k1v2]
extends = env:esp32dev_audio_esv11
upload_port = /dev/cu.usbmodem21401
build_flags =
	${env:esp32dev_audio_esv11.build_flags}
	-D K1_LED_STRIP1_DATA=6
	-D K1_LED_STRIP2_DATA=7
	-D K1_I2S_LRCL=11
	-D K1_I2S_DOUT=14
	-D K1_I2S_BCLK=13
	-D K1_TTP223_PIN=18

; K1-Lightwave v2 at 32kHz
; Build: pio run -e esp32dev_audio_esv11_k1v2_32khz
[env:esp32dev_audio_esv11_k1v2_32khz]
extends = env:esp32dev_audio_esv11_k1v2
build_flags =
	${env:esp32dev_audio_esv11_k1v2.build_flags}
	-D FEATURE_AUDIO_BACKEND_ESV11_32KHZ=1
	-include src/audio/backends/esv11/EsV11_32kHz_Shim.h

; ESV11 at 32kHz: SPH0645 overclocked, 125 Hz frame rate (2.5x default)
; Build: pio run -e esp32dev_audio_esv11_32khz
; All vendor DSP constants overridden via EsV11_32kHz_Shim.h (-include)
; PSRAM delta: ~+30KB (larger sample_history + novelty buffers)
[env:esp32dev_audio_esv11_32khz]
extends = env:esp32dev_audio_esv11
build_flags =
	${env:esp32dev_audio_esv11.build_flags}
	-D FEATURE_AUDIO_BACKEND_ESV11_32KHZ=1
	-include src/audio/backends/esv11/EsV11_32kHz_Shim.h

; ESP32-S3 primary board + PipelineCore DSP backend (256-bin FFT)
; Build: pio run -e esp32dev_audio_pipelinecore
; Upload: pio run -e esp32dev_audio_pipelinecore -t upload
[env:esp32dev_audio_pipelinecore]
extends = env:esp32dev_audio_base
upload_port = /dev/cu.usbmodem212401
build_flags =
	${env:esp32dev_audio_base.build_flags}
	-D FEATURE_AUDIO_BACKEND_PIPELINECORE=1
build_src_filter =
	+<*>
	-<hal/esp32p4/>
	-<audio/GoertzelAnalyzer.cpp>
	-<audio/ChromaAnalyzer.cpp>
	-<audio/tempo/TempoTracker.cpp>

; Spine16k: PipelineCore DSP at 16kHz/128-hop (DSP Spine v0.1)
; Build: pio run -e esp32dev_audio_spine16k
; Upload: pio run -e esp32dev_audio_spine16k -t upload
[env:esp32dev_audio_spine16k]
extends = env:esp32dev_audio_base
build_flags =
	${env:esp32dev_audio_base.build_flags}
	-D FEATURE_AUDIO_BACKEND_SPINE16K=1
build_src_filter =
	+<*>
	-<hal/esp32p4/>
	-<audio/GoertzelAnalyzer.cpp>
	-<audio/ChromaAnalyzer.cpp>
	-<audio/tempo/TempoTracker.cpp>

; PipelineCore build with MabuTrace for Perfetto timeline visualisation
; Build: pio run -e esp32dev_audio_pipelinecore_trace
; Capture: Connect serial, send 'trace' command, view at ui.perfetto.dev
[env:esp32dev_audio_pipelinecore_trace]
extends = env:esp32dev_audio_pipelinecore
build_flags =
	${env:esp32dev_audio_pipelinecore.build_flags}
	-D FEATURE_MABUTRACE=1
lib_deps =
	${env:esp32dev_audio_pipelinecore.lib_deps}
	mabuware/mabutrace

; Audio-reactive build with per-hop timing instrumentation
; Build: pio run -e esp32dev_audio_benchmark
; Adds ~2.2KB RAM, <0.02% CPU overhead for per-phase timing
[env:esp32dev_audio_benchmark]
extends = env:esp32dev_audio_base
build_flags =
	${env:esp32dev_audio_base.build_flags}
	-D FEATURE_AUDIO_BENCHMARK=1

; Audio-reactive build with MabuTrace for Perfetto timeline visualization
; Build: pio run -e esp32dev_audio_trace
; Capture: Connect serial, send 'trace' command, view at ui.perfetto.dev
; See: docs/debugging/MABUTRACE_GUIDE.md
[env:esp32dev_audio_trace]
extends = env:esp32dev_audio_base
build_flags =
	${env:esp32dev_audio_base.build_flags}
	-D FEATURE_MABUTRACE=1
lib_deps =
	${env:esp32dev_audio_base.lib_deps}
	mabuware/mabutrace

; ESV11 32kHz build with MabuTrace for Perfetto timeline visualisation
; Build: pio run -e esp32dev_audio_esv11_32khz_trace
; Capture: Connect serial, send 'trace' command, view at ui.perfetto.dev
[env:esp32dev_audio_esv11_32khz_trace]
extends = env:esp32dev_audio_esv11_32khz
build_flags =
	${env:esp32dev_audio_esv11_32khz.build_flags}
	-D FEATURE_MABUTRACE=1
lib_deps =
	${env:esp32dev_audio_esv11_32khz.lib_deps}
	mabuware/mabutrace

; ESP32-S3 Secondary Board (SSB) - Custom GPIO mapping
; Build: pio run -e esp32dev_SSB
[env:esp32dev_SSB]
extends = env:esp32dev_audio_base
board = esp32-s3-devkitc-1
board_build.partitions = partitions_4mb.csv
board_upload.flash_size = 4MB
board_build.flash_mode = qio
board_build.f_flash = 80000000L
board_build.psram_type = opi
board_build.arduino.memory_type = qio_opi
build_flags =
	${env:esp32dev_audio_base.build_flags}
	-D BOARD_HAS_PSRAM
	-D PSRAM_SIZE=2097152
	; LED pin overrides (GPIO 10 for Strip 1, GPIO 37 for Strip 2)
	-D LED_STRIP1_PIN=10
	-D LED_STRIP2_PIN=37
	; I2S pin overrides (SPH0645 with SEL=3V3 for right channel)
	-D I2S_LRCL_GPIO=34
	-D I2S_DOUT_GPIO=35
	-D I2S_BCLK_GPIO=33
	-D I2S_CHANNEL_RIGHT=1

; ESP32-S3 FH4R2 - 4MB Flash, 2MB Quad PSRAM — e.g. Waveshare ESP32-S3-Zero (ESP32-S3FH4R2)
; Uses same platform as esp32dev_audio_base (6.9.0) so Arduino 2.x + esp_websocket_client available.
; Override parent's qio_opi: this board has Quad PSRAM. Wrong mode → "opi psram: PSRAM ID read error".
; Build: pio run -e esp32dev_FH4R2
; Upload: pio run -e esp32dev_FH4R2 -t upload --upload-port /dev/cu.usbmodem212401
[env:esp32dev_FH4R2]
extends = env:esp32dev_audio_base
board = esp32-s3-devkitc-1
board_build.partitions = partitions_4mb.csv
board_upload.flash_size = 4MB
board_build.flash_mode = qio
board_build.f_flash = 80000000L
; Quad PSRAM (Waveshare ESP32-S3-Zero). Parent has qio_opi — must override for 2MB Quad PSRAM.
board_build.psram_type = qio
board_build.arduino.memory_type = qio_qspi
build_flags =
	${env:esp32dev_audio_base.build_flags}
	-D BOARD_HAS_PSRAM
	-D PSRAM_SIZE=2097152
	-D WIFI_AP_ONLY=1
	-D AUDIO_SILENCE_GATE_DISABLED=1

; ESP32-S3 FH4R2 + PipelineCore DSP backend
; Build: pio run -e esp32dev_FH4R2_pipelinecore
; Upload: pio run -e esp32dev_FH4R2_pipelinecore -t upload
[env:esp32dev_FH4R2_pipelinecore]
extends = env:esp32dev_FH4R2
upload_port = /dev/cu.usbmodem21401
; No-OTA partition for development (3.4MB app vs 1.8MB with OTA)
board_build.partitions = partitions_4mb_noota.csv
build_flags =
	${env:esp32dev_FH4R2.build_flags}
	-D FEATURE_AUDIO_BACKEND_PIPELINECORE=1
; Exclude Goertzel/ChromaAnalyzer/TempoTracker (replaced by PipelineCore)
; Include AudioCapture (shared), PipelineCore sources auto-discovered
build_src_filter =
	+<*>
	-<hal/esp32p4/>
	-<audio/GoertzelAnalyzer.cpp>
	-<audio/ChromaAnalyzer.cpp>
	-<audio/tempo/TempoTracker.cpp>

; ESP32-S3 FH4 - 4MB Flash, NO PSRAM (internal RAM only). For FH4R2 (has PSRAM) use esp32dev_FH4R2 instead.
; Build: pio run -e esp32dev_FH4
; Upload: pio run -e esp32dev_FH4 -t upload --upload-port /dev/cu.usbmodem*
[env:esp32dev_FH4]
extends = env:esp32dev_audio_base
board = esp32-s3-devkitc-1
board_build.partitions = partitions_4mb.csv
board_upload.flash_size = 4MB
board_build.flash_mode = qio
board_build.f_flash = 80000000L
board_build.filesystem = littlefs
build_flags =
	${env:esp32dev_audio_base.build_flags}
	-D FEATURE_HEAP_MONITORING=0
	-D FEATURE_MEMORY_LEAK_DETECTION=0
	-D FEATURE_VALIDATION_PROFILING=0
	-D FEATURE_STACK_PROFILING=0
	-D FEATURE_TRANSITIONS=0

; Native unit tests (no hardware required)
; Build: pio run -e native_test
; Run:   .pio/build/native_test/program
[env:native_test]
platform = native
build_src_filter =
	-<*>
	+<../test/test_native/*>
	+<../src/codec/ManifestCodec.cpp>
build_flags =
	-std=c++17
	-D NATIVE_BUILD=1
	-D LIGHTWAVEOS_V2=1
	-D NUM_LEDS=320
	-D CENTER_POINT=80
	-D FEATURE_MULTI_DEVICE=1
	-D FEATURE_AUDIO_SYNC=1
	-D LW_LOG_LEVEL=4
	-I test/test_native
	-I test/test_native/mocks
	-I src
	-I src/sync
test_framework = unity
test_build_src = no
test_filter = test_native
test_ignore =
	test_audio
	test_audio_benchmark
	test_native/test_effect_id_limits
	test_native/test_ws_effects_codec
lib_deps =
	throwtheswitch/Unity@^2.5.2
	bblanchon/ArduinoJson@7.0.4

; ES v1.1_320 vendored pipeline parity tests (native)
; Run: pio test -e native_test_esv11
[env:native_test_esv11]
platform = native
build_src_filter =
	-<*>
	+<audio/backends/esv11/vendor/EsV11Shim.cpp>
	+<audio/backends/esv11/vendor/EsV11Buffers.cpp>
build_flags =
	-std=c++17
	-D NATIVE_BUILD=1
	-D LIGHTWAVEOS_V2=1
	-D FEATURE_AUDIO_SYNC=1
	-D FEATURE_AUDIO_BACKEND_ESV11=1
	-I src
test_filter = test_esv11_audio
test_build_src = yes
test_framework = unity
lib_deps =
	throwtheswitch/Unity@^2.5.2
	bblanchon/ArduinoJson@7.0.4

; ESV11 real music tempo test at 12.8 kHz (default)
; Run: pio test -e native_test_esv11_music
[env:native_test_esv11_music]
platform = native
build_src_filter =
	-<*>
	+<audio/backends/esv11/vendor/EsV11Shim.cpp>
	+<audio/backends/esv11/vendor/EsV11Buffers.cpp>
build_flags =
	-std=c++17
	-D NATIVE_BUILD=1
	-D LIGHTWAVEOS_V2=1
	-D FEATURE_AUDIO_SYNC=1
	-D FEATURE_AUDIO_BACKEND_ESV11=1
	-I src
test_filter = test_esv11_music
test_build_src = yes
test_framework = unity
lib_deps =
	throwtheswitch/Unity@^2.5.2

; ESV11 real music tempo test at 32 kHz (with shim overrides)
; Run: pio test -e native_test_esv11_music_32khz
[env:native_test_esv11_music_32khz]
platform = native
build_src_filter =
	-<*>
	+<audio/backends/esv11/vendor/EsV11Shim.cpp>
	+<audio/backends/esv11/vendor/EsV11Buffers.cpp>
build_flags =
	-std=c++17
	-D NATIVE_BUILD=1
	-D LIGHTWAVEOS_V2=1
	-D FEATURE_AUDIO_SYNC=1
	-D FEATURE_AUDIO_BACKEND_ESV11=1
	-D FEATURE_AUDIO_BACKEND_ESV11_32KHZ=1
	-include src/audio/backends/esv11/EsV11_32kHz_Shim.h
	-I src
test_filter = test_esv11_music
test_build_src = yes
test_framework = unity
lib_deps =
	throwtheswitch/Unity@^2.5.2

; ESV11 harmonixset corpus regression gate at 12.8 kHz
; Capture baseline:
;   LW_ESV11_CAPTURE_BASELINE=1 pio test -e native_test_esv11_music_corpus
; Verify gate:
;   pio test -e native_test_esv11_music_corpus
[env:native_test_esv11_music_corpus]
platform = native
build_src_filter =
	-<*>
	+<audio/backends/esv11/vendor/EsV11Shim.cpp>
	+<audio/backends/esv11/vendor/EsV11Buffers.cpp>
build_flags =
	-std=c++17
	-D NATIVE_BUILD=1
	-D LIGHTWAVEOS_V2=1
	-D FEATURE_AUDIO_SYNC=1
	-D FEATURE_AUDIO_BACKEND_ESV11=1
	-I src
test_filter = test_esv11_music_corpus
test_build_src = yes
test_framework = unity
lib_deps =
	throwtheswitch/Unity@^2.5.2

; ESV11 harmonixset corpus regression gate at 32 kHz
; Capture baseline:
;   LW_ESV11_CAPTURE_BASELINE=1 pio test -e native_test_esv11_music_corpus_32khz
; Verify gate:
;   pio test -e native_test_esv11_music_corpus_32khz
[env:native_test_esv11_music_corpus_32khz]
platform = native
build_src_filter =
	-<*>
	+<audio/backends/esv11/vendor/EsV11Shim.cpp>
	+<audio/backends/esv11/vendor/EsV11Buffers.cpp>
build_flags =
	-std=c++17
	-D NATIVE_BUILD=1
	-D LIGHTWAVEOS_V2=1
	-D FEATURE_AUDIO_SYNC=1
	-D FEATURE_AUDIO_BACKEND_ESV11=1
	-D FEATURE_AUDIO_BACKEND_ESV11_32KHZ=1
	-include src/audio/backends/esv11/EsV11_32kHz_Shim.h
	-I src
test_filter = test_esv11_music_corpus
test_build_src = yes
test_framework = unity
lib_deps =
	throwtheswitch/Unity@^2.5.2

; AudioMappingRegistry PSRAM/disabled-state unit tests (native)
; Run: pio test -e native_test_audio_mapping_registry
[env:native_test_audio_mapping_registry]
platform = native
build_src_filter =
	-<*>
	+<audio/contracts/AudioEffectMapping.cpp>
build_flags =
	-std=c++17
	-D NATIVE_BUILD=1
	-D LIGHTWAVEOS_V2=1
	-D FEATURE_AUDIO_SYNC=1
	-D LW_LOG_LEVEL=4
	-I src
test_filter = test_audio_mapping_registry
test_build_src = yes
test_framework = unity
lib_deps =
	throwtheswitch/Unity@^2.5.2

; Isolated manifest codec unit tests (no hardware dependencies)
; Build: pio run -e native_codec_test_manifest
; Run:   .pio/build/native_codec_test_manifest/program
; Only includes ManifestCodec tests to avoid FastLED/audio hardware dependencies
[env:native_codec_test_manifest]
platform = native
build_src_filter =
	-<*>
	+<../test/test_native/test_manifest_codec.cpp>
	+<../src/codec/ManifestCodec.cpp>
build_flags =
	-std=c++17
	-D NATIVE_BUILD=1
	-D LIGHTWAVEOS_V2=1
	-D LW_LOG_LEVEL=4
	-I test/test_native
	-I src
test_framework = unity
test_build_src = no
# test_filter removed: build_src_filter already isolates test_manifest_codec.cpp
# test_ignore ensures other test suites are excluded even if discovered
test_ignore =
	test_effect_id_limits
	test_ws_effects_codec
	test_audio_*
lib_deps =
	throwtheswitch/Unity@^2.5.2
	bblanchon/ArduinoJson@7.0.4

; Isolated codec unit tests (no hardware dependencies)
; Build: pio run -e native_codec_test_ws_effects
; Run:   .pio/build/native_codec_test_ws_effects/program
; Only includes WsEffectsCodec tests to avoid FastLED/audio hardware dependencies
[env:native_codec_test_ws_effects]
platform = native
build_src_filter =
	-<*>
	+<../test/test_native/test_ws_effects_codec.cpp>
	+<../src/codec/WsEffectsCodec.cpp>
build_flags =
	-std=c++17
	-D NATIVE_BUILD=1
	-D LIGHTWAVEOS_V2=1
	-D LW_LOG_LEVEL=4
	-I test/test_native
	-I src
test_framework = unity
test_build_src = no
lib_deps =
	throwtheswitch/Unity@^2.5.2
	bblanchon/ArduinoJson@7.0.4

; Isolated WS codec unit tests (no hardware dependencies)
; Build: pio run -e native_codec_test_ws
; Run:   .pio/build/native_codec_test_ws/program
; Only includes WS codec tests (zones, plugins, etc.) to avoid FastLED/audio hardware dependencies
[env:native_codec_test_ws]
platform = native
build_src_filter =
	-<*>
	+<../src/codec/WsCommonCodec.cpp>
	+<../src/codec/WsAudioCodec.cpp>
	+<../src/codec/HttpAudioCodec.cpp>
	+<../src/codec/WsDeviceCodec.cpp>
	+<../src/codec/WsPaletteCodec.cpp>
	+<../src/codec/WsPluginsCodec.cpp>
	+<../src/codec/WsZonesCodec.cpp>
	+<../src/codec/WsTransitionCodec.cpp>
	+<../src/codec/WsStreamCodec.cpp>
	+<../src/codec/WsNarrativeCodec.cpp>
	+<../src/codec/WsEffectsCodec.cpp>
	+<../src/codec/HttpEffectsCodec.cpp>
	+<../src/codec/HttpTransitionCodec.cpp>
	+<../src/codec/HttpNarrativeCodec.cpp>
	+<../src/codec/HttpSystemCodec.cpp>
	+<../src/codec/HttpDebugCodec.cpp>
	+<../src/codec/HttpPaletteCodec.cpp>
	+<../src/codec/HttpDeviceCodec.cpp>
	+<../src/codec/HttpParameterCodec.cpp>
	+<../src/codec/HttpPluginCodec.cpp>
	+<../src/codec/HttpZoneCodec.cpp>
	+<../src/codec/HttpBatchCodec.cpp>
	+<../src/codec/WsBatchCodec.cpp>
	+<../src/codec/WsColorCodec.cpp>
	+<../src/codec/WsMotionCodec.cpp>
	+<../src/codec/WsDebugCodec.cpp>
	+<../src/codec/WsOtaCodec.cpp>
build_flags =
	-std=c++17
	-D NATIVE_BUILD=1
	-D LIGHTWAVEOS_V2=1
	-D LW_LOG_LEVEL=4
	-I test/test_native
	-I test/test_native/mocks
	-I src
test_framework = unity
test_build_src = yes
test_filter =
	test_ws_plugins_codec
	test_ws_zones_codec
	test_ws_transition_codec
	test_ws_stream_codec
	test_ws_narrative_codec
	test_ws_effects_codec
	test_ws_color_codec
	test_ws_motion_codec
	test_ws_debug_codec
	test_ws_palette_codec
	test_ws_device_codec
	test_ws_audio_codec
	test_http_audio_codec
	test_http_effects_codec
	test_http_transition_codec
	test_http_narrative_codec
	test_http_device_codec
	test_http_palette_codec
	test_http_parameter_codec
	test_http_plugin_codec
	test_http_zone_codec
test_ignore =
	test_native
	test_audio
	test_audio_benchmark
lib_deps =
	throwtheswitch/Unity@^2.5.2
	bblanchon/ArduinoJson@7.0.4

; Audio unit tests (native)
; Run: pio test -e native_test_audio
[env:native_test_audio]
platform = native
build_src_filter =
	-<*>
	+<audio/GoertzelAnalyzer.cpp>
	+<audio/tempo/TempoTracker.cpp>
build_flags =
	-std=c++17
	-D NATIVE_BUILD=1
	-D LIGHTWAVEOS_V2=1
	-D FEATURE_AUDIO_SYNC=1
	-I src
test_filter = test_audio
test_build_src = yes
test_framework = unity
lib_deps =
	throwtheswitch/Unity@^2.5.2

; Audio pipeline benchmark tests (native)
; Build: pio run -e native_audio_benchmark
; Run:   .pio/build/native_audio_benchmark/program
[env:native_audio_benchmark]
platform = native
build_src_filter =
	-<*>
	+<audio/GoertzelAnalyzer.cpp>
	+<audio/tempo/TempoTracker.cpp>
build_flags =
	-std=c++17
	-D NATIVE_BUILD=1
	-D LIGHTWAVEOS_V2=1
	-D FEATURE_AUDIO_SYNC=1
	-D FEATURE_AUDIO_BENCHMARK=1
	-I src
	-I test/test_audio
	-I test/test_native
test_filter = test_audio_benchmark
test_build_src = yes
test_framework = unity
lib_deps =
	throwtheswitch/Unity@^2.5.2

; Spine16k DSP acceptance tests (native)
; Runs actual PipelineCore + BeatTracker against 16kHz WAV test signals.
; Build: pio run -e native_test_spine16k
; Run:   .pio/build/native_test_spine16k/program
[env:native_test_spine16k]
platform = native
build_src_filter =
	-<*>
	+<audio/pipeline/PipelineCore.cpp>
	+<audio/pipeline/BeatTracker.cpp>
build_flags =
	-std=c++17
	-DNATIVE_BUILD=1
	-I src
	-I test/test_spine16k
test_filter = test_spine16k
test_build_src = yes
test_framework = unity
lib_deps =
	throwtheswitch/Unity@^2.5.2

; ============================================================================
; Brightness Floor Perceptual Test (standalone, hardware test)
; Cycles through gamma-corrected brightness levels on WS2812B for dark-room
; evaluation. Minimal firmware — no WiFi, no audio, no effects engine.
; Build: pio run -e test_brightness_floor
; Flash: pio run -e test_brightness_floor -t upload
; Serial: pio device monitor -e test_brightness_floor
; ============================================================================
[env:test_brightness_floor]
platform = espressif32@6.9.0
board = esp32-s3-devkitc1-n16r8
framework = arduino
upload_port = /dev/cu.usbmodem212401
monitor_speed = 115200
monitor_raw = yes
upload_speed = 115200
board_build.f_cpu = 240000000L
board_build.arduino.memory_type = qio_opi
build_unflags = -std=gnu++11
build_flags =
	-std=gnu++17
	-D ARDUINO_USB_MODE=1
	-D ARDUINO_USB_CDC_ON_BOOT=1
	-D CONFIG_TINYUSB_CDC_ENABLED=1
	-D DISABLE_ALL_LIBRARY_WARNINGS
	; Use FastLED's custom RMT driver (matches firmware-v3 production config)
	-D FASTLED_RMT_BUILTIN_DRIVER=0
	-D FASTLED_ESP32_FLASH_LOCK=0
	-D FASTLED_INTERRUPT_RETRY_COUNT=0
	-D FASTLED_RMT_MAX_TICKS_FOR_GTX_SEM=100
	-D FASTLED_RMT_MAX_CHANNELS=4
; Only compile the test source, not the entire src/ tree
build_src_filter =
	-<*>
	+<../test/test_brightness_floor/main.cpp>
lib_deps =
	fastled/FastLED@3.10.0

; ============================================================================
; ESP-NOW Clock Sync Test — MASTER (bare ESP32-S3 FH4, no LEDs, no PSRAM)
; Broadcasts sync pulses via ESP-NOW for clock offset measurement.
; Arena 9 validation: distributed coherence empirical testing.
; Build: pio run -e test_esp_now_sync_master
; Flash: pio run -e test_esp_now_sync_master -t upload
; Serial: pio device monitor -e test_esp_now_sync_master
; ============================================================================
[env:test_esp_now_sync_master]
platform = espressif32@6.9.0
board = esp32-s3-devkitc1-n16r8
framework = arduino
upload_port = /dev/cu.usbmodem212401
monitor_speed = 115200
monitor_raw = yes
upload_speed = 115200
board_build.f_cpu = 240000000L
board_build.arduino.memory_type = qio_opi
build_unflags = -std=gnu++11
build_flags =
	-std=gnu++17
	-D ARDUINO_USB_MODE=1
	-D ARDUINO_USB_CDC_ON_BOOT=1
	-D CONFIG_TINYUSB_CDC_ENABLED=1
	-D DISABLE_ALL_LIBRARY_WARNINGS
; Only compile the test source, not the entire src/ tree
build_src_filter =
	-<*>
	+<../test/test_esp_now_sync_master/main.cpp>

; ============================================================================
; ESP-NOW Clock Sync Test — SLAVE (ESP32-S3 N16R8 on usbmodem1101)
; Receives sync pulses from master, computes clock offset statistics.
; Arena 9 validation: distributed coherence empirical testing.
; Build: pio run -e test_esp_now_sync_slave
; Flash: pio run -e test_esp_now_sync_slave -t upload
; Serial: pio device monitor -e test_esp_now_sync_slave
; ============================================================================
[env:test_esp_now_sync_slave]
platform = espressif32@6.9.0
board = esp32-s3-devkitc1-n16r8
framework = arduino
upload_port = /dev/cu.usbmodem1101
monitor_speed = 115200
monitor_raw = yes
upload_speed = 115200
board_build.f_cpu = 240000000L
board_build.arduino.memory_type = qio_opi
build_unflags = -std=gnu++11
build_flags =
	-std=gnu++17
	-D ARDUINO_USB_MODE=1
	-D ARDUINO_USB_CDC_ON_BOOT=1
	-D CONFIG_TINYUSB_CDC_ENABLED=1
	-D DISABLE_ALL_LIBRARY_WARNINGS
; Only compile the test source, not the entire src/ tree
build_src_filter =
	-<*>
	+<../test/test_esp_now_sync_slave/main.cpp>

; ============================================================================
; ESP-NOW Clock Sync Test — SLAVE on K1-Lightwave (N16R8, QIO)
; Same slave code but targeting the Lightwave board on usbmodem212401
; ============================================================================
[env:test_esp_now_sync_slave_lightwave]
platform = espressif32@6.9.0
board = esp32-s3-devkitc1-n16r8
framework = arduino
upload_port = /dev/cu.usbmodem212401
monitor_speed = 115200
monitor_raw = yes
board_build.f_cpu = 240000000L
board_build.arduino.memory_type = qio_opi
build_unflags = -std=gnu++11
build_flags =
	-std=gnu++17
	-D ARDUINO_USB_MODE=1
	-D ARDUINO_USB_CDC_ON_BOOT=1
	-D CONFIG_TINYUSB_CDC_ENABLED=1
	-D DISABLE_ALL_LIBRARY_WARNINGS
build_src_filter =
	-<*>
	+<../test/test_esp_now_sync_slave/main.cpp>
