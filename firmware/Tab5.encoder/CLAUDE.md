<claude-mem-context>
# Recent Activity

<!-- This section is auto-generated by claude-mem. Edit content outside the tags. -->

### Jan 7, 2026

| ID | Time | T | Title | Read |
|----|------|---|-------|------|
| #12164 | 1:16 PM | ‚úÖ | Comprehensive Tab5.encoder Agent Guidance Documentation Created | ~841 |
| #12163 | 1:13 PM | üîµ | Tab5.encoder CLAUDE.md Remains Empty After PRISM Migration | ~386 |
| #12162 | 1:12 PM | ‚úÖ | Tab5.encoder README Comprehensively Updated for LVGL Architecture | ~1068 |
| #12153 | 6:38 AM | ‚úÖ | PRISM Firmware Migration Completed with LVGL Configuration | ~565 |
| #12148 | 6:36 AM | üîµ | CLAUDE.md File Empty in Copied Implementation | ~312 |
| #12128 | 6:20 AM | üîµ | PlatformIO Configuration for ESP32-P4 RISC-V Build | ~471 |
| #12127 | " | üîµ | Tab5.encoder ESP32-P4 Firmware Architecture | ~609 |
</claude-mem-context>

# Tab5.encoder - Agent Guidance

**Architecture:** LVGL 9.3.0 Widget-Based UI
**Last Updated:** 2026-01-07
**Hardware:** M5Stack Tab5 (ESP32-P4 RISC-V) + Dual M5ROTATE8 (16 encoders)

## What Is This?

Tab5.encoder is a **professional hardware controller** for LightwaveOS v2, featuring:
- **LVGL 9.3.0 UI** with radial gauges, preset banks, and touch controls
- **Dual M5ROTATE8** units (16 rotary encoders total)
- **8-Bank Preset System** with save/recall/delete functionality
- **WebSocket Sync** with bidirectional parameter updates
- **ESP32-P4 RISC-V** architecture (NOT Xtensa!)

This is a **complete rewrite** from the simple 8-encoder version, migrated from PRISM.tab5 on 2026-01-07.

---

## CRITICAL: ESP32-P4 RISC-V Build Requirements

**‚ö†Ô∏è THIS IS NOT AN ESP32-S3. DIFFERENT ARCHITECTURE. DIFFERENT TOOLCHAIN.**

### ‚õî NEVER Use These Commands:

```bash
# ‚ùå WRONG - Missing PATH isolation
pio run -e tab5 -d firmware/Tab5.encoder

# ‚ùå WRONG - Never cd into directory
cd firmware/Tab5.encoder && pio run -e tab5
```

### ‚úÖ ALWAYS Use These Commands:

**From repository root (`Lightwave-Ledstrip/`):**

```bash
# Build:
PATH="/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin" pio run -e tab5 -d firmware/Tab5.encoder

# Build + Upload:
PATH="/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin" pio run -e tab5 -t upload -d firmware/Tab5.encoder

# Monitor:
pio device monitor -d firmware/Tab5.encoder -b 115200
```

**Why?** The `scripts/pio_pre.py` hook injects the RISC-V toolchain. A clean PATH is REQUIRED.

---

## Architecture Overview

### UI Stack (LVGL 9.3.0)

```
LVGL 9.3.0 Widget Framework
  ‚îú‚îÄ‚îÄ GaugeWidget (radial parameter display)
  ‚îú‚îÄ‚îÄ PresetBankWidget (8-slot manager)
  ‚îî‚îÄ‚îÄ ActionRowWidget (touch actions)
       ‚Üì
lvgl_bridge (M5GFX ‚Üî LVGL)
  ‚îî‚îÄ‚îÄ ESP32-P4 PPA acceleration
       ‚Üì
M5GFX (hardware display driver)
  ‚îî‚îÄ‚îÄ ILI9881C / ST7123 auto-detect
```

### Control Flow

```
M5ROTATE8 Unit A (0x42) ‚Üí Encoders 0-7 ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
M5ROTATE8 Unit B (0x41) ‚Üí Buttons 8-15 ‚îÄ‚îÄ‚îÄ‚îÄ‚îú‚îÄ‚Üí DualEncoderService
                                           ‚îÇ      ‚Üì
                                           ‚îÇ  ParameterHandler
                                           ‚îÇ      ‚Üì
                                           ‚îÇ  WebSocketClient
                                           ‚îÇ      ‚Üì
                                           ‚îî‚îÄ‚Üí LightwaveOS v2
```

---

## Key Design Principles

### 1. LVGL Widget-Based Architecture

**DO:** Use LVGL primitives (`lv_obj_create`, `lv_label_create`, `lv_arc_create`), follow object hierarchy (parent ‚Üí child), use event callbacks for interactions.

**DON'T:** Draw directly to framebuffer, mix M5GFX canvas drawing with LVGL widgets, forget object parents (causes memory leaks), block in LVGL callbacks.

### 2. Dual M5ROTATE8 Same-Bus Operation

Both units share the **same I2C bus** (Grove Port.A) with **different addresses**:
- Unit A @ 0x42 (reprogrammed via register 0xFF)
- Unit B @ 0x41 (factory default)

I2C transactions must be sequenced. No aggressive recovery (Tab5 internal bus safety).

### 3. WebSocket Bidirectional Sync

**Anti-Snapback Pattern:** 1-second holdoff after encoder turn prevents server echo snapback.

### 4. 8-Bank Preset System

**Button Patterns:** Single click (recall), Double click (save), Long hold (delete)

**Data Captured:** All 8 global parameters + zone composer state, stored in NVS flash.

---

## File Organization

See README.md for detailed project structure.

Key layers: `src/ui/` (LVGL widgets), `src/input/` (encoders), `src/network/` (WiFi/WebSocket), `src/storage/` (NVS persistence)

---

## Common Tasks for Agents

### Adding a New Widget

1. Create class in `src/ui/widgets/` with LVGL object creation
2. Register with DisplayUI in `DisplayUI::begin()`

### Modifying Parameter Ranges

1. Update `Config.h` (ParamRange namespace)
2. Update README.md parameter table
3. No code changes needed - `EncoderProcessing` uses Config.h automatically

### Adding WebSocket Message

1. Define in `WsMessageRouter.h`
2. Add router case in `WsMessageRouter.cpp`
3. Implement handler

---

## Agent Selection Guide

- **LVGL UI Development** ‚Üí `agent-lvgl-uiux`
- **Hardware/Firmware** ‚Üí `embedded-system-engineer`
- **Network/API** ‚Üí `network-api-engineer`

---

## Protected Files

- `src/ui/lvgl_bridge.cpp` - M5GFX ‚Üî LVGL integration (display crashes if wrong)
- `src/input/DualEncoderService.h` - Dual I2C management (race conditions = bus lockup)
- `src/network/WiFiManager.cpp` - Complex state machine (bugs = connection failures)

---

## Common Pitfalls

1. **Using Wrong Build Command** ‚Üí Use exact PATH prefix above
2. **Modifying Unit B Encoder Processing** ‚Üí Intentionally disabled (buttons only)
3. **Blocking in LVGL Callbacks** ‚Üí Never use `delay()` in event callbacks
4. **Forgetting LVGL Object Parents** ‚Üí Always set parent
5. **Aggressive I2C Recovery** ‚Üí Use `I2CRecovery::softRecover()` only

---

## Testing Checklist

```
[ ] Build succeeds with RISC-V toolchain
[ ] WiFi connects (Primary + AP fallback)
[ ] WebSocket syncs bidirectionally (no snapback)
[ ] Preset save/recall/delete works
[ ] Touch long-press resets parameters
[ ] Connection status LEDs accurate
[ ] No memory leaks (monitor heap)
[ ] No I2C bus lockups (24hr soak test)
```

---

## Resources

- **LVGL Docs:** https://docs.lvgl.io/9.3/
- **M5Stack Tab5:** https://docs.m5stack.com/en/core/M5Stack_Tab5
- **ESP32-P4:** RISC-V architecture (NOT Xtensa)

---

**Remember:** This is a **production-grade hardware controller**. Code quality, reliability, and user experience matter.