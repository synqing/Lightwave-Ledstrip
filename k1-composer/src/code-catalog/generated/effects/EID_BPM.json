{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_BPM",
  "effectIdHex": "0x0106",
  "className": "BPMEffect",
  "displayName": "BPM",
  "headerPath": "firmware/v2/src/effects/ieffect/BPMEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/BPMEffect.cpp",
  "renderRange": [
    61,
    194
  ],
  "phaseRanges": {
    "input": [
      [
        74,
        74
      ],
      [
        78,
        79
      ],
      [
        102,
        102
      ],
      [
        112,
        113
      ]
    ],
    "mapping": [
      [
        67,
        67
      ],
      [
        94,
        95
      ],
      [
        128,
        128
      ],
      [
        158,
        158
      ]
    ],
    "modulation": [
      [
        76,
        76
      ],
      [
        81,
        81
      ],
      [
        83,
        83
      ],
      [
        86,
        88
      ],
      [
        90,
        90
      ],
      [
        93,
        93
      ],
      [
        110,
        110
      ],
      [
        112,
        114
      ],
      [
        126,
        126
      ],
      [
        128,
        129
      ],
      [
        154,
        154
      ],
      [
        157,
        157
      ],
      [
        162,
        162
      ]
    ],
    "render": [
      [
        134,
        134
      ],
      [
        147,
        147
      ],
      [
        149,
        149
      ],
      [
        166,
        166
      ],
      [
        181,
        181
      ],
      [
        184,
        184
      ],
      [
        186,
        186
      ],
      [
        190,
        190
      ]
    ],
    "post": [
      [
        132,
        132
      ],
      [
        137,
        137
      ]
    ],
    "output": [
      [
        149,
        149
      ],
      [
        186,
        186
      ],
      [
        188,
        190
      ]
    ]
  },
  "mappingConfidence": "high",
  "mappingWarnings": [],
  "sourceText": "/**\n * @file BPMEffect.cpp\n * @brief BPM effect v2 - Dual-layer beat-synced traveling waves + expanding rings\n *\n * v2 COMPLETE REWRITE - Fixes fundamental design flaw\n *\n * ORIGINAL BUG: No wave propagation at all!\n *   - `intensity = beat - distFromCenter*3` was a STATIC gradient\n *   - All LEDs pulsed simultaneously (nothing traveled)\n *   - chromagram color sum produced muddy/washed out colors\n *\n * v2 FIX: Proper dual-layer architecture\n *   - LAYER 1: Background traveling sine wave from center\n *   - LAYER 2: Beat-triggered expanding rings overlay\n *   - Palette-based colors (no chromagram)\n *   - v8 Spring pattern for smooth speed modulation\n */\n\n#include \"BPMEffect.h\"\n#include \"../CoreEffects.h\"\n#include <FastLED.h>\n#include <cmath>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nBPMEffect::BPMEffect()\n    : m_phase(0.0f)\n    , m_nextRing(0)\n    , m_tempoLocked(false)\n{\n}\n\nbool BPMEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n\n    // Initialize phase\n    m_phase = 0.0f;\n    \n    // Initialize smoothing\n    m_heavyEnergySmooth = 0.0f;\n    m_heavyEnergySmoothInitialized = false;\n\n    // Initialize Spring with stiffness=50, critically damped (matches v8 pattern)\n    m_speedSpring.init(50.0f, 1.0f);\n    m_speedSpring.reset(1.0f);\n\n    // Clear ring buffer\n    for (int r = 0; r < MAX_RINGS; r++) {\n        m_ringRadius[r] = 0.0f;\n        m_ringIntensity[r] = 0.0f;\n    }\n    m_nextRing = 0;\n\n    m_tempoLocked = false;\n\n    return true;\n}\n\nvoid BPMEffect::render(plugins::EffectContext& ctx) {\n    // =========================================================================\n    // SAFE DELTA TIME (clamped for physics stability)\n    // =========================================================================\n    float rawDt = ctx.getSafeRawDeltaSeconds();\n    float dt = ctx.getSafeDeltaSeconds();\n    float speedNorm = ctx.speed / 50.0f;\n\n    // Default values for no-audio mode\n    float speedMult = 1.0f;\n    float expansionRate = 80.0f;\n\n#if FEATURE_AUDIO_SYNC\n    if (ctx.audio.available) {\n        // =====================================================================\n        // v8 SPEED MODULATION: heavy_bands → EMA smoothing → Spring\n        // =====================================================================\n        float rawHeavyEnergy = (ctx.audio.controlBus.heavy_bands[1] +\n                                 ctx.audio.controlBus.heavy_bands[2]) / 2.0f;\n        \n        // EMA smoothing with frame-rate-independent alpha (tau = 50ms)\n        const float tau = 0.05f;\n        float alpha = 1.0f - expf(-rawDt / tau);\n        \n        // CRITICAL: Initialize to raw value on first frame (no ramp-from-zero)\n        if (!m_heavyEnergySmoothInitialized) {\n            m_heavyEnergySmooth = rawHeavyEnergy;\n            m_heavyEnergySmoothInitialized = true;\n        } else {\n            m_heavyEnergySmooth += (rawHeavyEnergy - m_heavyEnergySmooth) * alpha;\n        }\n        \n        float heavyEnergy = m_heavyEnergySmooth;\n        float targetSpeed = 0.6f + 0.8f * heavyEnergy;  // 0.6-1.4x range\n        speedMult = m_speedSpring.update(targetSpeed, rawDt);\n        if (speedMult > 1.6f) speedMult = 1.6f;\n        if (speedMult < 0.3f) speedMult = 0.3f;\n\n        // =====================================================================\n        // TEMPO LOCK HYSTERESIS\n        // =====================================================================\n        float tempoConf = ctx.audio.tempoConfidence();\n        if (tempoConf > 0.6f) m_tempoLocked = true;\n        else if (tempoConf < 0.4f) m_tempoLocked = false;\n\n        // Expansion rate scales with tempo confidence\n        expansionRate = 80.0f * (0.5f + tempoConf);\n\n        // =====================================================================\n        // BEAT RING SPAWNING\n        // =====================================================================\n        if (ctx.audio.isOnBeat()) {\n            float strength = ctx.audio.beatStrength();\n            // Scale by confidence for gentler response on uncertain beats\n            float weightedStrength = strength * (0.5f + 0.5f * tempoConf);\n\n            // Spawn new ring\n            m_ringRadius[m_nextRing] = 0.0f;\n            m_ringIntensity[m_nextRing] = weightedStrength;\n            m_nextRing = (m_nextRing + 1) % MAX_RINGS;\n        }\n    }\n#endif\n\n    // =========================================================================\n    // PHASE ACCUMULATION (standard formula from working effects)\n    // =========================================================================\n    m_phase += speedNorm * 240.0f * speedMult * dt;\n    if (m_phase > 628.3f) m_phase -= 628.3f;  // Wrap at ~100*2π\n\n    // =========================================================================\n    // UPDATE RING RADII (expand outward, fade as they go)\n    // =========================================================================\n    for (int r = 0; r < MAX_RINGS; r++) {\n        if (m_ringIntensity[r] > 0.01f) {\n            m_ringRadius[r] += expansionRate * dt;\n            m_ringIntensity[r] *= powf(0.97f, rawDt * 60.0f);  // Gradual fade (dt-corrected)\n\n            // Kill ring when it reaches edge\n            if (m_ringRadius[r] > HALF_LENGTH) {\n                m_ringIntensity[r] = 0.0f;\n            }\n        }\n    }\n\n    // =========================================================================\n    // DUAL-LAYER RENDER LOOP\n    // =========================================================================\n    for (uint16_t i = 0; i < STRIP_LENGTH; i++) {\n        float dist = (float)centerPairDistance(i);\n\n        // =====================================================================\n        // LAYER 1: Background traveling sine wave from center\n        // sin(dist * freq - phase) → OUTWARD motion when phase increases\n        // =====================================================================\n        float waveFreq = 0.12f;  // ~52 LED wavelength\n        float wave = sinf(dist * waveFreq - m_phase);\n        // Map [-1,1] to [0.2, 0.8] for subtle background\n        uint8_t baseIntensity = (uint8_t)((wave * 0.3f + 0.5f) * ctx.brightness);\n\n        // =====================================================================\n        // LAYER 2: Beat rings overlay\n        // Each ring is a Gaussian-ish bump that expands from center\n        // =====================================================================\n        uint8_t ringBoost = 0;\n        for (int r = 0; r < MAX_RINGS; r++) {\n            if (m_ringIntensity[r] > 0.01f) {\n                float delta = fabsf(dist - m_ringRadius[r]);\n                if (delta < 6.0f) {\n                    // Soft falloff within 6 LEDs of ring center\n                    float ringBright = (1.0f - delta / 6.0f) * m_ringIntensity[r];\n                    ringBoost = qadd8(ringBoost, (uint8_t)(ringBright * 180.0f));\n                }\n            }\n        }\n\n        // Combine layers\n        uint8_t intensity = qadd8(baseIntensity, ringBoost);\n\n        // =====================================================================\n        // PALETTE-BASED COLOR (NO chromagram - causes muddy colors!)\n        // =====================================================================\n        uint8_t hue = ctx.gHue + (uint8_t)(dist / 3);\n        CRGB color = ctx.palette.getColor(hue, intensity);\n\n        ctx.leds[i] = color;\n\n        // Strip 2: Complementary color (+128 hue offset)\n        if (i + STRIP_LENGTH < ctx.ledCount) {\n            ctx.leds[i + STRIP_LENGTH] = ctx.palette.getColor(\n                (uint8_t)(hue + 128), intensity);\n        }\n    }\n}\n\nvoid BPMEffect::cleanup() {\n    // No resources to free\n}\n\nconst plugins::EffectMetadata& BPMEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"BPM\",\n        \"v2: Traveling waves + beat-triggered expanding rings from center\",\n        plugins::EffectCategory::PARTY,\n        1\n    };\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
