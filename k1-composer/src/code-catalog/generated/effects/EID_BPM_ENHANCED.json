{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_BPM_ENHANCED",
  "effectIdHex": "0x0E00",
  "className": "BPMEnhancedEffect",
  "displayName": "BPM Enhanced",
  "headerPath": "firmware/v2/src/effects/ieffect/BPMEnhancedEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/BPMEnhancedEffect.cpp",
  "renderRange": [
    66,
    323
  ],
  "phaseRanges": {
    "input": [
      [
        82,
        82
      ],
      [
        86,
        86
      ],
      [
        88,
        92
      ],
      [
        99,
        99
      ],
      [
        105,
        105
      ],
      [
        153,
        153
      ],
      [
        165,
        165
      ],
      [
        206,
        207
      ],
      [
        291,
        291
      ]
    ],
    "mapping": [
      [
        72,
        73
      ],
      [
        84,
        84
      ],
      [
        89,
        89
      ],
      [
        91,
        92
      ],
      [
        101,
        101
      ],
      [
        103,
        103
      ],
      [
        105,
        105
      ],
      [
        109,
        113
      ],
      [
        118,
        118
      ],
      [
        129,
        130
      ],
      [
        181,
        181
      ],
      [
        188,
        188
      ],
      [
        203,
        203
      ],
      [
        208,
        208
      ],
      [
        210,
        211
      ],
      [
        262,
        262
      ]
    ],
    "modulation": [
      [
        91,
        91
      ],
      [
        109,
        109
      ],
      [
        111,
        111
      ],
      [
        115,
        115
      ],
      [
        117,
        117
      ],
      [
        121,
        121
      ],
      [
        123,
        124
      ],
      [
        127,
        127
      ],
      [
        147,
        147
      ],
      [
        152,
        153
      ],
      [
        157,
        157
      ],
      [
        181,
        183
      ],
      [
        188,
        190
      ],
      [
        195,
        195
      ],
      [
        199,
        200
      ],
      [
        202,
        203
      ],
      [
        205,
        205
      ],
      [
        207,
        208
      ],
      [
        211,
        213
      ],
      [
        215,
        215
      ],
      [
        218,
        219
      ],
      [
        222,
        224
      ],
      [
        226,
        227
      ],
      [
        258,
        258
      ],
      [
        261,
        261
      ],
      [
        269,
        269
      ]
    ],
    "render": [
      [
        98,
        98
      ],
      [
        104,
        104
      ],
      [
        116,
        116
      ],
      [
        223,
        224
      ],
      [
        233,
        233
      ],
      [
        248,
        248
      ],
      [
        251,
        251
      ],
      [
        253,
        253
      ],
      [
        273,
        273
      ],
      [
        294,
        295
      ],
      [
        299,
        299
      ],
      [
        303,
        303
      ],
      [
        305,
        306
      ],
      [
        308,
        308
      ],
      [
        313,
        313
      ],
      [
        315,
        316
      ],
      [
        318,
        318
      ]
    ],
    "post": [
      [
        195,
        195
      ],
      [
        205,
        205
      ],
      [
        215,
        215
      ],
      [
        222,
        222
      ],
      [
        231,
        231
      ],
      [
        236,
        236
      ],
      [
        246,
        246
      ],
      [
        248,
        248
      ]
    ],
    "output": [
      [
        253,
        253
      ],
      [
        295,
        295
      ],
      [
        297,
        299
      ],
      [
        306,
        308
      ],
      [
        316,
        318
      ]
    ]
  },
  "mappingConfidence": "high",
  "mappingWarnings": [],
  "sourceText": "/**\n * @file BPMEnhancedEffect.cpp\n * @brief BPM Enhanced effect - Enhanced version with 64-bin spectrum, heavy_chroma, beatPhase sync\n */\n\n#include \"BPMEnhancedEffect.h\"\n#include \"ChromaUtils.h\"\n#include \"../CoreEffects.h\"\n#include <FastLED.h>\n#include <cmath>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nBPMEnhancedEffect::BPMEnhancedEffect()\n    : m_phase(0.0f)\n    , m_nextRing(0)\n    , m_tempoLocked(false)\n    , m_fallbackPhase(0.0f)\n{\n}\n\nbool BPMEnhancedEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n\n    // Initialize phase\n    m_phase = 0.0f;\n    m_fallbackPhase = 0.0f;\n\n    // Initialize Spring with stiffness=50, critically damped\n    m_speedSpring.init(50.0f, 1.0f);\n    m_speedSpring.reset(1.0f);\n    \n    // Initialize smoothing followers\n    m_heavyEnergyFollower.reset(0.0f);\n    m_beatStrengthFollower.reset(0.0f);\n    m_tempoConfFollower.reset(0.0f);\n    m_subBassFollower.reset(0.0f);\n    m_lastHopSeq = 0;\n    m_targetHeavyEnergy = 0.0f;\n    m_targetBeatStrength = 0.0f;\n    m_targetTempoConf = 0.0f;\n    m_targetSubBass = 0.0f;\n\n    // Initialize chromagram smoothing\n    for (uint8_t i = 0; i < 12; i++) {\n        m_chromaFollowers[i].reset(0.0f);\n        m_chromaSmoothed[i] = 0.0f;\n        m_chromaTargets[i] = 0.0f;\n    }\n    m_chromaAngle = 0.0f;\n\n    // Clear ring buffer\n    for (int r = 0; r < MAX_RINGS; r++) {\n        m_ringRadius[r] = 0.0f;\n        m_ringIntensity[r] = 0.0f;\n    }\n    m_nextRing = 0;\n\n    m_tempoLocked = false;\n\n    return true;\n}\n\nvoid BPMEnhancedEffect::render(plugins::EffectContext& ctx) {\n    // =========================================================================\n    // SAFE DELTA TIME (clamped for physics stability)\n    // =========================================================================\n    float rawDt = ctx.getSafeRawDeltaSeconds();\n    float dt = ctx.getSafeDeltaSeconds();\n    float speedNorm = ctx.speed / 50.0f;\n    float moodNorm = ctx.getMoodNormalized();\n\n    // Default values for no-audio mode\n    float speedMult = 1.0f;\n    float expansionRate = 80.0f;\n    float subBassEnergy = 0.0f;\n    uint8_t chromaHueOffset = 0;\n\n#if FEATURE_AUDIO_SYNC\n    if (ctx.audio.available) {\n        // =====================================================================\n        // Hop-based updates: update targets only on new hops\n        // =====================================================================\n        bool newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n        if (newHop) {\n            m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n            m_targetHeavyEnergy = (ctx.audio.controlBus.heavy_bands[1] +\n                                   ctx.audio.controlBus.heavy_bands[2]) / 2.0f;\n            m_targetBeatStrength = ctx.audio.beatStrength();\n            m_targetTempoConf = ctx.audio.tempoConfidence();\n            \n            // =================================================================\n            // 64-bin Sub-Bass Detection (bins 0-5 = ~110-155 Hz)\n            // =================================================================\n            float subBassSum = 0.0f;\n            for (uint8_t i = 0; i < 6; ++i) {\n                subBassSum += ctx.audio.bin(i);\n            }\n            m_targetSubBass = subBassSum / 6.0f;\n            \n            // Update chromagram targets (use heavy_chroma for stability)\n            for (uint8_t i = 0; i < 12; i++) {\n                m_chromaTargets[i] = ctx.audio.controlBus.heavy_chroma[i];\n            }\n        }\n        \n        // Smooth toward targets every frame with MOOD-adjusted smoothing\n        float heavyEnergy = m_heavyEnergyFollower.updateWithMood(m_targetHeavyEnergy, rawDt, moodNorm);\n        float beatStrength = m_beatStrengthFollower.updateWithMood(m_targetBeatStrength, rawDt, moodNorm);\n        float tempoConf = m_tempoConfFollower.updateWithMood(m_targetTempoConf, rawDt, moodNorm);\n        subBassEnergy = m_subBassFollower.updateWithMood(m_targetSubBass, rawDt, moodNorm);\n        \n        // Smooth chromagram with AsymmetricFollower\n        for (uint8_t i = 0; i < 12; i++) {\n            m_chromaSmoothed[i] = m_chromaFollowers[i].updateWithMood(\n                m_chromaTargets[i], rawDt, moodNorm);\n        }\n        \n        // Circular weighted mean + circular EMA for smooth, continuous hue.\n        // Eliminates argmax discontinuities AND temporal chroma shifts.\n        chromaHueOffset = effects::chroma::circularChromaHueSmoothed(\n            m_chromaSmoothed, m_chromaAngle, rawDt, 0.20f);\n        \n        // =====================================================================\n        // v8 SPEED MODULATION: heavy_bands → Spring (NO stacked smoothing!)\n        // =====================================================================\n        float targetSpeed = 0.6f + 0.8f * heavyEnergy;  // 0.6-1.4x range\n        speedMult = m_speedSpring.update(targetSpeed, dt);\n        if (speedMult > 1.6f) speedMult = 1.6f;\n        if (speedMult < 0.3f) speedMult = 0.3f;\n\n        // =====================================================================\n        // TEMPO LOCK HYSTERESIS\n        // =====================================================================\n        if (tempoConf > 0.6f) m_tempoLocked = true;\n        else if (tempoConf < 0.4f) m_tempoLocked = false;\n\n        // Expansion rate scales with tempo confidence\n        // Use sqrt for gentler curve, add minimum floor for visibility\n        float confFactor = sqrtf(tempoConf) * 1.5f;\n        confFactor = fmaxf(0.3f, confFactor);  // Minimum 0.3 floor when confidence low\n        expansionRate = 80.0f * (0.5f + confFactor);\n\n        // =====================================================================\n        // BEAT RING SPAWNING (enhanced with beatPhase sync and snare triggers)\n        // =====================================================================\n        bool shouldSpawnRing = false;\n        float ringIntensity = 0.0f;\n\n        // Primary: Beat detection\n        if (ctx.audio.isOnBeat()) {\n            // Scale by confidence - use sqrt for gentler curve at low confidence\n            float confWeight = sqrtf(tempoConf) * 1.5f;\n            confWeight = fmaxf(0.3f, confWeight);  // Minimum floor for visibility\n            float weightedStrength = beatStrength * (0.5f + 0.5f * confWeight);\n            // Boost intensity with sub-bass energy\n            weightedStrength = fmaxf(weightedStrength, subBassEnergy * 0.5f);\n            ringIntensity = weightedStrength;\n            shouldSpawnRing = true;\n        }\n        \n        // Secondary: Snare hit trigger (additional ring spawns)\n        if (ctx.audio.isSnareHit()) {\n            float snareIntensity = 0.7f + subBassEnergy * 0.3f;\n            if (snareIntensity > ringIntensity) {\n                ringIntensity = snareIntensity;\n                shouldSpawnRing = true;\n            }\n        }\n        \n        if (shouldSpawnRing && ringIntensity > 0.1f) {\n            // Spawn new ring\n            m_ringRadius[m_nextRing] = 0.0f;\n            m_ringIntensity[m_nextRing] = ringIntensity;\n            m_nextRing = (m_nextRing + 1) % MAX_RINGS;\n        }\n    } else {\n        // NO AUDIO: Fallback slow time-based animation\n        m_fallbackPhase += speedNorm * 0.5f * dt;  // Slow animation\n        if (m_fallbackPhase > 2.0f * 3.14159f * 10.0f) {\n            m_fallbackPhase -= 2.0f * 3.14159f * 10.0f;\n        }\n    }\n#else\n    // NO AUDIO FEATURE: Fallback slow time-based animation\n    m_fallbackPhase += speedNorm * 0.5f * dt;\n    if (m_fallbackPhase > 2.0f * 3.14159f * 10.0f) {\n        m_fallbackPhase -= 2.0f * 3.14159f * 10.0f;\n    }\n#endif\n\n    // =========================================================================\n    // PHASE ACCUMULATION (PLL-style correction for smooth lock)\n    // =========================================================================\n#if FEATURE_AUDIO_SYNC\n    // Domain constants (compute once, use consistently)\n    const float PHASE_DOMAIN = 628.3f;      // 100 * 2 * PI\n    const float HALF_DOMAIN = 314.15f;      // PHASE_DOMAIN / 2\n\n    // Always advance phase (free-run oscillator)\n    m_phase += speedNorm * 240.0f * speedMult * dt;\n\n    // Apply phase correction when tempo-locked (PLL-style P-only correction)\n    if (ctx.audio.available && m_tempoLocked) {\n        float beatPhase = ctx.audio.beatPhase();\n        float targetPhase = beatPhase * PHASE_DOMAIN;\n        \n        // Compute wrapped error (shortest path to target)\n        float phaseError = targetPhase - m_phase;\n        if (phaseError > HALF_DOMAIN) phaseError -= PHASE_DOMAIN;\n        if (phaseError < -HALF_DOMAIN) phaseError += PHASE_DOMAIN;\n        \n        // Proportional correction (tau ~100ms gives smooth lock)\n        // Compute ONCE per frame, not per pixel\n        const float tau = 0.1f;\n        const float correctionAlpha = 1.0f - expf(-dt / tau);\n        m_phase += phaseError * correctionAlpha;\n    }\n\n    // CRITICAL: Wrap phase AFTER correction (handles negative and overflow)\n    while (m_phase >= PHASE_DOMAIN) m_phase -= PHASE_DOMAIN;\n    while (m_phase < 0.0f) m_phase += PHASE_DOMAIN;\n#else\n    // Fallback: use fallback phase\n    m_phase = m_fallbackPhase;\n#endif\n\n    // =========================================================================\n    // UPDATE RING RADII (expand outward, fade as they go)\n    // =========================================================================\n    for (int r = 0; r < MAX_RINGS; r++) {\n        if (m_ringIntensity[r] > 0.01f) {\n            m_ringRadius[r] += expansionRate * dt;\n            m_ringIntensity[r] *= powf(0.97f, dt * 60.0f);  // Gradual fade (dt-corrected)\n\n            // Kill ring when it reaches edge\n            if (m_ringRadius[r] > HALF_LENGTH) {\n                m_ringIntensity[r] = 0.0f;\n            }\n        }\n    }\n\n    // =========================================================================\n    // Fade for background wave trails\n    // =========================================================================\n    fadeToBlackBy(ctx.leds, ctx.ledCount, ctx.fadeAmount);\n\n    // =========================================================================\n    // DUAL-LAYER RENDER LOOP\n    // =========================================================================\n    for (uint16_t i = 0; i < STRIP_LENGTH; i++) {\n        float dist = (float)centerPairDistance(i);\n\n        // =====================================================================\n        // LAYER 1: Background traveling sine wave from center\n        // sin(dist * freq - phase) → OUTWARD motion when phase increases\n        // =====================================================================\n        float waveFreq = 0.12f;  // ~52 LED wavelength\n        float wave = sinf(dist * waveFreq - m_phase);\n        // Map [-1,1] to [0.2, 0.8] for subtle background\n        // Add minimum brightness floor (0.3) when tempo confidence low\n        float baseBrightness = (wave * 0.3f + 0.5f);\n        baseBrightness = fmaxf(0.3f, baseBrightness);  // Floor for visibility\n        uint8_t baseIntensity = (uint8_t)(baseBrightness * ctx.brightness);\n\n        // =====================================================================\n        // LAYER 2: Beat rings overlay\n        // Each ring is a Gaussian-ish bump that expands from center\n        // =====================================================================\n        uint8_t ringBoost = 0;\n        for (int r = 0; r < MAX_RINGS; r++) {\n            if (m_ringIntensity[r] > 0.01f) {\n                float delta = fabsf(dist - m_ringRadius[r]);\n                if (delta < 6.0f) {\n                    // Soft falloff within 6 LEDs of ring center\n                    float ringBright = (1.0f - delta / 6.0f) * m_ringIntensity[r];\n                    ringBoost = qadd8(ringBoost, (uint8_t)(ringBright * 180.0f));\n                }\n            }\n        }\n\n        // Combine layers\n        uint8_t intensity = qadd8(baseIntensity, ringBoost);\n\n        // =====================================================================\n        // COLOR: Use heavy_chroma for stable color (enhanced)\n        // =====================================================================\n#if FEATURE_AUDIO_SYNC\n        if (ctx.audio.available) {\n            // Use dominant chroma bin for hue offset\n            uint8_t hue = ctx.gHue + chromaHueOffset + (uint8_t)(dist / 3);\n            CRGB color = ctx.palette.getColor(hue, intensity);\n            ctx.leds[i] = color;\n            \n            // Strip 2: Complementary color (+128 hue offset)\n            if (i + STRIP_LENGTH < ctx.ledCount) {\n                ctx.leds[i + STRIP_LENGTH] = ctx.palette.getColor(\n                    (uint8_t)(hue + 128), intensity);\n            }\n        } else {\n            // Fallback: simple palette color\n            uint8_t hue = ctx.gHue + (uint8_t)(dist / 3);\n            CRGB color = ctx.palette.getColor(hue, intensity);\n            ctx.leds[i] = color;\n            if (i + STRIP_LENGTH < ctx.ledCount) {\n                ctx.leds[i + STRIP_LENGTH] = ctx.palette.getColor(\n                    (uint8_t)(hue + 128), intensity);\n            }\n        }\n#else\n        // Fallback: simple palette color\n        uint8_t hue = ctx.gHue + (uint8_t)(dist / 3);\n        CRGB color = ctx.palette.getColor(hue, intensity);\n        ctx.leds[i] = color;\n        if (i + STRIP_LENGTH < ctx.ledCount) {\n            ctx.leds[i + STRIP_LENGTH] = ctx.palette.getColor(\n                (uint8_t)(hue + 128), intensity);\n        }\n#endif\n    }\n}\n\nvoid BPMEnhancedEffect::cleanup() {\n    // No resources to free\n}\n\nconst plugins::EffectMetadata& BPMEnhancedEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"BPM Enhanced\",\n        \"Enhanced: 64-bin sub-bass, heavy_chroma, beatPhase sync, snare triggers\",\n        plugins::EffectCategory::PARTY,\n        1\n    };\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n\n"
}
