{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_CHEVRON_WAVES_ENHANCED",
  "effectIdHex": "0x0E02",
  "className": "ChevronWavesEnhancedEffect",
  "displayName": "LGP Chevron Waves Enhanced",
  "headerPath": "firmware/v2/src/effects/ieffect/ChevronWavesEffectEnhanced.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/ChevronWavesEffectEnhanced.cpp",
  "renderRange": [
    62,
    240
  ],
  "phaseRanges": {
    "input": [
      [
        67,
        67
      ],
      [
        72,
        72
      ],
      [
        74,
        74
      ],
      [
        78,
        78
      ],
      [
        134,
        134
      ],
      [
        149,
        149
      ],
      [
        157,
        158
      ],
      [
        177,
        177
      ],
      [
        189,
        189
      ]
    ],
    "mapping": [
      [
        65,
        66
      ],
      [
        76,
        76
      ],
      [
        78,
        78
      ],
      [
        97,
        99
      ],
      [
        102,
        103
      ],
      [
        107,
        107
      ],
      [
        122,
        122
      ],
      [
        128,
        128
      ],
      [
        131,
        131
      ],
      [
        142,
        143
      ],
      [
        161,
        161
      ],
      [
        164,
        164
      ],
      [
        185,
        185
      ],
      [
        190,
        190
      ],
      [
        192,
        193
      ],
      [
        224,
        224
      ]
    ],
    "modulation": [
      [
        86,
        87
      ],
      [
        124,
        124
      ],
      [
        127,
        127
      ],
      [
        130,
        130
      ],
      [
        141,
        143
      ],
      [
        145,
        145
      ],
      [
        148,
        148
      ],
      [
        163,
        166
      ],
      [
        168,
        168
      ],
      [
        170,
        171
      ],
      [
        184,
        185
      ],
      [
        187,
        187
      ],
      [
        189,
        190
      ],
      [
        193,
        195
      ],
      [
        197,
        197
      ],
      [
        200,
        201
      ],
      [
        204,
        206
      ],
      [
        215,
        215
      ],
      [
        221,
        221
      ],
      [
        223,
        223
      ],
      [
        226,
        226
      ]
    ],
    "render": [
      [
        77,
        77
      ],
      [
        85,
        85
      ],
      [
        126,
        126
      ],
      [
        205,
        206
      ],
      [
        208,
        208
      ],
      [
        210,
        210
      ],
      [
        234,
        234
      ],
      [
        237,
        237
      ]
    ],
    "post": [
      [
        168,
        168
      ],
      [
        187,
        187
      ],
      [
        197,
        197
      ],
      [
        204,
        204
      ],
      [
        208,
        208
      ],
      [
        233,
        233
      ]
    ],
    "output": [
      [
        210,
        210
      ],
      [
        234,
        234
      ],
      [
        236,
        237
      ]
    ]
  },
  "mappingConfidence": "medium",
  "mappingWarnings": [],
  "sourceText": "/**\n * @file ChevronWavesEffect.cpp\n * @brief LGP Chevron Waves implementation\n */\n\n#include \"ChevronWavesEffectEnhanced.h\"\n#include \"ChromaUtils.h\"\n#include \"../CoreEffects.h\"\n#include \"../utils/FastLEDOptim.h\"\n#include \"../../config/features.h\"\n#include <math.h>\n\n#ifndef PI\n#define PI 3.14159265358979323846f\n#endif\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nChevronWavesEnhancedEffect::ChevronWavesEnhancedEffect()\n    : m_chevronPos(0.0f)\n{\n}\n\nbool ChevronWavesEnhancedEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_chevronPos = 0.0f;\n    m_lastHopSeq = 0;\n    m_chromaEnergySum = 0.0f;\n    m_chromaHistIdx = 0;\n    for (uint8_t i = 0; i < CHROMA_HISTORY; ++i) {\n        m_chromaEnergyHist[i] = 0.0f;\n    }\n    m_energyAvg = 0.0f;\n    m_energyDelta = 0.0f;\n    m_dominantBin = 0;\n    m_chromaAngle = 0.0f;\n    m_chromaHue = 0.0f;\n\n    // Initialize chromagram smoothing\n    for (uint8_t i = 0; i < 12; i++) {\n        m_chromaFollowers[i].reset(0.0f);\n        m_chromaSmoothed[i] = 0.0f;\n        m_chromaTargets[i] = 0.0f;\n    }\n    \n    // Initialize enhancement utilities\n    m_phaseSpeedSpring.init(50.0f, 1.0f);  // stiffness=50, mass=1 (critically damped)\n    m_phaseSpeedSpring.reset(1.0f);        // Start at base speed\n    m_energyAvgFollower.reset(0.0f);\n    m_energyDeltaFollower.reset(0.0f);\n    m_subBassFollower.reset(0.0f);\n    m_subBassEnergy = 0.0f;\n    m_targetSubBass = 0.0f;\n    m_snareSharpness = 0.0f;\n    m_tempoLocked = false;\n\n    return true;\n}\n\nvoid ChevronWavesEnhancedEffect::render(plugins::EffectContext& ctx) {\n    // CENTRE ORIGIN - V-shaped patterns from centre\n\n    float speedNorm = ctx.speed / 50.0f;\n    float intensityNorm = ctx.brightness / 255.0f;\n    const bool hasAudio = ctx.audio.available;\n    bool newHop = false;\n\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n        if (newHop) {\n            m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n            \n            // Update chromagram targets\n            for (uint8_t i = 0; i < 12; i++) {\n                m_chromaTargets[i] = ctx.audio.controlBus.heavy_chroma[i];\n            }\n\n            const float led_share = 255.0f / 12.0f;\n            float chromaEnergy = 0.0f;\n            float maxBinVal = 0.0f;\n            uint8_t dominantBin = 0;\n            for (uint8_t i = 0; i < 12; ++i) {\n                // Use smoothed chromagram for energy calculation\n                float bin = m_chromaSmoothed[i];\n                float bright = bin * bin;\n                bright *= 1.5f;\n                if (bright > 1.0f) bright = 1.0f;\n                if (bright > maxBinVal) {\n                    maxBinVal = bright;\n                    dominantBin = i;\n                }\n                chromaEnergy += bright * led_share;\n            }\n            float energyNorm = chromaEnergy / 255.0f;\n            if (energyNorm < 0.0f) energyNorm = 0.0f;\n            if (energyNorm > 1.0f) energyNorm = 1.0f;\n\n            m_chromaEnergySum -= m_chromaEnergyHist[m_chromaHistIdx];\n            m_chromaEnergyHist[m_chromaHistIdx] = energyNorm;\n            m_chromaEnergySum += energyNorm;\n            m_chromaHistIdx = (m_chromaHistIdx + 1) % CHROMA_HISTORY;\n\n            m_energyAvg = m_chromaEnergySum / CHROMA_HISTORY;\n            m_energyDelta = energyNorm - m_energyAvg;\n            if (m_energyDelta < 0.0f) m_energyDelta = 0.0f;\n            m_dominantBin = dominantBin;\n        }\n    } else\n#endif\n    {\n        // dt-corrected decay when audio unavailable\n        float dtFallback = enhancement::getSafeDeltaSeconds(ctx.rawDeltaTimeSeconds);\n        m_energyAvg *= powf(0.98f, dtFallback * 60.0f);\n        m_energyDelta = 0.0f;\n    }\n\n    float rawDt = enhancement::getSafeDeltaSeconds(ctx.rawDeltaTimeSeconds);\n    float dt = enhancement::getSafeDeltaSeconds(ctx.deltaTimeSeconds);\n    float moodNorm = ctx.getMoodNormalized();\n\n    // Smooth chromagram with AsymmetricFollower (every frame)\n    if (hasAudio) {\n        for (uint8_t i = 0; i < 12; i++) {\n            m_chromaSmoothed[i] = m_chromaFollowers[i].updateWithMood(\n                m_chromaTargets[i], rawDt, moodNorm);\n        }\n        // Enhanced: Smooth sub-bass energy\n        m_subBassEnergy = m_subBassFollower.updateWithMood(m_targetSubBass, rawDt, moodNorm);\n        \n        // Enhanced: Snare hit triggers sharpness boost\n        if (ctx.audio.isSnareHit()) {\n            m_snareSharpness = 1.0f;\n        }\n        m_snareSharpness *= powf(0.90f, rawDt * 60.0f);  // dt-corrected decay (rawDt: audio-coupled)\n        if (m_snareSharpness < 0.01f) m_snareSharpness = 0.0f;\n    }\n\n    // True exponential smoothing with AsymmetricFollower (frame-rate independent)\n    float energyAvgSmooth = m_energyAvgFollower.updateWithMood(m_energyAvg, rawDt, moodNorm);\n    float energyDeltaSmooth = m_energyDeltaFollower.updateWithMood(m_energyDelta, rawDt, moodNorm);\n\n    // Circular chroma hue smoothing (replaces linear EMA on bin index)\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        m_chromaHue = static_cast<float>(effects::chroma::circularChromaHueSmoothed(\n            ctx.audio.controlBus.heavy_chroma, m_chromaAngle, rawDt, 0.20f));\n    }\n#endif\n\n    // Use heavy_bands instead of raw chroma/energyAvg to eliminate jitter\n    float heavyEnergy = 0.0f;\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        heavyEnergy = (ctx.audio.controlBus.heavy_bands[1] +\n                       ctx.audio.controlBus.heavy_bands[2]) / 2.0f;\n    }\n#endif\n    float targetSpeed = 0.6f + 1.2f * heavyEnergy;  // Reduced range for stability\n\n    // Spring physics for speed modulation (natural momentum, no jitter)\n    float smoothedSpeed = m_phaseSpeedSpring.update(targetSpeed, dt);\n    if (smoothedSpeed > 2.0f) smoothedSpeed = 2.0f;  // Hard clamp\n    if (smoothedSpeed < 0.3f) smoothedSpeed = 0.3f;  // Prevent stalling\n    \n    // Enhanced: Use beatPhase for synchronization when tempo confidence high (PLL-style correction)\n    // Domain constants (compute once, use consistently)\n    const float PHASE_DOMAIN = 628.3f;      // 100 * 2 * PI\n    const float HALF_DOMAIN = 314.15f;      // PHASE_DOMAIN / 2\n\n    // Tempo lock hysteresis (Schmitt trigger: prevents chatter near threshold)\n    if (!hasAudio) {\n        m_tempoLocked = false;  // Clear lock when audio drops (prevents ghost lock)\n    } else {\n        float tempoConf = ctx.audio.tempoConfidence();\n        \n        // Update lock state with hysteresis (0.6 lock / 0.4 unlock)\n        if (tempoConf > 0.6f) m_tempoLocked = true;\n        else if (tempoConf < 0.4f) m_tempoLocked = false;\n    }\n    \n    // Always advance phase (free-run oscillator)\n    m_chevronPos += speedNorm * 240.0f * smoothedSpeed * dt;\n    \n    // Apply phase correction when tempo-locked (PLL-style P-only correction)\n    if (hasAudio && m_tempoLocked) {\n        float beatPhase = ctx.audio.beatPhase();\n        float targetPhase = beatPhase * PHASE_DOMAIN;\n        \n        // Compute wrapped error (shortest path to target)\n        float phaseError = targetPhase - m_chevronPos;\n        if (phaseError > HALF_DOMAIN) phaseError -= PHASE_DOMAIN;\n        if (phaseError < -HALF_DOMAIN) phaseError += PHASE_DOMAIN;\n        \n        // Proportional correction (tau ~100ms gives smooth lock)\n        // Compute ONCE per frame, not per pixel\n        const float tau = 0.1f;\n        const float correctionAlpha = 1.0f - expf(-dt / tau);\n        m_chevronPos += phaseError * correctionAlpha;\n    }\n    \n    // CRITICAL: Wrap phase AFTER correction (handles negative and overflow)\n    while (m_chevronPos >= PHASE_DOMAIN) m_chevronPos -= PHASE_DOMAIN;\n    while (m_chevronPos < 0.0f) m_chevronPos += PHASE_DOMAIN;\n\n    fadeToBlackBy(ctx.leds, ctx.ledCount, ctx.fadeAmount);\n\n    for (uint16_t i = 0; i < ctx.ledCount && i < STRIP_LENGTH; i++) {\n        // CRITICAL FIX: Use centerPairDistance() like working effects\n        float distFromCenter = (float)centerPairDistance(i);\n\n        // CRITICAL FIX: Match reference pattern with moderate spatial frequency\n        // sin(k*dist - phase) produces OUTWARD motion when phase increases\n        const float freqBase = 0.25f;  // Wavelength ~25 LEDs (was ~7 with CHEVRON_COUNT)\n        float chevron = sinf(distFromCenter * freqBase - m_chevronPos);\n\n        // Enhanced: Sharp edges with snare-triggered crispness\n        float tanhScale = 2.0f + m_snareSharpness * 3.0f;  // Base sharpness + snare boost\n        chevron = tanhf(chevron * (tanhScale + 4.0f * energyAvgSmooth)) * 0.5f + 0.5f;\n\n        float audioGain = 0.2f + 0.8f * energyAvgSmooth;\n        uint8_t brightness = (uint8_t)(chevron * 255.0f * intensityNorm * audioGain);\n        // Calculate hue with proper modular arithmetic (avoids UB from large float->uint8_t cast)\n        // m_chromaHue is already 0-255 from circular chroma smoothing\n        float rawHue = (float)ctx.gHue\n                     + m_chromaHue\n                     + distFromCenter * 2.0f\n                     + fmodf(m_chevronPos * 0.5f, 256.0f);\n        uint8_t hue = (uint8_t)fmodf(rawHue, 256.0f);\n\n        // Direct assignment - fadeToBlackBy clears buffer each frame\n        ctx.leds[i] = ctx.palette.getColor(hue, brightness);\n\n        if (i + STRIP_LENGTH < ctx.ledCount) {\n            ctx.leds[i + STRIP_LENGTH] = ctx.palette.getColor(hue + 90, brightness);\n        }\n    }\n}\n\nvoid ChevronWavesEnhancedEffect::cleanup() {\n    // No resources to free\n}\n\nconst plugins::EffectMetadata& ChevronWavesEnhancedEffect::getMetadata() const {\n    static plugins::EffectMetadata meta(\n        \"LGP Chevron Waves Enhanced\",\n        \"Enhanced: heavy_chroma, 64-bin sub-bass, snare sharpness boost, beatPhase sync\",\n        plugins::EffectCategory::GEOMETRIC,\n        1\n    );\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
