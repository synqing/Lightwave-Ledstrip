{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_LGP_BEAT_PRISM",
  "effectIdHex": "0x1A01",
  "className": "LGPBeatPrismEffect",
  "displayName": "LGP Beat Prism",
  "headerPath": "firmware/v2/src/effects/ieffect/LGPExperimentalAudioPack.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/LGPExperimentalAudioPack.cpp",
  "renderRange": [
    268,
    313
  ],
  "phaseRanges": {
    "input": [
      [
        271,
        271
      ],
      [
        279,
        280
      ]
    ],
    "mapping": [
      [
        279,
        279
      ],
      [
        282,
        282
      ],
      [
        295,
        296
      ]
    ],
    "modulation": [
      [
        268,
        268
      ],
      [
        280,
        280
      ],
      [
        282,
        282
      ],
      [
        284,
        286
      ],
      [
        288,
        288
      ],
      [
        291,
        292
      ],
      [
        294,
        294
      ],
      [
        296,
        296
      ],
      [
        302,
        305
      ]
    ],
    "render": [
      [
        273,
        273
      ],
      [
        299,
        300
      ],
      [
        311,
        311
      ]
    ],
    "post": [
      [
        308,
        310
      ]
    ],
    "output": [
      [
        311,
        313
      ]
    ]
  },
  "mappingConfidence": "medium",
  "mappingWarnings": [
    "Phase 'post' inferred from fallback segmentation.",
    "Phase 'output' inferred from fallback segmentation."
  ],
  "sourceText": "/**\n * @file LGPExperimentalAudioPack.cpp\n * @brief 10 experimental audio-reactive effects for LightwaveOS v2\n */\n\n#include \"LGPExperimentalAudioPack.h\"\n#include \"ChromaUtils.h\"\n#include \"AudioReactivePolicy.h\"\n#include \"../CoreEffects.h\"\n#include \"../../config/features.h\"\n\n#ifndef NATIVE_BUILD\n#include <FastLED.h>\n#endif\n\n#include <cmath>\n#include <cstdint>\n#include <cstring>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nnamespace {\n\nstatic constexpr float EX_PI = 3.14159265358979323846f;\nstatic constexpr float EX_TAU = 6.28318530717958647692f;\n\nstatic constexpr uint8_t NOTE_HUES[12] = {\n    0, 12, 24, 40, 56, 74, 92, 112, 134, 154, 178, 202\n};\n\nstatic inline float clamp01f(float v) {\n    if (v < 0.0f) return 0.0f;\n    if (v > 1.0f) return 1.0f;\n    return v;\n}\n\nstatic inline float smoothstep01(float x) {\n    const float t = clamp01f(x);\n    return t * t * (3.0f - 2.0f * t);\n}\n\nstatic inline float expAlpha(float dt, float tauS) {\n    if (tauS <= 0.0f) return 1.0f;\n    return 1.0f - expf(-dt / tauS);\n}\n\nstatic inline float smoothTo(float current, float target, float dt, float tauS) {\n    return current + (target - current) * expAlpha(dt, tauS);\n}\n\nstatic inline float decay(float value, float dt, float tauS) {\n    if (tauS <= 0.0f) return 0.0f;\n    return value * expf(-dt / tauS);\n}\n\nstatic inline float binsRangeEnergy(const plugins::EffectContext& ctx, uint8_t start, uint8_t end) {\n    if (!ctx.audio.available || start > end) return 0.0f;\n    float sum = 0.0f;\n    uint8_t count = 0;\n    for (uint8_t i = start; i <= end && i < 64; ++i) {\n        sum += clamp01f(ctx.audio.binAdaptive(i));\n        ++count;\n    }\n    return (count > 0) ? (sum / static_cast<float>(count)) : 0.0f;\n}\n\nstatic inline uint8_t dominantNoteFromBins(const plugins::EffectContext& ctx) {\n    if (!ctx.audio.available) return 0;\n\n    // Accumulate per-note scores across octaves, then use circular weighted\n    // mean to avoid discontinuous jumps when two adjacent notes compete.\n    float scores[12] = {};\n    for (uint8_t note = 0; note < 12; ++note) {\n        for (uint8_t b = note; b < 48; b = static_cast<uint8_t>(b + 12)) {\n            scores[note] += clamp01f(ctx.audio.binAdaptive(b));\n        }\n    }\n\n    // Circular weighted mean over 12 note positions (30-degree steps)\n    float cx = 0.0f, sy = 0.0f;\n    for (uint8_t i = 0; i < 12; ++i) {\n        cx += scores[i] * effects::chroma::kCos[i];\n        sy += scores[i] * effects::chroma::kSin[i];\n    }\n    float angle = atan2f(sy, cx);\n    if (angle < 0.0f) angle += EX_TAU;\n\n    // Map angle back to nearest note index (0-11)\n    uint8_t note = static_cast<uint8_t>(roundf(angle * (12.0f / EX_TAU))) % 12;\n    return note;\n}\n\nstatic inline uint8_t selectMusicalHue(const plugins::EffectContext& ctx, bool& chordGateOpen) {\n    if (!ctx.audio.available) return 24;\n\n    // Schmitt trigger hysteresis on chord confidence (enter 0.40, exit 0.25)\n    // prevents rapid switching between chord root and bin-derived note.\n    const float conf = ctx.audio.chordConfidence();\n    if (conf >= 0.40f) chordGateOpen = true;\n    else if (conf <= 0.25f) chordGateOpen = false;\n\n    const uint8_t note = chordGateOpen\n        ? static_cast<uint8_t>(ctx.audio.rootNote() % 12)\n        : dominantNoteFromBins(ctx);\n    return NOTE_HUES[note];\n}\n\nstatic inline float smoothHue(float current, float target, float dt, float tauS) {\n    float delta = target - current;\n    while (delta > 128.0f) delta -= 256.0f;\n    while (delta < -128.0f) delta += 256.0f;\n    const float next = current + delta * expAlpha(dt, tauS);\n    float wrapped = fmodf(next, 256.0f);\n    if (wrapped < 0.0f) wrapped += 256.0f;\n    return wrapped;\n}\n\n// Circular smoothing for note index domain [0, 12).\n// Same shortest-arc approach as smoothHue but with period 12.\nstatic inline float smoothNoteCircular(float current, float target, float dt, float tauS) {\n    float delta = target - current;\n    while (delta > 6.0f) delta -= 12.0f;\n    while (delta < -6.0f) delta += 12.0f;\n    const float next = current + delta * expAlpha(dt, tauS);\n    float wrapped = fmodf(next, 12.0f);\n    if (wrapped < 0.0f) wrapped += 12.0f;\n    return wrapped;\n}\n\nstatic inline uint8_t toBrightness(float intensity, float master) {\n    return static_cast<uint8_t>(255.0f * clamp01f(intensity) * clamp01f(master));\n}\n\nstatic inline void setCentrePairDual(\n    plugins::EffectContext& ctx,\n    uint16_t dist,\n    const CRGB& strip1Color,\n    const CRGB& strip2Color\n) {\n    const uint16_t left1 = CENTER_LEFT - dist;\n    const uint16_t right1 = CENTER_RIGHT + dist;\n    const uint16_t left2 = STRIP_LENGTH + CENTER_LEFT - dist;\n    const uint16_t right2 = STRIP_LENGTH + CENTER_RIGHT + dist;\n\n    if (left1 < ctx.ledCount) ctx.leds[left1] = strip1Color;\n    if (right1 < ctx.ledCount) ctx.leds[right1] = strip1Color;\n    if (left2 < ctx.ledCount) ctx.leds[left2] = strip2Color;\n    if (right2 < ctx.ledCount) ctx.leds[right2] = strip2Color;\n}\n\nstatic inline void setCentrePairMono(\n    plugins::EffectContext& ctx,\n    uint16_t dist,\n    const CRGB& color\n) {\n    setCentrePairDual(ctx, dist, color, color);\n}\n\nstatic inline float fallbackSine(uint32_t rawMs, float rate, float phaseOffset = 0.0f) {\n    return 0.5f + 0.5f * sinf(static_cast<float>(rawMs) * rate + phaseOffset);\n}\n\nstatic inline float trackAudioPresence(float current, bool audioAvailable, float dtSignal) {\n    const float tau = audioAvailable ? 0.06f : 0.32f;\n    return smoothTo(current, audioAvailable ? 1.0f : 0.0f, dtSignal, tau);\n}\n\n} // namespace\n\n// ---------------------------------------------------------------------------\n// LGP Flux Rift\n// Principle: travelling phase-dislocation seam with beat shock release.\n// ---------------------------------------------------------------------------\n\nLGPFluxRiftEffect::LGPFluxRiftEffect() = default;\n\nbool LGPFluxRiftEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_phase = 0.0f;\n    m_fluxEnv = 0.0f;\n    m_beatPulse = 0.0f;\n    m_lastBeatMs = 0;\n    m_hue = 24.0f;\n    m_audioPresence = 0.0f;\n    m_chordGateOpen = false;\n    return true;\n}\n\nvoid LGPFluxRiftEffect::render(plugins::EffectContext& ctx) {\n    const float dtSignal = AudioReactivePolicy::signalDt(ctx);\n    const float dtVisual = AudioReactivePolicy::visualDt(ctx);\n    m_audioPresence = trackAudioPresence(m_audioPresence, ctx.audio.available, dtSignal);\n    if (m_audioPresence <= 0.001f) {\n        memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n        return;\n    }\n    const float master = (ctx.brightness / 255.0f) * m_audioPresence;\n\n    const float fluxTarget = ctx.audio.available\n        ? clamp01f(0.70f * ctx.audio.fastFlux() + 0.30f * ctx.audio.overallSaliency())\n        : fallbackSine(ctx.rawTotalTimeMs, 0.0013f, 0.7f);\n    m_fluxEnv = smoothTo(m_fluxEnv, fluxTarget, dtSignal, 0.10f);\n\n    const bool beatTick = AudioReactivePolicy::audioBeatTick(ctx, 128.0f, m_lastBeatMs);\n    if (beatTick) {\n        m_beatPulse = 1.0f;\n    } else {\n        m_beatPulse = decay(m_beatPulse, dtSignal, 0.25f);\n    }\n\n    m_phase += 0.85f * (0.55f + 1.20f * m_fluxEnv) * dtVisual;\n    if (m_phase > 100000.0f) m_phase = fmodf(m_phase, EX_TAU);\n\n    const float seamPos = clamp01f(1.0f - m_beatPulse);\n    const float hueTarget = static_cast<float>(selectMusicalHue(ctx, m_chordGateOpen));\n    m_hue = smoothHue(m_hue, hueTarget, dtSignal, 0.45f);\n    const uint8_t baseHue = static_cast<uint8_t>(m_hue);\n\n    memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        const float d = static_cast<float>(dist) / static_cast<float>(HALF_LENGTH);\n        const float seam = tanhf((d - seamPos) * (8.0f + 16.0f * m_fluxEnv));\n        const float carrierA = sinf(static_cast<float>(dist) * 0.22f - m_phase * 3.5f);\n        const float carrierB = sinf(static_cast<float>(dist) * 0.09f + m_phase * 5.1f);\n        const float dislocation = 0.5f + 0.5f * tanhf(-1.35f * seam + 0.65f * carrierA + 0.35f * carrierB);\n        const float shock = expf(-fabsf(d - seamPos) * 16.0f) * m_beatPulse;\n        const float intensity = clamp01f(dislocation * (0.35f + 0.65f * m_fluxEnv) + 0.9f * shock);\n\n        const uint8_t br = toBrightness(intensity, master);\n        const uint8_t idxA = static_cast<uint8_t>(baseHue + static_cast<uint8_t>(d * 48.0f) + static_cast<uint8_t>(m_fluxEnv * 22.0f));\n        setCentrePairMono(ctx, dist, ctx.palette.getColor(idxA, br));\n    }\n}\n\nvoid LGPFluxRiftEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPFluxRiftEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Flux Rift\",\n        \"Transient flux opens a travelling centre-out rift\",\n        plugins::EffectCategory::PARTY,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------------------------------------\n// LGP Beat Prism\n// Principle: beat-launched prism fronts refracting through radial spokes.\n// ---------------------------------------------------------------------------\n\nLGPBeatPrismEffect::LGPBeatPrismEffect() = default;\n\nbool LGPBeatPrismEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_phase = 0.0f;\n    m_prism = 0.0f;\n    m_beatPulse = 0.0f;\n    m_lastBeatMs = 0;\n    m_hue = 24.0f;\n    m_audioPresence = 0.0f;\n    m_chordGateOpen = false;\n    return true;\n}\n\nvoid LGPBeatPrismEffect::render(plugins::EffectContext& ctx) {\n    const float dtSignal = AudioReactivePolicy::signalDt(ctx);\n    const float dtVisual = AudioReactivePolicy::visualDt(ctx);\n    m_audioPresence = trackAudioPresence(m_audioPresence, ctx.audio.available, dtSignal);\n    if (m_audioPresence <= 0.001f) {\n        memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n        return;\n    }\n    const float master = (ctx.brightness / 255.0f) * m_audioPresence;\n\n    const float treble = binsRangeEnergy(ctx, 42, 63);\n    const float prismTarget = ctx.audio.available\n        ? clamp01f(0.55f * ctx.audio.beatStrength() + 0.45f * treble)\n        : fallbackSine(ctx.rawTotalTimeMs, 0.0011f, 1.0f);\n    m_prism = smoothTo(m_prism, prismTarget, dtSignal, 0.08f);\n\n    const bool beatTick = AudioReactivePolicy::audioBeatTick(ctx, 128.0f, m_lastBeatMs);\n    if (beatTick) {\n        m_beatPulse = 1.0f;\n    } else {\n        m_beatPulse = decay(m_beatPulse, dtSignal, 0.20f);\n    }\n\n    m_phase += 0.90f * (0.55f + 1.35f * m_prism) * dtVisual;\n    if (m_phase > 100000.0f) m_phase = fmodf(m_phase, EX_TAU);\n\n    const float frontPos = clamp01f(1.0f - m_beatPulse);\n    const float hueTarget = static_cast<float>(static_cast<uint8_t>(selectMusicalHue(ctx, m_chordGateOpen) + 8));\n    m_hue = smoothHue(m_hue, hueTarget, dtSignal, 0.45f);\n    const uint8_t baseHue = static_cast<uint8_t>(m_hue);\n\n    memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        const float d = static_cast<float>(dist) / static_cast<float>(HALF_LENGTH);\n        const float spokes = fabsf(sinf((d * (5.5f + 13.0f * m_prism) - m_phase * 0.7f) * EX_PI));\n        const float facets = 0.5f + 0.5f * cosf((d * 3.5f + m_phase * 0.35f) * EX_TAU);\n        const float refract = 0.5f + 0.5f * sinf(d * (2.2f + 4.0f * m_prism) * EX_TAU - m_phase * 1.35f);\n        const float front = expf(-fabsf(d - frontPos) * (8.0f + 10.0f * m_prism)) * m_beatPulse;\n        const float intensity = clamp01f((0.20f + 0.80f * spokes) * (0.25f + 0.75f * facets) *\n                                         (0.20f + 0.80f * refract) + front * 0.95f);\n\n        const uint8_t br = toBrightness(intensity, master);\n        const uint8_t idxA = static_cast<uint8_t>(baseHue + static_cast<uint8_t>(spokes * 32.0f) + static_cast<uint8_t>(d * 28.0f));\n        setCentrePairMono(ctx, dist, ctx.palette.getColor(idxA, br));\n    }\n}\n\nvoid LGPBeatPrismEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPBeatPrismEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Beat Prism\",\n        \"Beat-front prism rays with edgeward pressure travel\",\n        plugins::EffectCategory::PARTY,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------------------------------------\n// LGP Harmonic Tide\n// Principle: triadic standing-tide superposition anchored to harmonic state.\n// ---------------------------------------------------------------------------\n\nLGPHarmonicTideEffect::LGPHarmonicTideEffect() = default;\n\nbool LGPHarmonicTideEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_phase = 0.0f;\n    m_harmonic = 0.0f;\n    m_rootSmooth = 0.0f;\n    m_hue = 24.0f;\n    m_audioPresence = 0.0f;\n    m_chordGateOpen = false;\n    return true;\n}\n\nvoid LGPHarmonicTideEffect::render(plugins::EffectContext& ctx) {\n    const float dtSignal = AudioReactivePolicy::signalDt(ctx);\n    const float dtVisual = AudioReactivePolicy::visualDt(ctx);\n    m_audioPresence = trackAudioPresence(m_audioPresence, ctx.audio.available, dtSignal);\n    if (m_audioPresence <= 0.001f) {\n        memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n        return;\n    }\n    const float master = (ctx.brightness / 255.0f) * m_audioPresence;\n\n    const float harmonicTarget = ctx.audio.available\n        ? clamp01f(fmaxf(ctx.audio.harmonicSaliency(), ctx.audio.chordConfidence()))\n        : fallbackSine(ctx.rawTotalTimeMs, 0.0008f, 1.6f);\n    m_harmonic = smoothTo(m_harmonic, harmonicTarget, dtSignal, 0.20f);\n\n    // Hysteresis gate for chord confidence (enter 0.40, exit 0.25)\n    if (ctx.audio.available) {\n        const float conf = ctx.audio.chordConfidence();\n        if (conf >= 0.40f) m_chordGateOpen = true;\n        else if (conf <= 0.25f) m_chordGateOpen = false;\n    }\n\n    // Root note with hysteresis gate and circular smoothing (note domain wraps at 12)\n    const float rootTarget = ctx.audio.available\n        ? static_cast<float>(m_chordGateOpen ? (ctx.audio.rootNote() % 12)\n                                             : dominantNoteFromBins(ctx))\n        : 2.0f;\n    m_rootSmooth = smoothNoteCircular(m_rootSmooth, rootTarget, dtSignal, 0.30f);\n\n    const float mid = ctx.audio.available ? clamp01f(ctx.audio.heavyMid()) : 0.25f;\n    m_phase += 0.75f * (0.65f + 1.15f * mid) * dtVisual;\n    if (m_phase > 100000.0f) m_phase = fmodf(m_phase, EX_TAU);\n\n    const uint8_t rootBin = static_cast<uint8_t>(roundf(m_rootSmooth)) % 12;\n    const bool minor = ctx.audio.available ? ctx.audio.isMinor() : false;\n    const uint8_t thirdBin = static_cast<uint8_t>((rootBin + (minor ? 3 : 4)) % 12);\n    const uint8_t fifthBin = static_cast<uint8_t>((rootBin + 7) % 12);\n\n    const uint8_t binStep = static_cast<uint8_t>(255.0f / 12.0f);\n    const uint8_t hueRoot = static_cast<uint8_t>(ctx.gHue + rootBin * binStep);\n    const uint8_t hueThird = static_cast<uint8_t>(ctx.gHue + thirdBin * binStep);\n    const uint8_t hueFifth = static_cast<uint8_t>(ctx.gHue + fifthBin * binStep);\n\n    memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        const float d = static_cast<float>(dist) / static_cast<float>(HALF_LENGTH);\n\n        const float outward = 0.5f + 0.5f * sinf(static_cast<float>(dist) * 0.09f - m_phase * 3.8f);\n        const float inward = 0.5f + 0.5f * sinf(static_cast<float>(dist) * 0.07f + m_phase * 2.7f);\n        const float standing = fabsf(sinf(static_cast<float>(dist) * 0.043f + m_phase * 1.1f));\n        const float envelope = (0.28f + 0.72f * m_harmonic) * (0.30f + 0.70f * expf(-d * 2.0f));\n        const float intensity = clamp01f((0.45f * outward + 0.35f * inward + 0.20f * standing) * envelope);\n\n        const uint8_t brightness = toBrightness(intensity, master);\n        const uint8_t paletteIndex = static_cast<uint8_t>(dist + static_cast<uint8_t>(standing * 38.0f));\n\n        float wRoot = clamp01f(1.20f - 1.55f * d);\n        float wFifth = clamp01f(0.30f + 1.00f * d);\n        float wThird = m_harmonic * clamp01f(1.0f - fabsf(d - 0.35f) * 3.1f);\n        const float wSum = wRoot + wThird + wFifth;\n        if (wSum > 0.0001f) {\n            wRoot /= wSum;\n            wThird /= wSum;\n            wFifth /= wSum;\n        }\n\n        const uint8_t bRoot = static_cast<uint8_t>(brightness * wRoot);\n        const uint8_t bThird = static_cast<uint8_t>(brightness * wThird);\n        const uint8_t bFifth = static_cast<uint8_t>(brightness * wFifth);\n\n        CRGB c1 = CRGB::Black;\n        if (bRoot) {\n            c1 += ctx.palette.getColor(static_cast<uint8_t>(hueRoot + paletteIndex), bRoot);\n        }\n        if (bThird) {\n            c1 += ctx.palette.getColor(static_cast<uint8_t>(hueThird + paletteIndex), bThird);\n        }\n        if (bFifth) {\n            c1 += ctx.palette.getColor(static_cast<uint8_t>(hueFifth + paletteIndex), bFifth);\n        }\n        setCentrePairMono(ctx, dist, c1);\n    }\n}\n\nvoid LGPHarmonicTideEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPHarmonicTideEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Harmonic Tide\",\n        \"Chord-anchored tidal bands with centre-held continuity\",\n        plugins::EffectCategory::AMBIENT,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------------------------------------\n// LGP Bass Quake\n// Principle: non-linear compression field with outward shock cells.\n// ---------------------------------------------------------------------------\n\nLGPBassQuakeEffect::LGPBassQuakeEffect() = default;\n\nbool LGPBassQuakeEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_phase = 0.0f;\n    m_bassEnv = 0.0f;\n    m_impact = 0.0f;\n    m_lastBeatMs = 0;\n    m_hue = 24.0f;\n    m_audioPresence = 0.0f;\n    m_chordGateOpen = false;\n    return true;\n}\n\nvoid LGPBassQuakeEffect::render(plugins::EffectContext& ctx) {\n    const float dtSignal = AudioReactivePolicy::signalDt(ctx);\n    const float dtVisual = AudioReactivePolicy::visualDt(ctx);\n    m_audioPresence = trackAudioPresence(m_audioPresence, ctx.audio.available, dtSignal);\n    if (m_audioPresence <= 0.001f) {\n        memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n        return;\n    }\n    const float master = (ctx.brightness / 255.0f) * m_audioPresence;\n\n    const float bassTarget = ctx.audio.available\n        ? clamp01f(ctx.audio.heavyBass())\n        : fallbackSine(ctx.rawTotalTimeMs, 0.0011f, 2.2f);\n    m_bassEnv = smoothTo(m_bassEnv, bassTarget, dtSignal, 0.06f);\n\n    const bool beatTick = AudioReactivePolicy::audioBeatTick(ctx, 128.0f, m_lastBeatMs);\n    const float seed = clamp01f(0.80f * m_bassEnv + (beatTick ? 0.45f : 0.0f));\n    if (seed > m_impact) {\n        m_impact = seed;\n    } else {\n        m_impact = decay(m_impact, dtSignal, 0.22f);\n    }\n\n    m_phase += 0.80f * (0.45f + 1.75f * m_bassEnv) * dtVisual;\n    if (m_phase > 100000.0f) m_phase = fmodf(m_phase, EX_TAU);\n\n    const float shockPos = clamp01f(1.0f - m_impact);\n    const float hueTarget = static_cast<float>(static_cast<uint8_t>(selectMusicalHue(ctx, m_chordGateOpen) + 10));\n    m_hue = smoothHue(m_hue, hueTarget, dtSignal, 0.45f);\n    const uint8_t baseHue = static_cast<uint8_t>(m_hue);\n\n    memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        const float d = static_cast<float>(dist) / static_cast<float>(HALF_LENGTH);\n        const float compression = powf(clamp01f(1.0f - d), 0.55f + 2.30f * (1.0f - m_bassEnv));\n        const float cell = 0.5f + 0.5f * sinf(static_cast<float>(dist) * (0.18f + 0.22f * m_bassEnv) - m_phase * 4.2f);\n        const float overtone = 0.5f + 0.5f * sinf(static_cast<float>(dist) * 0.47f - m_phase * 7.8f);\n        const float shock = expf(-fabsf(d - shockPos) * (10.0f + 13.0f * m_impact)) * m_impact;\n        const float intensity = clamp01f((0.55f * compression + 0.45f * cell) * (0.35f + 0.65f * overtone) + 0.95f * shock);\n\n        const uint8_t br = toBrightness(intensity, master);\n        const uint8_t idxA = static_cast<uint8_t>(baseHue + static_cast<uint8_t>(shock * 30.0f) + static_cast<uint8_t>(d * 22.0f));\n        setCentrePairMono(ctx, dist, ctx.palette.getColor(idxA, br));\n    }\n}\n\nvoid LGPBassQuakeEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPBassQuakeEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Bass Quake\",\n        \"Sub-bass compression waves with outward shock release\",\n        plugins::EffectCategory::SHOCKWAVE,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------------------------------------\n// LGP Treble Net\n// Principle: moire-like high-frequency lattice with edge filament shimmer.\n// ---------------------------------------------------------------------------\n\nLGPTrebleNetEffect::LGPTrebleNetEffect() = default;\n\nbool LGPTrebleNetEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_phase = 0.0f;\n    m_trebleEnv = 0.0f;\n    m_shimmer = 0.0f;\n    m_hue = 24.0f;\n    m_audioPresence = 0.0f;\n    m_chordGateOpen = false;\n    return true;\n}\n\nvoid LGPTrebleNetEffect::render(plugins::EffectContext& ctx) {\n    const float dtSignal = AudioReactivePolicy::signalDt(ctx);\n    const float dtVisual = AudioReactivePolicy::visualDt(ctx);\n    m_audioPresence = trackAudioPresence(m_audioPresence, ctx.audio.available, dtSignal);\n    if (m_audioPresence <= 0.001f) {\n        memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n        return;\n    }\n    const float master = (ctx.brightness / 255.0f) * m_audioPresence;\n\n    const float trebleTarget = ctx.audio.available\n        ? clamp01f(0.65f * ctx.audio.heavyTreble() + 0.35f * ctx.audio.timbralSaliency())\n        : fallbackSine(ctx.rawTotalTimeMs, 0.0016f, 1.7f);\n    m_trebleEnv = smoothTo(m_trebleEnv, trebleTarget, dtSignal, 0.09f);\n\n    const bool shimmerHit = ctx.audio.available && (ctx.audio.isHihatHit() || ctx.audio.timbralSaliency() > 0.55f);\n    if (shimmerHit) {\n        m_shimmer = 1.0f;\n    } else {\n        m_shimmer = decay(m_shimmer, dtSignal, 0.14f);\n    }\n\n    m_phase += 0.95f * (0.45f + 1.55f * m_trebleEnv) * dtVisual;\n    if (m_phase > 100000.0f) m_phase = fmodf(m_phase, EX_TAU);\n\n    const float hueTarget = static_cast<float>(static_cast<uint8_t>(selectMusicalHue(ctx, m_chordGateOpen) + 116));\n    m_hue = smoothHue(m_hue, hueTarget, dtSignal, 0.45f);\n    const uint8_t baseHue = static_cast<uint8_t>(m_hue);\n\n    memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        const float d = static_cast<float>(dist) / static_cast<float>(HALF_LENGTH);\n\n        const float netA = sinf(static_cast<float>(dist) * (0.28f + 0.14f * m_trebleEnv) - m_phase * 4.7f);\n        const float netB = sinf(static_cast<float>(dist) * (0.52f + 0.10f * m_trebleEnv) + m_phase * 6.1f);\n        const float moire = 1.0f - fabsf(netA * netB);\n        const float edge = smoothstep01(d);\n\n        const float spark = powf(0.5f + 0.5f * sinf(static_cast<float>(dist) * 0.9f + m_phase * 12.0f), 6.0f) * m_shimmer;\n        const float intensity = clamp01f((0.20f + 0.80f * moire) * (0.25f + 0.75f * edge) *\n                                         (0.30f + 0.70f * m_trebleEnv) + spark);\n\n        const uint8_t br = toBrightness(intensity, master);\n        const uint8_t idxA = static_cast<uint8_t>(baseHue + static_cast<uint8_t>(moire * 28.0f) + static_cast<uint8_t>(edge * 16.0f));\n        setCentrePairMono(ctx, dist, ctx.palette.getColor(idxA, br));\n    }\n}\n\nvoid LGPTrebleNetEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPTrebleNetEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Treble Net\",\n        \"Timbral shimmer lattice with edge-biased spectral filaments\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------------------------------------\n// LGP Rhythmic Gate\n// Principle: temporal shutters and travelling seam locked to beat policy.\n// ---------------------------------------------------------------------------\n\nLGPRhythmicGateEffect::LGPRhythmicGateEffect() = default;\n\nbool LGPRhythmicGateEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_phase = 0.0f;\n    m_gate = 0.0f;\n    m_pulse = 0.0f;\n    m_lastBeatMs = 0;\n    m_hue = 24.0f;\n    m_audioPresence = 0.0f;\n    m_chordGateOpen = false;\n    return true;\n}\n\nvoid LGPRhythmicGateEffect::render(plugins::EffectContext& ctx) {\n    const float dtSignal = AudioReactivePolicy::signalDt(ctx);\n    const float dtVisual = AudioReactivePolicy::visualDt(ctx);\n    m_audioPresence = trackAudioPresence(m_audioPresence, ctx.audio.available, dtSignal);\n    if (m_audioPresence <= 0.001f) {\n        memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n        return;\n    }\n    const float master = (ctx.brightness / 255.0f) * m_audioPresence;\n\n    const float rhythmicTarget = ctx.audio.available\n        ? clamp01f(ctx.audio.rhythmicSaliency())\n        : fallbackSine(ctx.rawTotalTimeMs, 0.0010f, 0.5f);\n    m_gate = smoothTo(m_gate, rhythmicTarget, dtSignal, 0.11f);\n\n    const bool beatTick = AudioReactivePolicy::audioBeatTick(ctx, 128.0f, m_lastBeatMs);\n    if (beatTick) {\n        m_pulse = 1.0f;\n    } else {\n        m_pulse = decay(m_pulse, dtSignal, 0.17f);\n    }\n\n    m_phase += 0.85f * (0.60f + 1.10f * m_gate) * dtVisual;\n    if (m_phase > 100000.0f) m_phase = fmodf(m_phase, EX_TAU);\n\n    const float gateRate = 0.0013f + 0.0034f * (0.25f + 0.75f * m_gate);\n    const float gateClock = fmodf(static_cast<float>(ctx.rawTotalTimeMs) * gateRate, 1.0f);\n    const float duty = 0.24f + 0.48f * m_gate;\n    const float frontPos = clamp01f(1.0f - m_pulse);\n\n    const float hueTarget = static_cast<float>(static_cast<uint8_t>(selectMusicalHue(ctx, m_chordGateOpen) + 30));\n    m_hue = smoothHue(m_hue, hueTarget, dtSignal, 0.45f);\n    const uint8_t baseHue = static_cast<uint8_t>(m_hue);\n\n    memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        const float d = static_cast<float>(dist) / static_cast<float>(HALF_LENGTH);\n\n        const float bars = 0.5f + 0.5f * sinf(static_cast<float>(dist) * 0.16f - m_phase * 3.8f);\n        const float gateRaw = duty - gateClock;\n        const float gateSoft = clamp01f(0.5f + gateRaw / (0.08f + 0.20f * (1.0f - m_gate)));\n        const float gateMask = smoothstep01(gateSoft);\n        const float seam = expf(-fabsf(d - frontPos) * 13.5f) * m_pulse;\n\n        const float intensity = clamp01f((0.18f + 0.82f * gateMask) * (0.25f + 0.75f * bars) *\n                                         (0.32f + 0.68f * m_gate) + seam * 0.85f);\n\n        const uint8_t br = toBrightness(intensity, master);\n        const uint8_t idxA = static_cast<uint8_t>(baseHue + static_cast<uint8_t>(gateMask * 26.0f) + static_cast<uint8_t>(bars * 18.0f));\n        setCentrePairMono(ctx, dist, ctx.palette.getColor(idxA, br));\n    }\n}\n\nvoid LGPRhythmicGateEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPRhythmicGateEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Rhythmic Gate\",\n        \"Beat-gated lattice shutters with travelling pulse seams\",\n        plugins::EffectCategory::PARTY,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------------------------------------\n// LGP Spectral Knot\n// Principle: coupled counter-propagating knot rings from spectral imbalance.\n// ---------------------------------------------------------------------------\n\nLGPSpectralKnotEffect::LGPSpectralKnotEffect() = default;\n\nbool LGPSpectralKnotEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_phase = 0.0f;\n    m_knot = 0.0f;\n    m_rotation = 0.0f;\n    m_hue = 24.0f;\n    m_audioPresence = 0.0f;\n    m_chordGateOpen = false;\n    return true;\n}\n\nvoid LGPSpectralKnotEffect::render(plugins::EffectContext& ctx) {\n    const float dtSignal = AudioReactivePolicy::signalDt(ctx);\n    const float dtVisual = AudioReactivePolicy::visualDt(ctx);\n    m_audioPresence = trackAudioPresence(m_audioPresence, ctx.audio.available, dtSignal);\n    if (m_audioPresence <= 0.001f) {\n        memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n        return;\n    }\n    const float master = (ctx.brightness / 255.0f) * m_audioPresence;\n\n    const float low = binsRangeEnergy(ctx, 0, 10);\n    const float mid = binsRangeEnergy(ctx, 12, 32);\n    const float high = binsRangeEnergy(ctx, 36, 63);\n\n    const float knotTarget = ctx.audio.available\n        ? clamp01f(fabsf(low - high) + 0.45f * mid)\n        : fallbackSine(ctx.rawTotalTimeMs, 0.0012f, 2.4f);\n    m_knot = smoothTo(m_knot, knotTarget, dtSignal, 0.14f);\n\n    m_rotation += 0.60f * (0.35f + 0.95f * m_knot) * dtVisual;\n    if (m_rotation > EX_TAU) m_rotation -= EX_TAU;\n\n    m_phase += 0.78f * (0.60f + 1.20f * mid) * dtVisual;\n    if (m_phase > 100000.0f) m_phase = fmodf(m_phase, EX_TAU);\n\n    const float knotPos = clamp01f(0.5f + 0.28f * sinf(m_rotation));\n    const float antiPos = 1.0f - knotPos;\n    const float hueTarget = static_cast<float>(static_cast<uint8_t>(selectMusicalHue(ctx, m_chordGateOpen) + 44));\n    m_hue = smoothHue(m_hue, hueTarget, dtSignal, 0.45f);\n    const uint8_t baseHue = static_cast<uint8_t>(m_hue);\n\n    memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        const float d = static_cast<float>(dist) / static_cast<float>(HALF_LENGTH);\n\n        const float ringA = expf(-fabsf(d - knotPos) * (8.5f + 7.0f * m_knot));\n        const float ringB = expf(-fabsf(d - antiPos) * (8.5f + 7.0f * m_knot));\n        const float braid1 = 0.5f + 0.5f * sinf(static_cast<float>(dist) * 0.23f - m_phase * 4.6f);\n        const float braid2 = 0.5f + 0.5f * sinf(static_cast<float>(dist) * 0.37f + m_phase * 5.2f);\n        const float weave = fabsf(braid1 - braid2);\n\n        const float intensity = clamp01f(fmaxf(ringA, ringB) * (0.25f + 0.75f * weave) * (0.30f + 0.70f * m_knot));\n\n        const uint8_t br = toBrightness(intensity, master);\n        const uint8_t idxA = static_cast<uint8_t>(baseHue + static_cast<uint8_t>(weave * 40.0f) + static_cast<uint8_t>(knotPos * 18.0f));\n        setCentrePairMono(ctx, dist, ctx.palette.getColor(idxA, br));\n    }\n}\n\nvoid LGPSpectralKnotEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPSpectralKnotEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Spectral Knot\",\n        \"Frequency-balance knot fields crossing in mirrored rings\",\n        plugins::EffectCategory::GEOMETRIC,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------------------------------------\n// LGP Saliency Bloom\n// Principle: activator-inhibitor bloom shell riding over centre diffusion bed.\n// ---------------------------------------------------------------------------\n\nLGPSaliencyBloomEffect::LGPSaliencyBloomEffect() = default;\n\nbool LGPSaliencyBloomEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_phase = 0.0f;\n    m_saliency = 0.0f;\n    m_bloom = 0.0f;\n    m_lastBeatMs = 0;\n    m_hue = 24.0f;\n    m_audioPresence = 0.0f;\n    m_chordGateOpen = false;\n    return true;\n}\n\nvoid LGPSaliencyBloomEffect::render(plugins::EffectContext& ctx) {\n    const float dtSignal = AudioReactivePolicy::signalDt(ctx);\n    const float dtVisual = AudioReactivePolicy::visualDt(ctx);\n    m_audioPresence = trackAudioPresence(m_audioPresence, ctx.audio.available, dtSignal);\n    if (m_audioPresence <= 0.001f) {\n        memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n        return;\n    }\n    const float master = (ctx.brightness / 255.0f) * m_audioPresence;\n\n    const float saliencyTarget = ctx.audio.available\n        ? clamp01f(ctx.audio.overallSaliency())\n        : fallbackSine(ctx.rawTotalTimeMs, 0.0009f, 1.2f);\n    m_saliency = smoothTo(m_saliency, saliencyTarget, dtSignal, 0.16f);\n\n    const bool beatTick = AudioReactivePolicy::audioBeatTick(ctx, 128.0f, m_lastBeatMs);\n    if (beatTick) {\n        m_bloom = 1.0f;\n    } else {\n        const float floor = clamp01f(0.25f * m_saliency);\n        m_bloom = fmaxf(decay(m_bloom, dtSignal, 0.42f), floor);\n    }\n\n    m_phase += 0.68f * (0.45f + 1.10f * m_saliency) * dtVisual;\n    if (m_phase > 100000.0f) m_phase = fmodf(m_phase, EX_TAU);\n\n    const float ringPos = clamp01f(1.0f - m_bloom);\n    const float hueTarget = static_cast<float>(static_cast<uint8_t>(selectMusicalHue(ctx, m_chordGateOpen) + 14));\n    m_hue = smoothHue(m_hue, hueTarget, dtSignal, 0.45f);\n    const uint8_t baseHue = static_cast<uint8_t>(m_hue);\n\n    memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        const float d = static_cast<float>(dist) / static_cast<float>(HALF_LENGTH);\n\n        const float bed = expf(-d * (1.8f + 1.3f * (1.0f - m_saliency))) * (0.35f + 0.65f * (0.5f + 0.5f * sinf(m_phase * 2.4f)));\n        const float activator = expf(-fabsf(d - ringPos) * 11.0f) * m_bloom;\n        const float inhibitor = expf(-fabsf(d - clamp01f(ringPos + 0.10f)) * 14.5f) * m_bloom;\n        const float intensity = clamp01f(bed * (0.35f + 0.65f * m_saliency) + activator * 0.95f - inhibitor * 0.50f);\n\n        const uint8_t br = toBrightness(intensity, master);\n        const uint8_t idxA = static_cast<uint8_t>(baseHue + static_cast<uint8_t>(activator * 30.0f) + static_cast<uint8_t>(d * 22.0f));\n        setCentrePairMono(ctx, dist, ctx.palette.getColor(idxA, br));\n    }\n}\n\nvoid LGPSaliencyBloomEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPSaliencyBloomEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Saliency Bloom\",\n        \"Overall novelty drives expanding bloom radius and density\",\n        plugins::EffectCategory::AMBIENT,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------------------------------------\n// LGP Transient Lattice\n// Principle: transient impacts etch and decay a centre-symmetric scaffold.\n// ---------------------------------------------------------------------------\n\nLGPTransientLatticeEffect::LGPTransientLatticeEffect() = default;\n\nbool LGPTransientLatticeEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_phase = 0.0f;\n    m_transient = 0.0f;\n    m_memory = 0.0f;\n    m_lastBeatMs = 0;\n    m_hue = 24.0f;\n    m_audioPresence = 0.0f;\n    m_chordGateOpen = false;\n    return true;\n}\n\nvoid LGPTransientLatticeEffect::render(plugins::EffectContext& ctx) {\n    const float dtSignal = AudioReactivePolicy::signalDt(ctx);\n    const float dtVisual = AudioReactivePolicy::visualDt(ctx);\n    m_audioPresence = trackAudioPresence(m_audioPresence, ctx.audio.available, dtSignal);\n    if (m_audioPresence <= 0.001f) {\n        memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n        return;\n    }\n    const float master = (ctx.brightness / 255.0f) * m_audioPresence;\n\n    float seed = ctx.audio.available ? clamp01f(ctx.audio.fastFlux()) : fallbackSine(ctx.rawTotalTimeMs, 0.0015f, 2.0f);\n    if (ctx.audio.available && ctx.audio.isSnareHit()) seed = fmaxf(seed, 0.95f);\n    if (ctx.audio.available && ctx.audio.isHihatHit()) seed = fmaxf(seed, 0.70f);\n    if (AudioReactivePolicy::audioBeatTick(ctx, 128.0f, m_lastBeatMs)) seed = fmaxf(seed, 0.82f);\n\n    if (seed > m_transient) {\n        m_transient = seed;\n    } else {\n        m_transient = decay(m_transient, dtSignal, 0.19f);\n    }\n\n    m_memory = clamp01f(m_memory * expf(-dtSignal / 0.68f) + m_transient * 0.20f);\n\n    m_phase += 0.92f * (0.55f + 1.40f * m_transient) * dtVisual;\n    if (m_phase > 100000.0f) m_phase = fmodf(m_phase, EX_TAU);\n\n    const float ringPos = clamp01f(1.0f - m_transient);\n    const float hueTarget = static_cast<float>(static_cast<uint8_t>(selectMusicalHue(ctx, m_chordGateOpen) + 62));\n    m_hue = smoothHue(m_hue, hueTarget, dtSignal, 0.45f);\n    const uint8_t baseHue = static_cast<uint8_t>(m_hue);\n\n    memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        const float d = static_cast<float>(dist) / static_cast<float>(HALF_LENGTH);\n\n        const float l1 = fabsf(sinf(static_cast<float>(dist) * 0.27f - m_phase * 4.2f));\n        const float l2 = fabsf(sinf(static_cast<float>(dist) * 0.14f + m_phase * 6.8f));\n        const float scaffold = l1 * l2;\n        const float impact = expf(-fabsf(d - ringPos) * 13.0f) * m_transient;\n        const float afterglow = expf(-d * 2.4f) * m_memory;\n        const float intensity = clamp01f(scaffold * (0.20f + 0.80f * m_memory) + 0.92f * impact + 0.35f * afterglow);\n\n        const uint8_t br = toBrightness(intensity, master);\n        const uint8_t idxA = static_cast<uint8_t>(baseHue + static_cast<uint8_t>(scaffold * 44.0f) + static_cast<uint8_t>(m_memory * 12.0f));\n        setCentrePairMono(ctx, dist, ctx.palette.getColor(idxA, br));\n    }\n}\n\nvoid LGPTransientLatticeEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPTransientLatticeEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Transient Lattice\",\n        \"Snare and flux impacts drive a decaying interference scaffold\",\n        plugins::EffectCategory::PARTY,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------------------------------------\n// LGP Wavelet Mirror\n// Principle: mirrored waveform crest field with beat-reinforced travelling ridge.\n// ---------------------------------------------------------------------------\n\nLGPWaveletMirrorEffect::LGPWaveletMirrorEffect() = default;\n\nbool LGPWaveletMirrorEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_phase = 0.0f;\n    m_waveEnv = 0.0f;\n    m_beatTrail = 0.0f;\n    m_lastBeatMs = 0;\n    m_hue = 24.0f;\n    m_audioPresence = 0.0f;\n    m_chordGateOpen = false;\n    return true;\n}\n\nvoid LGPWaveletMirrorEffect::render(plugins::EffectContext& ctx) {\n    const float dtSignal = AudioReactivePolicy::signalDt(ctx);\n    const float dtVisual = AudioReactivePolicy::visualDt(ctx);\n    m_audioPresence = trackAudioPresence(m_audioPresence, ctx.audio.available, dtSignal);\n    if (m_audioPresence <= 0.001f) {\n        memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n        return;\n    }\n    const float master = (ctx.brightness / 255.0f) * m_audioPresence;\n\n    float waveAvg = 0.0f;\n    if (ctx.audio.available) {\n        for (uint8_t s = 0; s < 8; ++s) {\n            const uint8_t idx = static_cast<uint8_t>((s * 16u + ((ctx.rawTotalTimeMs >> 3) & 0x0Fu)) & 0x7Fu);\n            waveAvg += fabsf(ctx.audio.getWaveformNormalized(idx));\n        }\n        waveAvg *= 0.125f;\n    }\n\n    const float waveTarget = ctx.audio.available\n        ? fmaxf(clamp01f(ctx.audio.rms()), clamp01f(waveAvg))\n        : fallbackSine(ctx.rawTotalTimeMs, 0.0012f, 0.6f);\n    m_waveEnv = smoothTo(m_waveEnv, waveTarget, dtSignal, 0.09f);\n\n    const bool beatTick = AudioReactivePolicy::audioBeatTick(ctx, 128.0f, m_lastBeatMs);\n    if (beatTick) {\n        m_beatTrail = 1.0f;\n    } else {\n        m_beatTrail = decay(m_beatTrail, dtSignal, 0.22f);\n    }\n\n    m_phase += 0.82f * (0.55f + 1.35f * m_waveEnv) * dtVisual;\n    if (m_phase > 100000.0f) m_phase = fmodf(m_phase, EX_TAU);\n\n    const float ridgePos = clamp01f(1.0f - m_beatTrail);\n    const float hueTarget = static_cast<float>(static_cast<uint8_t>(selectMusicalHue(ctx, m_chordGateOpen) + 30));\n    m_hue = smoothHue(m_hue, hueTarget, dtSignal, 0.45f);\n    const uint8_t baseHue = static_cast<uint8_t>(m_hue);\n\n    memset(ctx.leds, 0, ctx.ledCount * sizeof(CRGB));\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        const float d = static_cast<float>(dist) / static_cast<float>(HALF_LENGTH);\n        const uint8_t idx = static_cast<uint8_t>((dist * 128u) / HALF_LENGTH);\n        const uint8_t idxMirror = static_cast<uint8_t>(127u - idx);\n\n        const float s1 = ctx.audio.available\n            ? ctx.audio.getWaveformNormalized(idx)\n            : sinf(m_phase * 2.8f + d * EX_TAU);\n        const float s2 = ctx.audio.available\n            ? ctx.audio.getWaveformNormalized(idxMirror)\n            : sinf(m_phase * 2.8f + (1.0f - d) * EX_TAU);\n\n        const float crest1 = powf(clamp01f(fabsf(s1)), 0.72f);\n        const float crest2 = powf(clamp01f(fabsf(s2)), 0.72f);\n        const float carrier1 = 0.5f + 0.5f * sinf(static_cast<float>(dist) * 0.19f - m_phase * 4.5f);\n        const float carrier2 = 0.5f + 0.5f * sinf(static_cast<float>(dist) * 0.19f + m_phase * 4.5f + EX_PI * 0.5f);\n        const float ridge = expf(-fabsf(d - ridgePos) * 11.0f) * m_beatTrail;\n\n        const float i1 = clamp01f((0.22f + 0.78f * crest1) * (0.25f + 0.75f * carrier1) * (0.35f + 0.65f * m_waveEnv) + ridge * 0.72f);\n        const float i2 = clamp01f((0.22f + 0.78f * crest2) * (0.25f + 0.75f * carrier2) * (0.35f + 0.65f * m_waveEnv) + ridge * 0.72f);\n\n        const uint8_t br = toBrightness(0.5f * (i1 + i2), master);\n        const uint8_t idxA = static_cast<uint8_t>(baseHue +\n            static_cast<uint8_t>((0.5f * (crest1 + crest2)) * 34.0f) +\n            static_cast<uint8_t>(d * 16.0f));\n        setCentrePairMono(ctx, dist, ctx.palette.getColor(idxA, br));\n    }\n}\n\nvoid LGPWaveletMirrorEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPWaveletMirrorEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Wavelet Mirror\",\n        \"Waveform crest mirroring with beat-travel ridge reinforcement\",\n        plugins::EffectCategory::GEOMETRIC,\n        1\n    };\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
