{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_LGP_INTERFERENCE_SCANNER_ENHANCED",
  "effectIdHex": "0x0E03",
  "className": "LGPInterferenceScannerEnhancedEffect",
  "displayName": "LGP Interference Scanner Enhanced",
  "headerPath": "firmware/v2/src/effects/ieffect/LGPInterferenceScannerEffectEnhanced.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/LGPInterferenceScannerEffectEnhanced.cpp",
  "renderRange": [
    59,
    247
  ],
  "phaseRanges": {
    "input": [
      [
        65,
        65
      ],
      [
        70,
        70
      ],
      [
        72,
        72
      ],
      [
        76,
        76
      ],
      [
        83,
        83
      ],
      [
        93,
        93
      ],
      [
        104,
        104
      ],
      [
        148,
        148
      ],
      [
        197,
        197
      ],
      [
        215,
        215
      ]
    ],
    "mapping": [
      [
        61,
        64
      ],
      [
        77,
        79
      ],
      [
        81,
        81
      ],
      [
        83,
        83
      ],
      [
        95,
        95
      ],
      [
        106,
        106
      ],
      [
        109,
        110
      ],
      [
        114,
        114
      ],
      [
        128,
        128
      ],
      [
        134,
        134
      ],
      [
        139,
        140
      ],
      [
        143,
        144
      ],
      [
        151,
        151
      ],
      [
        153,
        154
      ],
      [
        157,
        157
      ],
      [
        165,
        165
      ],
      [
        189,
        190
      ],
      [
        208,
        208
      ],
      [
        235,
        235
      ]
    ],
    "modulation": [
      [
        74,
        74
      ],
      [
        87,
        87
      ],
      [
        130,
        130
      ],
      [
        133,
        133
      ],
      [
        138,
        138
      ],
      [
        142,
        144
      ],
      [
        147,
        147
      ],
      [
        150,
        150
      ],
      [
        152,
        152
      ],
      [
        156,
        159
      ],
      [
        161,
        167
      ],
      [
        171,
        174
      ],
      [
        176,
        176
      ],
      [
        181,
        182
      ],
      [
        185,
        185
      ],
      [
        191,
        192
      ],
      [
        197,
        197
      ],
      [
        199,
        199
      ],
      [
        201,
        201
      ],
      [
        209,
        209
      ]
    ],
    "render": [
      [
        82,
        82
      ],
      [
        92,
        92
      ],
      [
        103,
        103
      ],
      [
        132,
        132
      ],
      [
        178,
        178
      ],
      [
        236,
        236
      ],
      [
        239,
        239
      ],
      [
        243,
        243
      ]
    ],
    "post": [
      [
        225,
        237
      ]
    ],
    "output": [
      [
        178,
        178
      ],
      [
        239,
        241
      ],
      [
        243,
        243
      ]
    ]
  },
  "mappingConfidence": "medium",
  "mappingWarnings": [
    "Phase 'post' inferred from fallback segmentation."
  ],
  "sourceText": "/**\n * @file LGPInterferenceScannerEnhancedEffect.cpp\n * @brief LGP Interference Scanner Enhanced - Enhanced version with optimized thresholds and snare boost\n */\n\n#include \"LGPInterferenceScannerEffectEnhanced.h\"\n#include \"../CoreEffects.h\"\n#include \"../enhancement/MotionEngine.h\"\n#include \"../../config/features.h\"\n#include \"../../validation/EffectValidationMacros.h\"\n#include <FastLED.h>\n#include <cmath>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nLGPInterferenceScannerEnhancedEffect::LGPInterferenceScannerEnhancedEffect()\n    : m_scanPhase(0.0f)\n{\n}\n\nbool LGPInterferenceScannerEnhancedEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_scanPhase = 0.0f;\n    m_lastHopSeq = 0;\n    m_chromaEnergySum = 0.0f;\n    m_chromaHistIdx = 0;\n    for (uint8_t i = 0; i < CHROMA_HISTORY; ++i) {\n        m_chromaEnergyHist[i] = 0.0f;\n    }\n    m_energyAvg = 0.0f;\n    m_energyDelta = 0.0f;\n    m_chromaAngle = 0.0f;\n    m_bassWavelength = 0.0f;\n    m_trebleOverlay = 0.0f;\n\n    // Initialize chromagram smoothing\n    for (uint8_t i = 0; i < 12; i++) {\n        m_chromaFollowers[i].reset(0.0f);\n        m_chromaSmoothed[i] = 0.0f;\n        m_chromaTargets[i] = 0.0f;\n    }\n    \n    // Initialize smoothing followers\n    m_bassFollower.reset(0.0f);\n    m_trebleFollower.reset(0.0f);\n    m_targetBass = 0.0f;\n    m_targetTreble = 0.0f;\n    \n    // Initialize enhancement utilities\n    m_speedSpring.init(50.0f, 1.0f);  // stiffness=50, mass=1 (critically damped)\n    m_speedSpring.reset(1.0f);         // Start at base speed\n    m_energyAvgFollower.reset(0.0f);\n    m_energyDeltaFollower.reset(0.0f);\n    return true;\n}\n\nvoid LGPInterferenceScannerEnhancedEffect::render(plugins::EffectContext& ctx) {\n    // CENTER ORIGIN INTERFERENCE SCANNER - Creates scanning interference patterns\n    float speedNorm = ctx.speed / 50.0f;\n    float intensityNorm = ctx.brightness / 255.0f;\n    float complexityNorm = ctx.complexity / 255.0f;\n    float variationNorm = ctx.variation / 255.0f;\n    const bool hasAudio = ctx.audio.available;\n    bool newHop = false;\n\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n        if (newHop) {\n            m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n\n            // LGP-SMOOTH: Use heavy_bands mid-frequency for smoother energy signal\n            // This replaces raw chroma processing which is prone to spikes\n            float heavyMid = ctx.audio.heavyMid();  // Accessor: (heavy_bands[2-4]) / 3.0f\n            float energyNorm = heavyMid;\n            if (energyNorm < 0.0f) energyNorm = 0.0f;\n            if (energyNorm > 1.0f) energyNorm = 1.0f;\n\n            // Update chromagram targets\n            for (uint8_t i = 0; i < 12; i++) {\n                m_chromaTargets[i] = ctx.audio.controlBus.heavy_chroma[i];\n            }\n            \n            // =================================================================\n            // 64-bin Sub-Bass Wavelength Modulation (bins 0-5 = 110-155 Hz)\n            // Deep bass widens the interference pattern - kick drums create\n            // slow, majestic wave expansion instead of tight fringes.\n            // =================================================================\n            float bassSum = 0.0f;\n            for (uint8_t i = 0; i < 6; ++i) {\n                bassSum += ctx.audio.binAdaptive(i);\n            }\n            m_targetBass = bassSum / 6.0f;\n\n            // =================================================================\n            // 64-bin Treble Overlay (bins 48-63 = 1.3-4.2 kHz)\n            // Hi-hat and cymbal energy adds high-frequency sparkle on top\n            // of the interference pattern.\n            // =================================================================\n            float trebleSum = 0.0f;\n            for (uint8_t i = 48; i < 64; ++i) {\n                trebleSum += ctx.audio.binAdaptive(i);\n            }\n            m_targetTreble = trebleSum / 16.0f;\n\n            m_chromaEnergySum -= m_chromaEnergyHist[m_chromaHistIdx];\n            m_chromaEnergyHist[m_chromaHistIdx] = energyNorm;\n            m_chromaEnergySum += energyNorm;\n            m_chromaHistIdx = (m_chromaHistIdx + 1) % CHROMA_HISTORY;\n\n            m_energyAvg = m_chromaEnergySum / CHROMA_HISTORY;\n            m_energyDelta = energyNorm - m_energyAvg;\n            if (m_energyDelta < 0.0f) m_energyDelta = 0.0f;\n        }\n    } else\n#endif\n    {\n        // dt-corrected decay when audio unavailable\n        float dtFallback = enhancement::getSafeDeltaSeconds(ctx.rawDeltaTimeSeconds);\n        m_energyAvg *= powf(0.98f, dtFallback * 60.0f);\n        m_energyDelta = 0.0f;\n    }\n\n    float rawDt = enhancement::getSafeDeltaSeconds(ctx.rawDeltaTimeSeconds);\n    float dt = enhancement::getSafeDeltaSeconds(ctx.deltaTimeSeconds);\n    float moodNorm = ctx.getMoodNormalized();\n\n    // Smooth chromagram with AsymmetricFollower (every frame)\n    if (hasAudio) {\n        for (uint8_t i = 0; i < 12; i++) {\n            m_chromaSmoothed[i] = m_chromaFollowers[i].updateWithMood(\n                m_chromaTargets[i], rawDt, moodNorm);\n        }\n    }\n\n    // Smooth bass and treble with AsymmetricFollower\n    m_bassWavelength = m_bassFollower.updateWithMood(m_targetBass, rawDt, moodNorm);\n    m_trebleOverlay = m_trebleFollower.updateWithMood(m_targetTreble, rawDt, moodNorm);\n\n    // True exponential smoothing with AsymmetricFollower (frame-rate independent)\n    float energyAvgSmooth = m_energyAvgFollower.updateWithMood(m_energyAvg, rawDt, moodNorm);\n    float energyDeltaSmooth = m_energyDeltaFollower.updateWithMood(m_energyDelta, rawDt, moodNorm);\n\n    // Circular chroma hue (replaces argmax + linear EMA to eliminate bin-flip rainbow sweeps)\n    uint8_t chromaHue = effects::chroma::circularChromaHueSmoothed(\n        ctx.audio.controlBus.heavy_chroma, m_chromaAngle, rawDt, 0.20f);\n\n    // Speed modulation with Spring physics (natural momentum, no jitter)\n    // Target range: 0.6 to 1.4 (2.3x variation max, not 10x)\n    float rawSpeedScale = 0.6f + 0.8f * energyAvgSmooth;  // Capture raw speed for validation\n    float speedTarget = rawSpeedScale;\n    if (speedTarget > 1.4f) speedTarget = 1.4f;\n\n    // Spring physics for speed modulation (replaces linear slew limiting)\n    float smoothedSpeed = m_speedSpring.update(speedTarget, dt);\n    if (smoothedSpeed > 1.4f) smoothedSpeed = 1.4f;  // Hard clamp\n    if (smoothedSpeed < 0.3f) smoothedSpeed = 0.3f;  // Prevent stalling\n\n    // Capture phase before update for delta calculation\n    float prevPhase = m_scanPhase;\n    // FIX: Use 240.0f multiplier like ChevronWaves (was 3.6f via advancePhase - 67x slower!)\n    // Fast phase accumulation makes forward motion perceptually dominant\n    m_scanPhase += speedNorm * 240.0f * smoothedSpeed * dt;\n    if (m_scanPhase > 628.3f) m_scanPhase -= 628.3f;  // Wrap at 100*2π to prevent float overflow\n    float phaseDelta = m_scanPhase - prevPhase;\n\n    // Validation instrumentation\n    VALIDATION_INIT(16);  // Effect ID 16\n    VALIDATION_PHASE(m_scanPhase, phaseDelta);\n    VALIDATION_SPEED(rawSpeedScale, smoothedSpeed);\n    VALIDATION_AUDIO(m_chromaAngle, energyAvgSmooth, energyDeltaSmooth);\n    VALIDATION_REVERSAL_CHECK(m_prevPhaseDelta, phaseDelta);\n    VALIDATION_SUBMIT(::lightwaveos::validation::g_validationRing);\n    m_prevPhaseDelta = phaseDelta;\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float dist = (float)centerPairDistance((uint16_t)i);\n\n        // INTERFERENCE PATTERN: Two wavelengths create moiré beating patterns\n        // sin(k*dist - phase) produces OUTWARD motion when phase increases\n        //\n        // =====================================================================\n        // 64-bin BASS WAVELENGTH MODULATION: Sub-bass (bins 0-5) widens pattern\n        // On kick drum hits, the interference fringes expand majestically.\n        // Bass energy reduces frequency → larger wavelength → wider pattern.\n        // =====================================================================\n        float freq1 = (0.16f + 0.08f * complexityNorm) - 0.05f * m_bassWavelength;\n        float freq2 = (0.28f + 0.10f * complexityNorm) - 0.08f * m_bassWavelength;\n        float wave1 = sinf(dist * freq1 - m_scanPhase);\n        float wave2 = sinf(dist * freq2 - m_scanPhase * 1.2f);  // Slight phase offset\n        float interference = wave1 + wave2 * 0.6f;  // Combine with weight for moiré\n\n        // JOG-DIAL FIX: Audio modulates BRIGHTNESS, not speed - energyDelta drives intensity bursts\n#if FEATURE_AUDIO_SYNC\n        float fastFlux = hasAudio ? ctx.audio.fastFlux() : 0.0f;\n#else\n        float fastFlux = 0.0f;\n#endif\n        float audioGain = 0.4f + 0.5f * energyAvgSmooth + 0.5f * energyDeltaSmooth + 0.3f * fastFlux;\n\n        // =====================================================================\n        // 64-bin TREBLE SHIMMER: High frequencies (bins 48-63) add sparkle\n        // Hi-hat and cymbal energy creates high-frequency brightness overlay.\n        // =====================================================================\n        if (m_trebleOverlay > 0.1f) {\n            float shimmerFreq = 1.2f + variationNorm * 0.9f;\n            float shimmer = m_trebleOverlay * sinf(dist * shimmerFreq + m_scanPhase * 4.0f);\n            audioGain += shimmer * 0.35f;\n        }\n\n        // PERCUSSION BOOST: Add amplitude spike on snare hit for visual punch\n#if FEATURE_AUDIO_SYNC\n        if (hasAudio && ctx.audio.isSnareHit()) {\n            audioGain += 0.8f;  // Burst on snare\n        }\n#endif\n        audioGain = fminf(audioGain, 2.0f);  // Clamp max to prevent oversaturation\n\n        // VISIBILITY FIX: Ensure minimum interference amplitude\n        float interferenceAbs = fabsf(interference);\n        if (interferenceAbs < 0.2f) {\n            interference = (interference >= 0.0f) ? 0.2f : -0.2f;\n        }\n\n        float pattern = interference * audioGain;\n\n        // CRITICAL: Use tanhf for uniform brightness (like ChevronWaves)\n        pattern = tanhf(pattern * 2.0f) * 0.5f + 0.5f;\n\n        // VISIBILITY FIX: Ensure minimum brightness floor\n        pattern = fmaxf(0.2f, pattern);\n\n        uint8_t brightness = (uint8_t)(pattern * 255.0f * intensityNorm);\n        uint8_t paletteIndex = (uint8_t)(dist * 2.0f + pattern * 50.0f);\n        uint8_t baseHue = (uint8_t)(ctx.gHue + chromaHue);\n\n        ctx.leds[i] = ctx.palette.getColor((uint8_t)(baseHue + paletteIndex), brightness);\n        if (i + STRIP_LENGTH < ctx.ledCount) {\n            // FIX: Use SAME brightness for both strips (was inverted, causing visual backward motion)\n            // Hue offset +90 matches ChevronWaves pattern (was +128)\n            ctx.leds[i + STRIP_LENGTH] = ctx.palette.getColor((uint8_t)(baseHue + paletteIndex + 90),\n                                                             brightness);\n        }\n    }\n}\n\nvoid LGPInterferenceScannerEnhancedEffect::cleanup() {\n    // No resources to free\n}\n\nconst plugins::EffectMetadata& LGPInterferenceScannerEnhancedEffect::getMetadata() const {\n    static plugins::EffectMetadata meta(\n        \"LGP Interference Scanner Enhanced\",\n        \"Enhanced: Optimized 64-bin usage, enhanced snare boost, beatPhase sync\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    );\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
