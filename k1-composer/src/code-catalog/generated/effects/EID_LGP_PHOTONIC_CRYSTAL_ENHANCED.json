{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_LGP_PHOTONIC_CRYSTAL_ENHANCED",
  "effectIdHex": "0x0E04",
  "className": "LGPPhotonicCrystalEnhancedEffect",
  "displayName": "LGP Photonic Crystal Enhanced",
  "headerPath": "firmware/v2/src/effects/ieffect/LGPPhotonicCrystalEffectEnhanced.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/LGPPhotonicCrystalEffectEnhanced.cpp",
  "renderRange": [
    87,
    301
  ],
  "phaseRanges": {
    "input": [
      [
        108,
        108
      ],
      [
        110,
        111
      ],
      [
        122,
        122
      ],
      [
        124,
        124
      ],
      [
        126,
        126
      ],
      [
        141,
        141
      ],
      [
        147,
        147
      ],
      [
        172,
        172
      ],
      [
        180,
        180
      ],
      [
        194,
        194
      ],
      [
        197,
        197
      ],
      [
        208,
        209
      ],
      [
        277,
        277
      ]
    ],
    "mapping": [
      [
        93,
        93
      ],
      [
        113,
        114
      ],
      [
        139,
        139
      ],
      [
        141,
        141
      ],
      [
        149,
        149
      ],
      [
        156,
        156
      ],
      [
        160,
        160
      ],
      [
        163,
        164
      ],
      [
        189,
        189
      ],
      [
        205,
        205
      ],
      [
        210,
        210
      ],
      [
        212,
        213
      ]
    ],
    "modulation": [
      [
        102,
        102
      ],
      [
        153,
        153
      ],
      [
        155,
        155
      ],
      [
        159,
        159
      ],
      [
        163,
        164
      ],
      [
        166,
        167
      ],
      [
        179,
        179
      ],
      [
        184,
        184
      ],
      [
        186,
        187
      ],
      [
        192,
        192
      ],
      [
        204,
        205
      ],
      [
        207,
        207
      ],
      [
        209,
        210
      ],
      [
        213,
        215
      ],
      [
        217,
        217
      ],
      [
        220,
        221
      ],
      [
        224,
        226
      ],
      [
        228,
        229
      ],
      [
        257,
        257
      ],
      [
        261,
        261
      ]
    ],
    "render": [
      [
        140,
        140
      ],
      [
        146,
        146
      ],
      [
        154,
        154
      ],
      [
        225,
        226
      ],
      [
        232,
        232
      ],
      [
        234,
        234
      ],
      [
        290,
        290
      ],
      [
        293,
        293
      ],
      [
        295,
        296
      ]
    ],
    "post": [
      [
        184,
        184
      ],
      [
        207,
        207
      ],
      [
        217,
        217
      ],
      [
        224,
        224
      ]
    ],
    "output": [
      [
        234,
        234
      ],
      [
        292,
        295
      ]
    ]
  },
  "mappingConfidence": "high",
  "mappingWarnings": [],
  "sourceText": "/**\n * @file LGPPhotonicCrystalEffect.cpp\n * @brief LGP Photonic Crystal effect - v8 CORRECT audio-reactive motion\n *\n * v8: FIXED SPEED SMOOTHING ARCHITECTURE\n *\n * ROOT CAUSE of v7 jitter: Too many smoothing layers for speed\n *   v7 WRONG: heavyBass() → rolling avg → AsymmetricFollower → Spring (~630ms)\n *   v8 CORRECT: heavy_bands (pre-smoothed) → Spring ONLY (~200ms)\n *\n * The base algorithm is UNCHANGED from the original v1 lgpPhotonicCrystal():\n * - latticeSize = 4 + (complexity >> 6)  → 4-10 LEDs per cell\n * - defectProbability = variation        → random impurities\n * - inBandgap = cellPosition < (latticeSize >> 1)\n * - Allowed modes: sin8((distFromCenter << 2) - (phase >> 7))\n * - Forbidden decay: scale8(sin8(...), 255 - cellPosition * 50)\n *\n * Audio reactivity architecture (matches ChevronWaves/WaveCollision):\n * - Speed: heavy_bands[1]+[2] → Spring ONLY (0.6-1.4x, ~200ms response)\n * - Brightness: rolling avg + AsymmetricFollower (fine for visual intensity)\n * - Collision flash: snare-triggered, spatial decay from center\n * - Color offset: chroma dominant bin (smoothed over 250ms)\n */\n\n#include \"LGPPhotonicCrystalEffectEnhanced.h\"\n#include \"../CoreEffects.h\"\n#include <FastLED.h>\n#include <cmath>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nLGPPhotonicCrystalEnhancedEffect::LGPPhotonicCrystalEnhancedEffect()\n    : m_phase(0.0f)\n{\n}\n\nbool LGPPhotonicCrystalEnhancedEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n\n    // Initialize phase\n    m_phase = 0.0f;\n\n    // Audio hop tracking\n    m_lastHopSeq = 0;\n\n    // Energy history (4-hop rolling average)\n    for (uint8_t i = 0; i < ENERGY_HISTORY; ++i) {\n        m_energyHist[i] = 0.0f;\n    }\n    m_energySum = 0.0f;\n    m_energyHistIdx = 0;\n    m_energyAvg = 0.0f;\n    m_energyDelta = 0.0f;\n\n    // Reset asymmetric followers\n    m_energyAvgFollower.reset(0.5f);\n    m_energyDeltaFollower.reset(0.0f);\n\n    // Initialize spring with stiffness=50, critically damped\n    m_speedSpring.init(50.0f, 1.0f);\n    m_speedSpring.reset(1.0f);\n\n    // Collision flash\n    m_collisionBoost = 0.0f;\n    \n    // Enhanced: Initialize sub-bass tracking\n    m_subBassFollower.reset(0.0f);\n    m_subBassEnergy = 0.0f;\n    m_targetSubBass = 0.0f;\n\n    // Initialize chromagram smoothing\n    for (uint8_t i = 0; i < 12; i++) {\n        m_chromaFollowers[i].reset(0.0f);\n        m_chromaSmoothed[i] = 0.0f;\n        m_chromaTargets[i] = 0.0f;\n    }\n    \n    // Chroma tracking\n    m_chromaAngle = 0.0f;\n    m_tempoLocked = false;\n\n    return true;\n}\n\nvoid LGPPhotonicCrystalEnhancedEffect::render(plugins::EffectContext& ctx) {\n    // ========================================================================\n    // SAFE DELTA TIME (clamped for physics stability)\n    // ========================================================================\n    float rawDt = ctx.getSafeRawDeltaSeconds();\n    float dt = ctx.getSafeDeltaSeconds();\n    float moodNorm = ctx.getMoodNormalized();\n\n    // ========================================================================\n    // ORIGINAL V1 PARAMETERS (from ctx, NOT from audio)\n    // These MUST stay as the original algorithm intended\n    // ========================================================================\n    uint8_t latticeSize = 4 + (ctx.complexity >> 6);  // 4-10 LEDs per cell\n    uint8_t defectProbability = ctx.variation;         // Random impurities\n\n    // Audio modulation values (defaults for no-audio mode)\n    float speedMult = 1.0f;\n    float brightnessGain = 1.0f;\n    uint8_t chromaOffset = 0;\n\n#if FEATURE_AUDIO_SYNC\n    if (ctx.audio.available) {\n        // Enhanced: SPEED uses 64-bin sub-bass blended with heavy_bands\n        float heavyMid = (ctx.audio.controlBus.heavy_bands[1] +\n                          ctx.audio.controlBus.heavy_bands[2]) / 2.0f;\n        float heavyEnergy = m_subBassEnergy * 0.6f + heavyMid * 0.4f;  // Blend sub-bass with heavy_bands\n        float targetSpeed = 0.6f + 0.8f * heavyEnergy;  // 0.6-1.4x range\n        speedMult = m_speedSpring.update(targetSpeed, dt);\n        if (speedMult > 1.6f) speedMult = 1.6f;\n        if (speedMult < 0.3f) speedMult = 0.3f;\n\n        // ================================================================\n        // BRIGHTNESS: Per-hop sampling for energy baseline (separate from speed)\n        // Rolling avg + AsymmetricFollower is fine for visual intensity\n        // ================================================================\n        bool newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n        if (newHop) {\n            m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n\n            float currentEnergy = ctx.audio.heavyBass();\n\n            // Rolling 4-hop average (for brightness baseline only)\n            m_energySum -= m_energyHist[m_energyHistIdx];\n            m_energyHist[m_energyHistIdx] = currentEnergy;\n            m_energySum += currentEnergy;\n            m_energyHistIdx = (m_energyHistIdx + 1) % ENERGY_HISTORY;\n            m_energyAvg = m_energySum / ENERGY_HISTORY;\n\n            // Delta = energy ABOVE average (positive only)\n            m_energyDelta = currentEnergy - m_energyAvg;\n            if (m_energyDelta < 0.0f) m_energyDelta = 0.0f;\n\n            // Update chromagram targets\n            for (uint8_t i = 0; i < 12; i++) {\n                m_chromaTargets[i] = ctx.audio.controlBus.heavy_chroma[i];\n            }\n            \n            // Enhanced: 64-bin Sub-Bass Detection (bins 0-5 = ~110-155 Hz)\n            float subBassSum = 0.0f;\n            for (uint8_t i = 0; i < 6; ++i) {\n                subBassSum += ctx.audio.bin(i);\n            }\n            m_targetSubBass = subBassSum / 6.0f;\n            \n        }\n        \n        // Smooth chromagram with AsymmetricFollower (every frame)\n        for (uint8_t i = 0; i < 12; i++) {\n            m_chromaSmoothed[i] = m_chromaFollowers[i].updateWithMood(\n                m_chromaTargets[i], rawDt, moodNorm);\n        }\n        \n        // Enhanced: Smooth sub-bass energy\n        m_subBassEnergy = m_subBassFollower.updateWithMood(m_targetSubBass, rawDt, moodNorm);\n\n        // Asymmetric followers for BRIGHTNESS (not speed!)\n        float energyAvgSmooth = m_energyAvgFollower.updateWithMood(m_energyAvg, rawDt, moodNorm);\n        float energyDeltaSmooth = m_energyDeltaFollower.updateWithMood(m_energyDelta, rawDt, moodNorm);\n\n        // Brightness modulation\n        brightnessGain = 0.4f + 0.5f * energyAvgSmooth + 0.4f * energyDeltaSmooth;\n        if (brightnessGain > 1.5f) brightnessGain = 1.5f;\n        if (brightnessGain < 0.3f) brightnessGain = 0.3f;\n\n        // Enhanced: Collision flash (snare-triggered with sub-bass boost)\n        if (ctx.audio.isSnareHit()) {\n            m_collisionBoost = 1.0f + m_subBassEnergy * 0.3f;  // Boost with sub-bass\n        }\n        if (m_collisionBoost > 1.3f) m_collisionBoost = 1.3f;  // Clamp\n        m_collisionBoost = effects::chroma::dtDecay(m_collisionBoost, 0.88f, rawDt);\n\n        // Circular chroma hue (replaces argmax + linear EMA to eliminate bin-flip rainbow sweeps)\n        chromaOffset = effects::chroma::circularChromaHueSmoothed(\n            ctx.audio.controlBus.heavy_chroma, m_chromaAngle, rawDt, 0.20f);\n    }\n#endif\n\n    // Enhanced: Use beatPhase for synchronization when tempo confidence high (PLL-style correction)\n    // Domain constants (compute once, use consistently)\n    const float PHASE_DOMAIN = 628.3f;      // 100 * 2 * PI\n    const float HALF_DOMAIN = 314.15f;     // PHASE_DOMAIN / 2\n\n    float speedNorm = ctx.speed / 50.0f;\n    \n    // Tempo lock hysteresis (Schmitt trigger: prevents chatter near threshold)\n    // Note: Reverted from 0.2f \"visibility fix\" - using beatPhase when confidence\n    // is low injects wobble rather than coherence (unreliable reference)\n    if (!ctx.audio.available) {\n        m_tempoLocked = false;  // Clear lock when audio drops (prevents ghost lock)\n    } else {\n        float tempoConf = ctx.audio.tempoConfidence();\n        \n        // Update lock state with hysteresis (0.6 lock / 0.4 unlock)\n        if (tempoConf > 0.6f) m_tempoLocked = true;\n        else if (tempoConf < 0.4f) m_tempoLocked = false;\n    }\n    \n    // Always advance phase (free-run oscillator)\n    m_phase += speedNorm * 240.0f * speedMult * dt;\n    \n    // Apply phase correction when tempo-locked (PLL-style P-only correction)\n    if (ctx.audio.available && m_tempoLocked) {\n        float beatPhase = ctx.audio.beatPhase();\n        float targetPhase = beatPhase * PHASE_DOMAIN;\n        \n        // Compute wrapped error (shortest path to target)\n        float phaseError = targetPhase - m_phase;\n        if (phaseError > HALF_DOMAIN) phaseError -= PHASE_DOMAIN;\n        if (phaseError < -HALF_DOMAIN) phaseError += PHASE_DOMAIN;\n        \n        // Proportional correction (tau ~100ms gives smooth lock)\n        // Compute ONCE per frame, not per pixel\n        const float tau = 0.1f;\n        const float correctionAlpha = 1.0f - expf(-dt / tau);\n        m_phase += phaseError * correctionAlpha;\n    }\n    \n    // CRITICAL: Wrap phase AFTER correction (handles negative and overflow)\n    while (m_phase >= PHASE_DOMAIN) m_phase -= PHASE_DOMAIN;\n    while (m_phase < 0.0f) m_phase += PHASE_DOMAIN;\n\n    // Convert to integer phase for sin8 compatibility\n    uint16_t phaseInt = (uint16_t)(m_phase * 0.408f);  // Scale to 0-256\n\n    // ========================================================================\n    // RENDER LOOP: ORIGINAL V1 ALGORITHM with audio layering\n    // ========================================================================\n    for (uint16_t i = 0; i < STRIP_LENGTH; i++) {\n        // CENTER ORIGIN: distance from center (79/80)\n        uint16_t distFromCenter = centerPairDistance(i);\n\n        // ================================================================\n        // ORIGINAL V1: Periodic structure - bandgap simulation\n        // ================================================================\n        uint8_t cellPosition = distFromCenter % latticeSize;\n        bool inBandgap = cellPosition < (latticeSize >> 1);\n\n        // ================================================================\n        // ORIGINAL V1: Random defects (photonic impurities)\n        // ================================================================\n        if (random8() < defectProbability) {\n            inBandgap = !inBandgap;\n        }\n\n        // ================================================================\n        // ORIGINAL V1: Photonic band structure\n        // ================================================================\n        uint8_t brightness = 0;\n        if (inBandgap) {\n            // Allowed modes - outward from center\n            brightness = sin8((distFromCenter << 2) - (phaseInt >> 7));\n        } else {\n            // Forbidden gap - evanescent decay\n            uint8_t decay = 255 - (cellPosition * 50);\n            brightness = scale8(sin8((distFromCenter << 1) - (phaseInt >> 8)), decay);\n        }\n\n        // ================================================================\n        // AUDIO LAYER: Apply brightness gain with minimum floor\n        // VISIBILITY FIX: Ensure base brightness even with ambient/sparse music\n        // ================================================================\n        float brightnessFloat = (float)brightness * brightnessGain;\n        brightnessFloat = fmaxf(0.2f * 255.0f, brightnessFloat);  // 20% minimum\n        brightness = scale8((uint8_t)fminf(255.0f, brightnessFloat), ctx.brightness);\n\n        // ================================================================\n        // AUDIO LAYER: Collision flash (spatial decay from center)\n        // exp(-dist * 0.12f) creates natural falloff\n        // ================================================================\n#if FEATURE_AUDIO_SYNC\n        if (ctx.audio.available && m_collisionBoost > 0.01f) {\n            float flash = m_collisionBoost * expf(-(float)distFromCenter * 0.12f);\n            brightness = qadd8(brightness, (uint8_t)(flash * 60.0f));\n        }\n#endif\n\n        // ================================================================\n        // ORIGINAL V1: Color based on band structure\n        // Allowed zones get gHue, forbidden zones get gHue + 128\n        // AUDIO LAYER: Add chroma offset for pitch-based color variation\n        // ================================================================\n        uint8_t baseHue = inBandgap ? ctx.gHue : (uint8_t)(ctx.gHue + 128);\n        baseHue += chromaOffset;\n        uint8_t palettePos = baseHue + distFromCenter / 4;\n\n        // Render to both strips (Strip 2 offset by 64 for complementary color)\n        ctx.leds[i] = ctx.palette.getColor(palettePos, brightness);\n        if (i + STRIP_LENGTH < ctx.ledCount) {\n            ctx.leds[i + STRIP_LENGTH] = ctx.palette.getColor(\n                (uint8_t)(palettePos + 64),\n                brightness\n            );\n        }\n    }\n}\n\nvoid LGPPhotonicCrystalEnhancedEffect::cleanup() {\n    // No resources to free\n}\n\nconst plugins::EffectMetadata& LGPPhotonicCrystalEnhancedEffect::getMetadata() const {\n    static plugins::EffectMetadata meta(\n        \"LGP Photonic Crystal Enhanced\",\n        \"Enhanced: heavy_chroma, 64-bin sub-bass, enhanced snare flash, beatPhase sync\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    );\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
