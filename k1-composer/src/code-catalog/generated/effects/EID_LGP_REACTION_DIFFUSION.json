{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_LGP_REACTION_DIFFUSION",
  "effectIdHex": "0x1700",
  "className": "LGPReactionDiffusionEffect",
  "displayName": "LGP Reaction Diffusion",
  "headerPath": "firmware/v2/src/effects/ieffect/LGPReactionDiffusionEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/LGPReactionDiffusionEffect.cpp",
  "renderRange": [
    51,
    126
  ],
  "phaseRanges": {
    "input": [
      [
        51,
        59
      ]
    ],
    "mapping": [
      [
        54,
        54
      ],
      [
        64,
        64
      ],
      [
        67,
        67
      ],
      [
        97,
        97
      ]
    ],
    "modulation": [
      [
        72,
        84
      ]
    ],
    "render": [
      [
        69,
        70
      ],
      [
        91,
        91
      ],
      [
        99,
        99
      ],
      [
        118,
        118
      ],
      [
        121,
        121
      ]
    ],
    "post": [
      [
        117,
        122
      ]
    ],
    "output": [
      [
        70,
        70
      ],
      [
        72,
        72
      ],
      [
        91,
        91
      ],
      [
        98,
        99
      ],
      [
        118,
        119
      ],
      [
        121,
        121
      ]
    ]
  },
  "mappingConfidence": "low",
  "mappingWarnings": [
    "Phase inference used fallback segmentation due to sparse signal.",
    "Phase 'input' inferred from fallback segmentation.",
    "Phase 'modulation' inferred from fallback segmentation.",
    "Phase 'post' inferred from fallback segmentation."
  ],
  "sourceText": "/**\n * @file LGPReactionDiffusionEffect.cpp\n * @brief LGP Reaction Diffusion effect implementation\n */\n\n#include \"LGPReactionDiffusionEffect.h\"\n#include \"../CoreEffects.h\"\n#include \"../../utils/Log.h\"\n#include <FastLED.h>\n#include <cmath>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nstatic inline float clamp01(float x) {\n    return (x < 0.0f) ? 0.0f : (x > 1.0f) ? 1.0f : x;\n}\n\nLGPReactionDiffusionEffect::LGPReactionDiffusionEffect()\n    : m_t(0.0f)\n{\n}\n\nbool LGPReactionDiffusionEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_t = 0.0f;\n\n    // Allocate large buffers in PSRAM (DRAM is too precious)\n    if (!m_ps) {\n        m_ps = static_cast<PsramData*>(heap_caps_malloc(sizeof(PsramData), MALLOC_CAP_SPIRAM));\n        if (!m_ps) {\n            LW_LOGE(\"LGPReactionDiffusionEffect: PSRAM alloc failed (%u bytes)\", (unsigned)sizeof(PsramData));\n            return false;\n        }\n    }\n\n    // Standard init: U=1 everywhere, V=0; seed a small region of V.\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        m_ps->u[i] = 1.0f;\n        m_ps->v[i] = 0.0f;\n    }\n    const int mid = STRIP_LENGTH / 2;\n    for (int i = mid - 6; i <= mid + 6; i++) {\n        if (i >= 0 && i < STRIP_LENGTH) { m_ps->v[i] = 1.0f; m_ps->u[i] = 0.0f; }\n    }\n\n    return true;\n}\n\nvoid LGPReactionDiffusionEffect::render(plugins::EffectContext& ctx) {\n    if (!m_ps) return;\n\n    const float speedNorm = ctx.speed / 50.0f;\n    const float master = ctx.brightness / 255.0f;\n\n    // --- Gray-Scott parameters ---\n    const float Du = 1.0f;\n    const float Dv = 0.5f;\n    const float F = 0.0380f;\n    const float K = 0.0630f;\n\n    // Time step: faster at higher speed, but keep stable.\n    const float dt = 0.9f + 0.6f * speedNorm;\n\n    // Do 1–2 iterations per frame depending on speed (keeps cost bounded).\n    const int iters = (speedNorm > 0.55f) ? 2 : 1;\n\n    for (int iter = 0; iter < iters; iter++) {\n        for (int i = 0; i < STRIP_LENGTH; i++) {\n            const int im1 = (i == 0) ? 0 : (i - 1);\n            const int ip1 = (i == STRIP_LENGTH - 1) ? (STRIP_LENGTH - 1) : (i + 1);\n\n            // 1D Laplacian (simple and stable for this use).\n            const float lapU = m_ps->u[im1] - 2.0f * m_ps->u[i] + m_ps->u[ip1];\n            const float lapV = m_ps->v[im1] - 2.0f * m_ps->v[i] + m_ps->v[ip1];\n\n            const float u = m_ps->u[i];\n            const float v = m_ps->v[i];\n\n            // Gray-Scott reaction term (u*v^2) and feed/kill.\n            const float uvv = u * v * v;\n\n            m_ps->u2[i] = u + (Du * lapU - uvv + F * (1.0f - u)) * dt;\n            m_ps->v2[i] = v + (Dv * lapV + uvv - (K + F) * v) * dt;\n\n            m_ps->u2[i] = clamp01(m_ps->u2[i]);\n            m_ps->v2[i] = clamp01(m_ps->v2[i]);\n        }\n\n        for (int i = 0; i < STRIP_LENGTH; i++) {\n            m_ps->u[i] = m_ps->u2[i];\n            m_ps->v[i] = m_ps->v2[i];\n        }\n    }\n\n    // Render: map V concentration to brightness and hue; add centre “melt glue”.\n    const float mid = (STRIP_LENGTH - 1) * 0.5f;\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        const float x = (float)i;\n        const float dist = (float)centerPairDistance((uint16_t)i);\n\n        const float dmid = x - mid;\n        const float melt = expf(-(dmid * dmid) * 0.0018f);\n\n        const float v = m_ps->v[i];\n        float wave = clamp01(0.15f * melt + 0.85f * (v * melt + 0.25f * v));\n\n        const float base = 0.07f;\n        const float out = clamp01(base + (1.0f - base) * wave) * master;\n        const uint8_t brA = (uint8_t)(255.0f * out);\n\n        const uint8_t hueA = (uint8_t)(ctx.gHue + (int)(dist * 0.6f) + (int)(v * 180.0f));\n\n        const uint8_t hueB = (uint8_t)(hueA + 4u);\n        const uint8_t brB = scale8_video(brA, 245);\n\n        ctx.leds[i] = ctx.palette.getColor(hueA, brA);\n        const int j = i + STRIP_LENGTH;\n        if (j < ctx.ledCount) {\n            ctx.leds[j] = ctx.palette.getColor(hueB, brB);\n        }\n    }\n\n    m_t += 1.0f;\n}\n\nvoid LGPReactionDiffusionEffect::cleanup() {\n    if (m_ps) { heap_caps_free(m_ps); m_ps = nullptr; }\n}\n\nconst plugins::EffectMetadata& LGPReactionDiffusionEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Reaction Diffusion\",\n        \"Gray-Scott 1D slime\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
