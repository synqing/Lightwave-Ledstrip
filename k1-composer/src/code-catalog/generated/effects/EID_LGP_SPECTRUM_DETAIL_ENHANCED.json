{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_LGP_SPECTRUM_DETAIL_ENHANCED",
  "effectIdHex": "0x0E06",
  "className": "LGPSpectrumDetailEnhancedEffect",
  "displayName": "LGP Spectrum Detail Enhanced",
  "headerPath": "firmware/v2/src/effects/ieffect/LGPSpectrumDetailEnhancedEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/LGPSpectrumDetailEnhancedEffect.cpp",
  "renderRange": [
    89,
    533
  ],
  "phaseRanges": {
    "input": [
      [
        102,
        102
      ],
      [
        107,
        107
      ],
      [
        109,
        109
      ],
      [
        117,
        117
      ],
      [
        119,
        119
      ],
      [
        239,
        240
      ],
      [
        244,
        244
      ],
      [
        253,
        253
      ],
      [
        311,
        311
      ]
    ],
    "mapping": [
      [
        106,
        106
      ],
      [
        114,
        114
      ],
      [
        145,
        145
      ],
      [
        148,
        148
      ],
      [
        152,
        152
      ],
      [
        215,
        216
      ],
      [
        219,
        219
      ],
      [
        223,
        224
      ],
      [
        290,
        290
      ],
      [
        304,
        305
      ],
      [
        357,
        358
      ],
      [
        473,
        473
      ]
    ],
    "modulation": [
      [
        122,
        122
      ],
      [
        131,
        131
      ],
      [
        143,
        145
      ],
      [
        149,
        149
      ],
      [
        151,
        152
      ],
      [
        157,
        158
      ],
      [
        163,
        163
      ],
      [
        169,
        172
      ],
      [
        182,
        183
      ],
      [
        186,
        186
      ],
      [
        190,
        191
      ],
      [
        195,
        195
      ],
      [
        201,
        201
      ],
      [
        209,
        211
      ],
      [
        216,
        216
      ],
      [
        218,
        219
      ],
      [
        221,
        221
      ],
      [
        233,
        235
      ],
      [
        243,
        246
      ],
      [
        249,
        249
      ],
      [
        251,
        254
      ],
      [
        257,
        260
      ],
      [
        262,
        262
      ],
      [
        265,
        266
      ],
      [
        272,
        272
      ],
      [
        275,
        275
      ],
      [
        278,
        278
      ],
      [
        280,
        280
      ],
      [
        287,
        287
      ],
      [
        328,
        328
      ],
      [
        334,
        335
      ],
      [
        448,
        448
      ],
      [
        471,
        471
      ]
    ],
    "render": [
      [
        93,
        93
      ],
      [
        123,
        123
      ],
      [
        134,
        134
      ],
      [
        136,
        136
      ],
      [
        147,
        147
      ],
      [
        161,
        161
      ],
      [
        185,
        185
      ],
      [
        214,
        214
      ],
      [
        271,
        271
      ],
      [
        277,
        277
      ],
      [
        286,
        286
      ],
      [
        295,
        295
      ],
      [
        326,
        326
      ],
      [
        333,
        333
      ],
      [
        353,
        353
      ],
      [
        383,
        385
      ],
      [
        388,
        390
      ],
      [
        399,
        401
      ],
      [
        404,
        406
      ],
      [
        415,
        415
      ],
      [
        422,
        424
      ],
      [
        427,
        429
      ],
      [
        447,
        447
      ],
      [
        470,
        470
      ],
      [
        476,
        476
      ],
      [
        484,
        484
      ],
      [
        503,
        503
      ],
      [
        505,
        506
      ],
      [
        522,
        524
      ],
      [
        527,
        529
      ]
    ],
    "post": [
      [
        92,
        93
      ],
      [
        95,
        96
      ],
      [
        301,
        301
      ]
    ],
    "output": [
      [
        383,
        385
      ],
      [
        388,
        390
      ],
      [
        399,
        401
      ],
      [
        404,
        406
      ],
      [
        413,
        413
      ],
      [
        422,
        424
      ],
      [
        427,
        429
      ],
      [
        435,
        436
      ],
      [
        477,
        477
      ],
      [
        503,
        503
      ],
      [
        517,
        517
      ],
      [
        522,
        524
      ],
      [
        527,
        529
      ]
    ]
  },
  "mappingConfidence": "high",
  "mappingWarnings": [],
  "sourceText": "/**\n * @file LGPSpectrumDetailEnhancedEffect.cpp\n * @brief Enhanced 64-bin FFT spectrum visualization matching Sensory Bridge pattern\n * \n * IMPLEMENTATION MATCHES SENSORY BRIDGE get_smooth_spectrogram():\n * - Update targets ONLY on new hops (prevents per-frame noise)\n * - 4-frame history buffer BEFORE smoothing (filters single-frame spikes)\n * - Symmetric 0.75 linear interpolation (simple, NOT asymmetric)\n * - Center-to-edges motion (reversed mapping)\n * - High amplitude gain for full LED range\n */\n\n#include \"LGPSpectrumDetailEnhancedEffect.h\"\n#include \"../CoreEffects.h\"\n#include \"../../config/features.h\"\n\n#ifdef FEATURE_EFFECT_VALIDATION\n#include \"../../validation/EffectValidationMacros.h\"\n#endif\n\n#ifndef NATIVE_BUILD\n#include <FastLED.h>\n#include <Arduino.h>\n#include <esp_heap_caps.h>\n#endif\n\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\n// Enhanced parameters\nconstexpr float AMPLITUDE_GAIN = 4.0f;  // High gain for full LED range\nconstexpr float MIN_THRESHOLD = 0.002f;  // Very low threshold for sensitivity\n// NOTE: SMOOTHING_COEFF removed - using frame-rate independent tau-based smoothing\n\n// PRE_SCALE: Scale colors BEFORE accumulation to prevent overflow\n// Spectrum and trail both add to same LEDs (qadd8); keep sum in range (colour corruption fix).\nconstexpr uint8_t SPECTRUM_PRE_SCALE = 40;   // ~4 bins × 40 + trail ~= 220, stays in range\nconstexpr uint8_t TRAIL_PRE_SCALE = 25;      // Trail overlap; spectrum + trail must not wash to white\nconstexpr uint8_t STRIP2_PRE_SCALE = 60;     // Strip 2 at 66% of Strip 1 (supporting role)\n\nbool LGPSpectrumDetailEnhancedEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n\n    // =========================================================================\n    // PRE-COMPUTE FRAME-RATE INDEPENDENT ALPHA VALUES\n    // Formula: alpha = 1 - exp(-dt/tau)\n    // This ensures identical visual behavior at any frame rate\n    // =========================================================================\n    m_smoothingAlpha = 1.0f - expf(-FRAME_DT / SMOOTHING_TAU);  // ~0.154 @ 120 FPS\n    m_attackAlpha = 1.0f - expf(-FRAME_DT / ATTACK_TAU);        // ~0.341 @ 120 FPS\n    m_releaseAlpha = 1.0f - expf(-FRAME_DT / RELEASE_TAU);      // ~0.027 @ 120 FPS\n    m_decayAlpha = expf(-FRAME_DT / DECAY_TAU);                 // ~0.9958 @ 120 FPS (retention)\n    m_shimmerAlpha = 1.0f - expf(-FRAME_DT / SHIMMER_SMOOTH_TAU); // ~0.080 @ 120 FPS\n\n#ifndef NATIVE_BUILD\n    if (!m_ps) {\n        m_ps = static_cast<SpectrumDetailEnhancedPsram*>(\n            heap_caps_malloc(sizeof(SpectrumDetailEnhancedPsram), MALLOC_CAP_SPIRAM));\n        if (!m_ps) return false;\n    }\n    memset(m_ps, 0, sizeof(SpectrumDetailEnhancedPsram));\n\n    // Initialize history buffer and smoothing arrays\n    for (uint8_t i = 0; i < HISTORY_SIZE; i++) {\n        for (uint8_t bin = 0; bin < 64; bin++) {\n            m_ps->binHistory[i][bin] = 0.0f;\n        }\n    }\n    for (uint8_t bin = 0; bin < 64; bin++) {\n        m_ps->binSmoothing[bin] = 0.0f;\n        m_ps->shimmerAmp[bin] = 0.0f;\n        m_ps->binDistance[bin] = (float)binToLedDistance(bin);\n        m_ps->binMomentum[bin] = 0.0f;\n    }\n#endif\n    m_historyIdx = 0;\n    m_lastHopSeq = 0;\n    m_lastBeatInBar = 255;\n    m_lastBarPhase = 0.0f;\n\n    return true;\n}\n\nvoid LGPSpectrumDetailEnhancedEffect::render(plugins::EffectContext& ctx) {\n    if (!m_ps) return;\n    // Faster LED-level cleanup to prevent saturation buildup between frames\n    // fadeAmount=12 (4.7% per frame) - takes 14 frames to halve instead of 77\n    fadeToBlackBy(ctx.leds, ctx.ledCount, 12);\n\n    // Fade reverse trail buffer - fixed faster rate for consistent decay\n    fadeToBlackBy(m_ps->radialTrail, HALF_LENGTH, 15);\n\n#if !FEATURE_AUDIO_SYNC\n    (void)ctx;\n    return;\n#else\n    if (!ctx.audio.available) {\n        return;\n    }\n\n    // Prefer adaptive normalisation (Sensory Bridge max follower); fall back to raw bins if unavailable.\n    const float* bins64 = ctx.audio.bins64Adaptive();\n    if (!bins64) {\n        bins64 = ctx.audio.bins64();\n    }\n    constexpr uint8_t NUM_BINS = 64;\n    \n    // =========================================================================\n    // Sensory Bridge Pattern: Update targets ONLY on new hops\n    // This prevents per-frame noise and matches Sensory Bridge exactly\n    // =========================================================================\n    bool newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n    if (newHop) {\n        m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n        \n        // Update history buffer ONLY on new hops (when data actually changes)\n        // Sensory Bridge Pattern: History Buffer BEFORE Smoothing (filters spikes)\n        for (uint8_t bin = 0; bin < NUM_BINS; ++bin) {\n            m_ps->binHistory[m_historyIdx][bin] = bins64[bin];\n        }\n        m_historyIdx = (m_historyIdx + 1) % HISTORY_SIZE;\n    }\n    \n    // =========================================================================\n    // Sensory Bridge Pattern: 4-Frame Rolling Average (spike filtering)\n    // Average history buffer BEFORE smoothing to filter single-frame spikes\n    // =========================================================================\n    float avgBins[64] = {0.0f};\n    for (uint8_t bin = 0; bin < NUM_BINS; ++bin) {\n        float sum = 0.0f;\n        for (uint8_t i = 0; i < HISTORY_SIZE; ++i) {\n            sum += m_ps->binHistory[i][bin];\n        }\n        avgBins[bin] = sum / (float)HISTORY_SIZE;\n    }\n    \n    // =========================================================================\n    // FRAME-RATE INDEPENDENT SMOOTHING (tau=50ms)\n    // Uses pre-computed m_smoothingAlpha = 1 - exp(-dt/tau)\n    // At 120 FPS: alpha ~0.154 (reaches 63% of target in 50ms = 6 frames)\n    // =========================================================================\n    for (uint8_t bin = 0; bin < NUM_BINS; ++bin) {\n        float target = avgBins[bin];\n        float current = m_ps->binSmoothing[bin];\n\n        // Frame-rate independent exponential smoothing\n        m_ps->binSmoothing[bin] = current + (target - current) * m_smoothingAlpha;\n    }\n\n    // =========================================================================\n    // FRAME-RATE INDEPENDENT DECAY (tau=2000ms)\n    // Uses pre-computed m_decayAlpha = exp(-dt/tau) for retention\n    // At 120 FPS: alpha ~0.9958 (half-life = ln(2) * tau = ~1.4s)\n    // Creates \"fluid in slow mo\" trails that decay uniformly\n    // =========================================================================\n    for (uint8_t bin = 0; bin < NUM_BINS; ++bin) {\n        // Frame-rate independent uniform decay\n        m_ps->binSmoothing[bin] *= m_decayAlpha;\n    }\n\n    // =========================================================================\n    // MOTION PHYSICS v2: Frame-Rate Independent Energy Coupling\n    //\n    // Philosophy: Energy controls position DIRECTLY with smooth transitions.\n    // Uses pre-computed alpha values for frame-rate independence:\n    // - m_attackAlpha: 20ms tau for fast attack (near-instant response)\n    // - m_releaseAlpha: 300ms tau for slow release (smooth decay)\n    // =========================================================================\n\n    // Motion parameters (frame-rate independent)\n    constexpr float EXPANSION_FACTOR = 12.0f;   // Max LED displacement from energy\n    constexpr float MOMENTUM_FACTOR = 6.0f;     // Additional displacement from momentum\n    constexpr float SILENCE_THRESHOLD = 0.01f;  // Below this = \"silent\"\n    constexpr float MOMENTUM_THRESHOLD = 0.05f; // Below this = allow spring return\n    constexpr float SPRING_RETURN_TAU = 0.200f; // 200ms spring return time constant\n\n    // Pre-compute spring return alpha (could also be done in init())\n    float springReturnAlpha = 1.0f - expf(-FRAME_DT / SPRING_RETURN_TAU);\n\n    for (uint8_t bin = 0; bin < NUM_BINS; ++bin) {\n        float currentEnergy = m_ps->binSmoothing[bin];\n        float staticBase = (float)binToLedDistance(bin);\n\n        // ASYMMETRIC MOMENTUM: Frame-rate independent attack/release\n        float alpha = (currentEnergy > m_ps->binMomentum[bin]) ? m_attackAlpha : m_releaseAlpha;\n        m_ps->binMomentum[bin] += (currentEnergy - m_ps->binMomentum[bin]) * alpha;\n\n        // DIRECT COUPLING: Position = Base + Instant + MomentumTail\n        float directContribution = currentEnergy * EXPANSION_FACTOR;       // INSTANT\n        float momentumContribution = m_ps->binMomentum[bin] * MOMENTUM_FACTOR; // SMOOTH\n\n        float rawPosition = staticBase + directContribution + momentumContribution;\n\n        // SPRING RETURN: Frame-rate independent (only during silence)\n        if (currentEnergy < SILENCE_THRESHOLD && m_ps->binMomentum[bin] < MOMENTUM_THRESHOLD) {\n            rawPosition = rawPosition + (staticBase - rawPosition) * springReturnAlpha;\n        }\n\n        // Clamp to valid LED range\n        m_ps->binDistance[bin] = fmaxf(0.0f, fminf((float)(HALF_LENGTH - 1), rawPosition));\n    }\n\n    // =========================================================================\n    // TREBLE SHIMMER: Frame-rate independent amplitude smoothing\n    // Oscillation amplitude is smoothed to prevent abrupt size changes\n    // Uses m_shimmerAlpha (100ms tau) for smooth amplitude transitions\n    // =========================================================================\n    float time = (float)millis() * 0.001f;  // Time in seconds\n    for (uint8_t bin = 48; bin < 64; ++bin) {  // Treble bins only (highest 16 bins)\n        // Target amplitude based on current energy\n        float targetAmp = (m_ps->binSmoothing[bin] > MIN_THRESHOLD) ? 0.3f * m_ps->binSmoothing[bin] : 0.0f;\n\n        // Smooth the amplitude using frame-rate independent decay\n        m_ps->shimmerAmp[bin] += (targetAmp - m_ps->shimmerAmp[bin]) * m_shimmerAlpha;\n\n        // Apply oscillation with smoothed amplitude\n        if (m_ps->shimmerAmp[bin] > 0.001f) {\n            float freqNorm = (float)(bin - 48) / 16.0f;  // 0.0-1.0 for treble range\n            float oscillationFreq = 4.0f + freqNorm * 8.0f;  // 4-12 Hz\n            m_ps->binDistance[bin] += m_ps->shimmerAmp[bin] * sinf(time * oscillationFreq * 6.28f);\n\n            // Re-clamp after oscillation\n            m_ps->binDistance[bin] = fmaxf(0.0f, fminf((float)(HALF_LENGTH - 1), m_ps->binDistance[bin]));\n        }\n    }\n\n    // =========================================================================\n    // Detect backbeat trigger (beats 2 and 4) with confidence check and fallback\n    // PRIMARY: Use beat_in_bar when tempo confidence is high (musically aligned)\n    // FALLBACK: Use bar_phase01 threshold crossing when confidence is low (consistent rhythm)\n    // =========================================================================\n    bool triggerReverseTrail = false;\n    \n    if (ctx.audio.available) {\n        float tempoConf = ctx.audio.tempoConfidence();\n        \n        if (tempoConf > 0.3f) {\n        // RELIABLE BEAT TRACKING: Use beat_in_bar for musically-aligned triggers\n        uint8_t beatInBar = ctx.audio.musicalGrid.beat_in_bar;\n        // Trigger on beats 2 and 4 (beat_in_bar == 1 or 3)\n        if ((beatInBar == 1 || beatInBar == 3) && beatInBar != m_lastBeatInBar) {\n            triggerReverseTrail = true;\n        }\n        m_lastBeatInBar = beatInBar;\n    } else {\n        // LOW CONFIDENCE FALLBACK: Use bar_phase01 threshold crossing\n        // Triggers when bar phase crosses 0.25 (beat 2) or 0.75 (beat 4)\n        float barPhase = ctx.audio.musicalGrid.bar_phase01;\n        float lastBarPhase = m_lastBarPhase;\n        \n        // Detect threshold crossings (0.0→0.25, 0.24→0.26, 0.49→0.51, 0.74→0.76)\n        bool crossBeat2 = (lastBarPhase < 0.25f && barPhase >= 0.25f) || \n                          (lastBarPhase > 0.75f && barPhase < 0.26f);  // Wrap detection\n        bool crossBeat4 = (lastBarPhase < 0.75f && barPhase >= 0.75f) ||\n                          (lastBarPhase > 0.99f && barPhase < 0.76f);  // Wrap detection\n        \n        if (crossBeat2 || crossBeat4) {\n            triggerReverseTrail = true;\n        }\n        m_lastBarPhase = barPhase;\n        m_lastBeatInBar = 255;  // Reset beat tracking when using fallback\n        }\n    }\n    \n    // =========================================================================\n    // Render reverse trail on trigger (similar to Ripple Enhanced's wave rendering)\n    // ENHANCED: Beat triggers velocity pulse for \"breathing\" expansion effect\n    // =========================================================================\n    if (triggerReverseTrail) {\n        // MOTION ENHANCEMENT v2: Momentum boost on beats 2 & 4\n        // Creates coordinated outward expansion pulse (F1-style throttle burst)\n        for (uint8_t bin = 0; bin < NUM_BINS; ++bin) {\n            if (m_ps->binSmoothing[bin] > MIN_THRESHOLD) {\n                // Boost momentum by 20-50% based on energy (scales with activity)\n                float boostFactor = 0.2f + m_ps->binSmoothing[bin] * 0.3f;\n                m_ps->binMomentum[bin] = fminf(1.0f, m_ps->binMomentum[bin] + boostFactor);\n            }\n        }\n\n        // Render reverse trail: for each active bin, draw trailing wake\n        for (uint8_t bin = 0; bin < NUM_BINS; ++bin) {\n            float magnitude = m_ps->binSmoothing[bin] * AMPLITUDE_GAIN;\n            if (magnitude < MIN_THRESHOLD) continue;\n            \n            // Map bin to LED distance from center\n            uint16_t ledDist = binToLedDistance(bin);\n            \n            // Draw trailing wake: brighter at bin position, fading behind\n            // This creates the \"reverse\" motion as the trail persists while bin moves forward\n            for (int16_t trailOffset = -3; trailOffset <= 3; ++trailOffset) {\n                int16_t trailDist = ledDist + trailOffset;\n                if (trailDist < 0 || trailDist >= HALF_LENGTH) continue;\n                \n                float trailPos = fabsf((float)trailOffset);\n                if (trailPos < 3.0f) {\n                    // Brightness: max at bin position, fades away\n                    // Halved intensity to prevent trail overflow (4 bins × 45 PRE_SCALE = 180)\n                    float trailBrightnessFactor = 0.5f * (1.0f - (trailPos / 3.0f));  // 0.5 at center, 0.0 at edge\n                    float brightnessNorm = (float)ctx.brightness / 255.0f;  // Normalize to 0.0-1.0\n                    float trailBrightFloat = magnitude * brightnessNorm * 255.0f * trailBrightnessFactor;\n                    uint8_t trailBright = (uint8_t)fminf(255.0f, trailBrightFloat);  // Clamp properly\n                    \n                    CRGB color = frequencyToColor(bin, ctx);\n                    color = color.nscale8(trailBright);\n\n                    // PRE_SCALE before accumulation (correct pattern - prevents overflow at source)\n                    color.r = scale8(color.r, TRAIL_PRE_SCALE);\n                    color.g = scale8(color.g, TRAIL_PRE_SCALE);\n                    color.b = scale8(color.b, TRAIL_PRE_SCALE);\n\n                    // Additive blending into radial buffer with qadd8() overflow protection\n                    m_ps->radialTrail[trailDist].r = qadd8(m_ps->radialTrail[trailDist].r, color.r);\n                    m_ps->radialTrail[trailDist].g = qadd8(m_ps->radialTrail[trailDist].g, color.g);\n                    m_ps->radialTrail[trailDist].b = qadd8(m_ps->radialTrail[trailDist].b, color.b);\n                }\n            }\n        }\n    }\n    \n    // =========================================================================\n    // SUBPIXEL RENDERING: Anti-aliased LED positioning\n    // Instead of truncating to integer positions, distribute color between\n    // adjacent LEDs based on fractional position for smooth motion\n    // =========================================================================\n\n    uint16_t centerLED = ctx.centerPoint;\n\n    for (uint8_t bin = 0; bin < NUM_BINS; ++bin) {\n        // Apply amplitude gain to smoothed magnitude\n        float magnitude = m_ps->binSmoothing[bin] * AMPLITUDE_GAIN;\n\n        // VISIBILITY FIX: Apply 2x gain boost to bass bins (0-15) for better visibility\n        if (bin < 16) {\n            magnitude *= 2.0f;\n        }\n\n        // Skip if below threshold\n        if (magnitude < MIN_THRESHOLD) {\n            continue;\n        }\n\n        // SUBPIXEL: Keep fractional position for anti-aliasing\n        float ledDistFloat = m_ps->binDistance[bin];\n        uint16_t ledDistLow = (uint16_t)ledDistFloat;\n        uint16_t ledDistHigh = ledDistLow + 1;\n        float frac = ledDistFloat - (float)ledDistLow;  // 0.0-1.0 fractional part\n\n        // Get color for this frequency band (using palette system)\n        CRGB color = frequencyToColor(bin, ctx);\n\n        // Brightness from magnitude (already includes AMPLITUDE_GAIN)\n        float brightnessNorm = (float)ctx.brightness / 255.0f;\n        float brightFloat = magnitude * brightnessNorm * 255.0f;\n        uint8_t bright = (uint8_t)fminf(255.0f, brightFloat);\n        color = color.nscale8(bright);\n\n        // PRE_SCALE before accumulation\n        color.r = scale8(color.r, SPECTRUM_PRE_SCALE);\n        color.g = scale8(color.g, SPECTRUM_PRE_SCALE);\n        color.b = scale8(color.b, SPECTRUM_PRE_SCALE);\n\n        // SUBPIXEL: Distribute color based on fractional position\n        // Low LED gets (1-frac) brightness, High LED gets (frac) brightness\n        uint8_t lowScale = (uint8_t)((1.0f - frac) * 255.0f);\n        uint8_t highScale = (uint8_t)(frac * 255.0f);\n\n        CRGB colorLow = color;\n        colorLow.nscale8(lowScale);\n\n        CRGB colorHigh = color;\n        colorHigh.nscale8(highScale);\n\n        // Apply LOW position (primary LED)\n        uint16_t leftIdxLow = centerLED - 1 - ledDistLow;\n        uint16_t rightIdxLow = centerLED + ledDistLow;\n\n        if (leftIdxLow < ctx.ledCount) {\n            ctx.leds[leftIdxLow].r = qadd8(ctx.leds[leftIdxLow].r, colorLow.r);\n            ctx.leds[leftIdxLow].g = qadd8(ctx.leds[leftIdxLow].g, colorLow.g);\n            ctx.leds[leftIdxLow].b = qadd8(ctx.leds[leftIdxLow].b, colorLow.b);\n        }\n        if (rightIdxLow < ctx.ledCount) {\n            ctx.leds[rightIdxLow].r = qadd8(ctx.leds[rightIdxLow].r, colorLow.r);\n            ctx.leds[rightIdxLow].g = qadd8(ctx.leds[rightIdxLow].g, colorLow.g);\n            ctx.leds[rightIdxLow].b = qadd8(ctx.leds[rightIdxLow].b, colorLow.b);\n        }\n\n        // Apply HIGH position (anti-aliased adjacent LED) if within bounds\n        if (ledDistHigh < HALF_LENGTH) {\n            uint16_t leftIdxHigh = centerLED - 1 - ledDistHigh;\n            uint16_t rightIdxHigh = centerLED + ledDistHigh;\n\n            if (leftIdxHigh < ctx.ledCount) {\n                ctx.leds[leftIdxHigh].r = qadd8(ctx.leds[leftIdxHigh].r, colorHigh.r);\n                ctx.leds[leftIdxHigh].g = qadd8(ctx.leds[leftIdxHigh].g, colorHigh.g);\n                ctx.leds[leftIdxHigh].b = qadd8(ctx.leds[leftIdxHigh].b, colorHigh.b);\n            }\n            if (rightIdxHigh < ctx.ledCount) {\n                ctx.leds[rightIdxHigh].r = qadd8(ctx.leds[rightIdxHigh].r, colorHigh.r);\n                ctx.leds[rightIdxHigh].g = qadd8(ctx.leds[rightIdxHigh].g, colorHigh.g);\n                ctx.leds[rightIdxHigh].b = qadd8(ctx.leds[rightIdxHigh].b, colorHigh.b);\n            }\n        }\n    }\n    \n    // =========================================================================\n    // Blend reverse trail into main LED buffer (creates trailing wake effect)\n    // STRIP 1 ONLY (like original) - qadd8() prevents overflow\n    // =========================================================================\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        if (m_ps->radialTrail[dist].r > 0 || m_ps->radialTrail[dist].g > 0 || m_ps->radialTrail[dist].b > 0) {\n            uint16_t centerLED = ctx.centerPoint;\n            uint16_t leftIdx = centerLED - 1 - dist;\n            uint16_t rightIdx = centerLED + dist;\n            \n            if (leftIdx < ctx.ledCount) {\n                ctx.leds[leftIdx].r = qadd8(ctx.leds[leftIdx].r, m_ps->radialTrail[dist].r);\n                ctx.leds[leftIdx].g = qadd8(ctx.leds[leftIdx].g, m_ps->radialTrail[dist].g);\n                ctx.leds[leftIdx].b = qadd8(ctx.leds[leftIdx].b, m_ps->radialTrail[dist].b);\n            }\n            if (rightIdx < ctx.ledCount) {\n                ctx.leds[rightIdx].r = qadd8(ctx.leds[rightIdx].r, m_ps->radialTrail[dist].r);\n                ctx.leds[rightIdx].g = qadd8(ctx.leds[rightIdx].g, m_ps->radialTrail[dist].g);\n                ctx.leds[rightIdx].b = qadd8(ctx.leds[rightIdx].b, m_ps->radialTrail[dist].b);\n            }\n        }\n    }\n\n    // =========================================================================\n    // STRIP 2: GAP DETECTION VIA BOOLEAN MASK\n    // Mark LED positions where Strip 1 rendered bins (with magnitude threshold)\n    // Gaps are positions NOT in the mask\n    // =========================================================================\n    constexpr float SIGNIFICANT_MAGNITUDE = 0.05f;  // Only count bins with real energy\n    constexpr float MAX_GAP_BRIGHTNESS = 0.7f;\n    constexpr uint8_t GAP_PRE_SCALE = 80;\n\n    // Step 1: Create mask of where bins are rendered\n    bool hasBin[HALF_LENGTH] = {false};\n    float binMagnitudeAt[HALF_LENGTH] = {0.0f};  // Track magnitude at each position\n\n    for (uint8_t bin = 0; bin < NUM_BINS; ++bin) {\n        float magnitude = m_ps->binSmoothing[bin];\n        if (magnitude < SIGNIFICANT_MAGNITUDE) continue;  // Only significant bins\n\n        uint16_t pos = (uint16_t)m_ps->binDistance[bin];\n        if (pos >= HALF_LENGTH) continue;\n\n        // Mark this position and immediate neighbors as \"has bin\"\n        hasBin[pos] = true;\n        binMagnitudeAt[pos] = fmaxf(binMagnitudeAt[pos], magnitude);\n\n        if (pos > 0) {\n            hasBin[pos - 1] = true;\n            binMagnitudeAt[pos - 1] = fmaxf(binMagnitudeAt[pos - 1], magnitude * 0.5f);\n        }\n        if (pos < HALF_LENGTH - 1) {\n            hasBin[pos + 1] = true;\n            binMagnitudeAt[pos + 1] = fmaxf(binMagnitudeAt[pos + 1], magnitude * 0.5f);\n        }\n    }\n\n    // Step 2: Compute total audio energy for gap brightness scaling\n    float totalEnergy = 0.0f;\n    for (uint8_t bin = 0; bin < NUM_BINS; ++bin) {\n        totalEnergy += m_ps->binSmoothing[bin];\n    }\n    totalEnergy = fminf(1.0f, totalEnergy / 8.0f);  // Normalize\n\n    // Step 3: Render gaps (positions where hasBin is false)\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        if (hasBin[dist]) continue;  // Skip - Strip 1 renders here\n\n        // THIS IS A GAP - render fill\n\n        // Find nearest bin for color (search outward)\n        uint8_t colorBin = 32;  // Default\n        float nearestMag = 0.0f;\n        for (int16_t offset = 1; offset < 20; ++offset) {\n            if (dist >= (uint16_t)offset && hasBin[dist - offset]) {\n                colorBin = (uint8_t)((dist - offset) * 64 / HALF_LENGTH);  // Approximate bin\n                nearestMag = binMagnitudeAt[dist - offset];\n                break;\n            }\n            if (dist + offset < HALF_LENGTH && hasBin[dist + offset]) {\n                colorBin = (uint8_t)((dist + offset) * 64 / HALF_LENGTH);  // Approximate bin\n                nearestMag = binMagnitudeAt[dist + offset];\n                break;\n            }\n        }\n\n        // Gap brightness: based on total energy and nearby magnitude\n        float gapBright = totalEnergy * MAX_GAP_BRIGHTNESS;\n        if (nearestMag > 0.0f) {\n            gapBright = fmaxf(gapBright, nearestMag * MAX_GAP_BRIGHTNESS);\n        }\n\n        // COLOR: Use distance-based palette index (varies across strip)\n        // This ensures different gaps get different colors\n        uint8_t paletteIdx = (uint8_t)(ctx.gHue + (dist * 255 / HALF_LENGTH));\n        CRGB color = ctx.palette.getColor(paletteIdx, 255);\n\n        // Apply brightness\n        uint8_t bright = (uint8_t)(gapBright * (float)ctx.brightness);\n        color = color.nscale8(bright);\n\n        // PRE_SCALE\n        color.r = scale8(color.r, GAP_PRE_SCALE);\n        color.g = scale8(color.g, GAP_PRE_SCALE);\n        color.b = scale8(color.b, GAP_PRE_SCALE);\n\n        // Apply to Strip 2 (CENTER ORIGIN)\n        uint16_t leftIdx2 = 239 - dist;\n        uint16_t rightIdx2 = 240 + dist;\n\n        if (leftIdx2 >= 160 && leftIdx2 < ctx.ledCount) {\n            ctx.leds[leftIdx2].r = qadd8(ctx.leds[leftIdx2].r, color.r);\n            ctx.leds[leftIdx2].g = qadd8(ctx.leds[leftIdx2].g, color.g);\n            ctx.leds[leftIdx2].b = qadd8(ctx.leds[leftIdx2].b, color.b);\n        }\n        if (rightIdx2 >= 160 && rightIdx2 < ctx.ledCount) {\n            ctx.leds[rightIdx2].r = qadd8(ctx.leds[rightIdx2].r, color.r);\n            ctx.leds[rightIdx2].g = qadd8(ctx.leds[rightIdx2].g, color.g);\n            ctx.leds[rightIdx2].b = qadd8(ctx.leds[rightIdx2].b, color.b);\n        }\n    }\n#endif  // FEATURE_AUDIO_SYNC\n}\n\nuint16_t LGPSpectrumDetailEnhancedEffect::binToLedDistance(uint8_t bin) const {\n    // REVERSED: High frequencies at center, low frequencies at edges\n    // bin 63 (treble) -> distance 0 (center)\n    // bin 0 (bass) -> distance 80 (edge)\n    // This creates center-to-edges visual flow\n    \n    if (bin == 63) {\n        return 0;  // Treble at center\n    }\n    \n    // Calculate normalized position (0.0 = bin 0, 1.0 = bin 63)\n    float logPos = log10f((float)(bin + 1) / 64.0f);\n    float normalized = (logPos + 1.806f) / 1.806f;\n    normalized = fmaxf(0.0f, fminf(1.0f, normalized));\n    \n    // REVERSE: invert normalized (1.0 - normalized)\n    // Now: bin 0 → normalized=0 → reversed=1.0 → distance=80\n    //      bin 63 → normalized=1.0 → reversed=0.0 → distance=0\n    float reversed = 1.0f - normalized;\n    uint16_t distance = (uint16_t)(reversed * (float)HALF_LENGTH);\n    \n    return distance;\n}\n\nCRGB LGPSpectrumDetailEnhancedEffect::frequencyToColor(uint8_t bin, const plugins::EffectContext& ctx) const {\n    // Map bin to FULL palette range (0-255) with gHue offset for animation\n    // bin 0 → 0, bin 63 → 255 (covers entire palette)\n    float prog = (float)bin / 63.0f;  // 0.0 to 1.0\n    uint8_t paletteIdx = (uint8_t)(prog * 255.0f) + ctx.gHue;\n    return ctx.palette.getColor(paletteIdx, 255);  // Full brightness - scaled later in render\n}\n\nvoid LGPSpectrumDetailEnhancedEffect::cleanup() {\n#ifndef NATIVE_BUILD\n    if (m_ps) {\n        heap_caps_free(m_ps);\n        m_ps = nullptr;\n    }\n#endif\n}\n\nconst plugins::EffectMetadata& LGPSpectrumDetailEnhancedEffect::getMetadata() const {\n    static plugins::EffectMetadata meta(\n        \"LGP Spectrum Detail Enhanced\",\n        \"Enhanced: Sensory Bridge pattern - 4-frame history, symmetric 0.75 smoothing\",\n        plugins::EffectCategory::PARTY,\n        1\n    );\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
