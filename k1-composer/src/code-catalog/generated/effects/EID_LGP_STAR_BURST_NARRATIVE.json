{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_LGP_STAR_BURST_NARRATIVE",
  "effectIdHex": "0x0A06",
  "className": "LGPStarBurstNarrativeEffect",
  "displayName": "LGP Star Burst (Narrative)",
  "headerPath": "firmware/v2/src/effects/ieffect/LGPStarBurstNarrativeEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/LGPStarBurstNarrativeEffect.cpp",
  "renderRange": [
    82,
    376
  ],
  "phaseRanges": {
    "input": [
      [
        92,
        92
      ],
      [
        97,
        97
      ],
      [
        99,
        99
      ],
      [
        102,
        102
      ],
      [
        115,
        117
      ],
      [
        125,
        125
      ],
      [
        132,
        132
      ],
      [
        142,
        142
      ],
      [
        150,
        150
      ],
      [
        171,
        171
      ]
    ],
    "mapping": [
      [
        84,
        85
      ],
      [
        101,
        101
      ],
      [
        251,
        251
      ],
      [
        254,
        254
      ],
      [
        263,
        263
      ],
      [
        265,
        265
      ],
      [
        302,
        302
      ],
      [
        307,
        307
      ],
      [
        311,
        311
      ],
      [
        334,
        334
      ],
      [
        338,
        338
      ]
    ],
    "modulation": [
      [
        125,
        125
      ],
      [
        135,
        136
      ],
      [
        141,
        142
      ],
      [
        145,
        145
      ],
      [
        152,
        154
      ],
      [
        156,
        157
      ],
      [
        162,
        162
      ],
      [
        175,
        175
      ],
      [
        184,
        185
      ],
      [
        192,
        192
      ],
      [
        197,
        197
      ],
      [
        199,
        199
      ],
      [
        201,
        202
      ],
      [
        207,
        207
      ],
      [
        209,
        210
      ],
      [
        215,
        215
      ],
      [
        218,
        218
      ],
      [
        221,
        221
      ],
      [
        232,
        233
      ],
      [
        236,
        237
      ],
      [
        239,
        239
      ],
      [
        242,
        243
      ],
      [
        250,
        250
      ],
      [
        254,
        254
      ],
      [
        258,
        259
      ],
      [
        264,
        267
      ],
      [
        269,
        271
      ],
      [
        295,
        295
      ],
      [
        303,
        304
      ],
      [
        308,
        308
      ],
      [
        319,
        319
      ],
      [
        323,
        323
      ],
      [
        325,
        325
      ]
    ],
    "render": [
      [
        106,
        106
      ],
      [
        278,
        278
      ],
      [
        300,
        300
      ],
      [
        336,
        336
      ],
      [
        354,
        356
      ],
      [
        359,
        359
      ],
      [
        362,
        362
      ],
      [
        366,
        368
      ],
      [
        371,
        371
      ],
      [
        373,
        373
      ]
    ],
    "post": [
      [
        278,
        278
      ],
      [
        316,
        317
      ]
    ],
    "output": [
      [
        297,
        298
      ],
      [
        362,
        363
      ],
      [
        373,
        373
      ]
    ]
  },
  "mappingConfidence": "medium",
  "mappingWarnings": [],
  "sourceText": "/**\n * @file LGPStarBurstNarrativeEffect.cpp\n * @brief LGP Star Burst (Narrative) - legacy starburst core with phrase-gated harmonic commits\n */\n\n#include \"LGPStarBurstNarrativeEffect.h\"\n\n#include \"../CoreEffects.h\"\n#include \"../../config/features.h\"\n\n#include <FastLED.h>\n#include <cmath>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nnamespace {\n\nstatic inline float clamp01(float x) {\n    if (x < 0.0f) return 0.0f;\n    if (x > 1.0f) return 1.0f;\n    return x;\n}\n\nstatic inline uint8_t clampU8(int v) {\n    if (v < 0) return 0;\n    if (v > 255) return 255;\n    return static_cast<uint8_t>(v);\n}\n\nstatic inline float smoothstep01(float x) {\n    float t = clamp01(x);\n    return t * t * (3.0f - 2.0f * t);\n}\n\nstatic inline float smoothstepDur(float t, float durationS) {\n    if (durationS <= 0.0f) return 1.0f;\n    return smoothstep01(t / durationS);\n}\n\nstatic inline float expAlpha(float dt, float tauS) {\n    if (tauS <= 0.0f) return 1.0f;\n    return 1.0f - expf(-dt / tauS);\n}\n\n} // namespace\n\nLGPStarBurstNarrativeEffect::LGPStarBurstNarrativeEffect()\n    : m_phase(0.0f) {\n}\n\nbool LGPStarBurstNarrativeEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n\n    m_storyPhase = StoryPhase::REST;\n    m_storyTimeS = 0.0f;\n    m_quietTimeS = 0.0f;\n    m_phraseHoldS = 2.0f;\n\n    m_phase = 0.0f;\n    m_burst = 0.0f;\n    m_lastHopSeq = 0;\n\n    m_candidateRootBin = 0;\n    m_candidateMinor = false;\n    m_keyRootBin = 0;\n    m_keyMinor = false;\n    m_dominantBin = 0;\n    m_keyRootAngle = 0.0f;\n\n    m_phaseSpeedSpring.init(50.0f, 1.0f);\n    m_phaseSpeedSpring.reset(1.0f);\n\n    m_heavyBassSmooth = 0.0f;\n    m_heavyBassSmoothInitialised = false;\n    m_kickEnv = 0.0f;\n\n    return true;\n}\n\nvoid LGPStarBurstNarrativeEffect::render(plugins::EffectContext& ctx) {\n    const float userSpeed = clamp01((ctx.speed - 1) / 99.0f);\n    const float userMood  = ctx.getMoodNormalized();\n    const float intensityNorm = ctx.brightness / 255.0f;\n    const float dtAudio = ctx.getSafeRawDeltaSeconds();\n    float dtVisual = ctx.getSafeDeltaSeconds();\n    if (dtVisual > 0.1f) dtVisual = 0.1f;\n\n    bool hasAudio = false;\n#if FEATURE_AUDIO_SYNC\n    hasAudio = ctx.audio.available;\n#endif\n\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        const bool newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n        if (newHop) {\n            m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n\n            // Both backends now produce normalised chroma via Stage A/B pipeline.\n            const float* chroma = ctx.audio.controlBus.chroma;\n\n            float maxBin = 0.0f;\n            uint8_t dominant = 0;\n            for (uint8_t i = 0; i < 12; ++i) {\n                const float v = chroma ? chroma[i] : 0.0f;\n                if (v > maxBin) {\n                    maxBin = v;\n                    dominant = i;\n                }\n            }\n            m_dominantBin = dominant;\n\n            if (ctx.audio.chordConfidence() >= 0.45f) {\n                m_candidateRootBin = ctx.audio.rootNote();\n                m_candidateMinor = ctx.audio.isMinor();\n            } else {\n                m_candidateRootBin = dominant;\n                m_candidateMinor = m_keyMinor;\n            }\n\n            // Phrase-gated key commit keeps colour stable instead of hopping every frame.\n            if (m_phraseHoldS > 1.5f &&\n                (ctx.audio.chordConfidence() >= 0.55f || m_storyPhase == StoryPhase::REST)) {\n                m_keyRootBin = m_candidateRootBin;\n                m_keyMinor = m_candidateMinor;\n                m_phraseHoldS = 0.0f;\n            }\n        }\n\n        if (ctx.audio.isSnareHit()) {\n            const float burstCeiling = 0.35f + 0.40f * userMood;\n            m_burst = fmaxf(m_burst, burstCeiling);\n            if (m_storyPhase == StoryPhase::REST) {\n                m_storyPhase = StoryPhase::BUILD;\n                m_storyTimeS = 0.0f;\n            }\n        }\n\n        // Kick envelope from beat events\n        if (ctx.audio.isOnBeat()) {\n            const float kickCeiling = 0.50f + 0.35f * userMood;\n            m_kickEnv = fmaxf(m_kickEnv, kickCeiling);\n            m_phaseSpeedSpring.velocity += 0.8f + 1.2f * userSpeed;\n        }\n        const float kickReleaseTau = 0.20f - 0.08f * userMood;\n        m_kickEnv *= expf(-dtAudio / kickReleaseTau);\n\n        const float heavyRaw = clamp01(ctx.audio.heavyBass());\n        const float tauHeavy = 0.12f - 0.07f * userMood;\n        if (!m_heavyBassSmoothInitialised) {\n            m_heavyBassSmooth = heavyRaw;\n            m_heavyBassSmoothInitialised = true;\n        } else {\n            const float heavyAlpha = expAlpha(dtAudio, tauHeavy);\n            m_heavyBassSmooth += (heavyRaw - m_heavyBassSmooth) * heavyAlpha;\n        }\n    } else\n#endif\n    {\n        m_heavyBassSmooth *= expf(-dtAudio / 0.25f);\n    }\n\n    m_storyTimeS += dtAudio;\n    m_phraseHoldS += dtAudio;\n\n    float rmsNow = 0.0f;\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        rmsNow = clamp01(ctx.audio.rms());\n    }\n#endif\n\n    const bool energyQuiet = (rmsNow < 0.06f) && (m_heavyBassSmooth < 0.08f) && (m_burst < 0.06f);\n    const bool noRecentKick = (m_kickEnv < 0.05f);\n    const bool quietNow = (!hasAudio) || (energyQuiet && noRecentKick);\n    if (quietNow) {\n        m_quietTimeS += dtAudio;\n    } else {\n        m_quietTimeS = 0.0f;\n    }\n\n    switch (m_storyPhase) {\n        case StoryPhase::REST:\n            if (!quietNow && m_phraseHoldS > 0.65f) {\n                if (m_phraseHoldS > 1.5f) {\n                    m_keyRootBin = m_candidateRootBin;\n                    m_keyMinor = m_candidateMinor;\n                    m_phraseHoldS = 0.0f;\n                }\n                m_storyPhase = StoryPhase::BUILD;\n                m_storyTimeS = 0.0f;\n            }\n            break;\n\n        case StoryPhase::BUILD:\n            if (m_quietTimeS > (0.80f + 0.40f * userMood)) {\n                m_storyPhase = StoryPhase::REST;\n                m_storyTimeS = 0.0f;\n            } else if (m_storyTimeS > 0.90f && m_heavyBassSmooth > 0.14f) {\n                m_storyPhase = StoryPhase::HOLD;\n                m_storyTimeS = 0.0f;\n            }\n            break;\n\n        case StoryPhase::HOLD:\n            if (m_quietTimeS > (0.90f + 0.50f * userMood) ||\n                (m_storyTimeS > 2.40f && m_heavyBassSmooth < 0.10f)) {\n                m_storyPhase = StoryPhase::RELEASE;\n                m_storyTimeS = 0.0f;\n            }\n            break;\n\n        case StoryPhase::RELEASE: {\n            const float releaseDurS = 1.40f - 0.85f * userMood;\n            if (m_quietTimeS > (1.10f + 0.40f * userMood) || m_storyTimeS > releaseDurS) {\n                m_storyPhase = StoryPhase::REST;\n                m_storyTimeS = 0.0f;\n            } else if (!quietNow && m_storyTimeS > 0.70f) {\n                m_storyPhase = StoryPhase::BUILD;\n                m_storyTimeS = 0.0f;\n            }\n            break;\n        }\n    }\n\n    const float buildDurS   = 1.20f - 0.75f * userMood;\n    const float releaseDurEnvS = 1.40f - 0.85f * userMood;\n\n    float env = 0.0f;\n    switch (m_storyPhase) {\n        case StoryPhase::REST:\n            env = 0.0f;\n            break;\n        case StoryPhase::BUILD:\n            env = smoothstepDur(m_storyTimeS, buildDurS);\n            break;\n        case StoryPhase::HOLD:\n            env = 1.0f;\n            break;\n        case StoryPhase::RELEASE:\n            env = 1.0f - smoothstepDur(m_storyTimeS, releaseDurEnvS);\n            break;\n    }\n    env = clamp01(env);\n\n    // Circular EMA for key root bin (eliminates rainbow sweep at bin 11->0 boundary)\n    {\n        const float keyAlpha = expAlpha(dtAudio, 0.35f);\n        const float targetAngle = static_cast<float>(m_keyRootBin) *\n            (effects::chroma::TWO_PI_F / 12.0f);\n        m_keyRootAngle = effects::chroma::circularEma(\n            targetAngle, m_keyRootAngle, keyAlpha);\n    }\n\n    // Mood-controlled spring dynamics\n    m_phaseSpeedSpring.stiffness = 35.0f + 65.0f * userMood;\n    m_phaseSpeedSpring.damping = 2.0f * sqrtf(m_phaseSpeedSpring.stiffness * m_phaseSpeedSpring.mass);\n\n    const float minSpeed = 0.25f + 0.55f * userSpeed;\n    const float maxSpeed = 1.25f + 1.95f * userSpeed;\n    const float targetSpeed = (0.55f + 0.95f * userSpeed)\n                            + (0.30f + 1.50f * userSpeed) * m_heavyBassSmooth;\n    float smoothedSpeed = m_phaseSpeedSpring.update(targetSpeed, dtAudio);\n    if (smoothedSpeed > maxSpeed) smoothedSpeed = maxSpeed;\n    if (smoothedSpeed < minSpeed) smoothedSpeed = minSpeed;\n\n    m_phase += (0.40f + 1.80f * userSpeed) * smoothedSpeed * dtVisual;\n    if (m_phase > 100000.0f) {\n        m_phase = fmodf(m_phase, 6.2831853f);\n    }\n\n    // Mood-controlled burst decay (no BUILD accumulation, no separate REST decay)\n    const float burstDecayTau = 0.26f - 0.10f * userMood;\n    m_burst *= expf(-dtAudio / burstDecayTau);\n\n    fadeToBlackBy(ctx.leds, ctx.ledCount, ctx.fadeAmount);\n\n    const uint8_t binStep = static_cast<uint8_t>(255.0f / 12.0f);\n    // Derive integer root bin from circular angle (avoids wrap-around artefacts)\n    const uint8_t rootBin = static_cast<uint8_t>(\n        roundf(m_keyRootAngle * (12.0f / effects::chroma::TWO_PI_F))) % 12;\n    const uint8_t thirdBin = static_cast<uint8_t>((rootBin + (m_keyMinor ? 3 : 4)) % 12);\n    const uint8_t fifthBin = static_cast<uint8_t>((rootBin + 7) % 12);\n\n    const uint8_t hueRoot = static_cast<uint8_t>(ctx.gHue + rootBin * binStep);\n    const uint8_t hueThird = static_cast<uint8_t>(ctx.gHue + thirdBin * binStep);\n    const uint8_t hueFifth = static_cast<uint8_t>(ctx.gHue + fifthBin * binStep);\n\n    const float freqBase = 0.18f + 0.30f * env;\n    const float falloff = (3.6f - 1.2f * userMood) - (1.6f - 0.4f * userMood) * env;\n    const float pulseRate = (0.6f + 0.6f * userSpeed) + (1.8f + 0.8f * userSpeed) * env;\n    const uint8_t motionIdx =\n        static_cast<uint8_t>((static_cast<uint32_t>(m_phase * 40.58f)) & 0xFFu);\n\n    const int maxLeds = (ctx.ledCount < STRIP_LENGTH) ? static_cast<int>(ctx.ledCount)\n                                                       : static_cast<int>(STRIP_LENGTH);\n\n    for (int i = 0; i < maxLeds; ++i) {\n        const float distFromCentre = static_cast<float>(centerPairDistance(static_cast<uint16_t>(i)));\n        const float normalisedDist = distFromCentre / static_cast<float>(HALF_LENGTH);\n        const float ray1 = sinf(distFromCentre * freqBase - m_phase);\n        const float ray2 = 0.35f * env * sinf(distFromCentre * (freqBase * 2.0f) - (m_phase * 1.3f));\n\n        float field = 0.5f + 0.5f * (ray1 + ray2);\n        field *= expf(-normalisedDist * falloff);\n        field *= 0.35f + 0.65f * (0.5f + 0.5f * sinf(m_phase * pulseRate));\n\n        if (env > 0.02f) {\n            field += m_burst * env * expf(-normalisedDist * (falloff + 0.6f));\n        }\n        field = clamp01(field);\n\n        // Controllable contrast curve (replaces harsh squaring)\n        const float gamma = 2.2f - 0.8f * userMood;\n        field = powf(field, gamma);\n\n        // Kick-locked amplitude modulation\n        field *= (0.70f + 0.30f * m_kickEnv);\n\n        float brightF = field;\n        if (m_storyPhase == StoryPhase::REST) {\n            brightF *= 0.20f;\n        } else if (m_storyPhase == StoryPhase::BUILD) {\n            brightF *= (0.35f + 0.65f * env);\n        }\n\n        // Soft limiter (prevents flash/white-out)\n        brightF = brightF / (brightF + 0.15f) * 1.15f;\n        brightF = clamp01(brightF);\n\n        const uint8_t brightness =\n            clampU8(static_cast<int>(roundf(brightF * intensityNorm * 255.0f)));\n        const int baseIdx = static_cast<int>(distFromCentre * 2.0f) + static_cast<int>(motionIdx);\n        const uint8_t paletteIndex = clampU8(baseIdx);\n\n        const float t = clamp01(normalisedDist);\n        float wRoot = clamp01(1.15f - 1.65f * t);\n        float wFifth = clamp01(0.35f + 0.95f * t);\n        float wThird = env * clamp01(1.0f - fabsf(t - 0.35f) * 3.0f);\n        const float weightSum = wRoot + wThird + wFifth;\n        if (weightSum > 0.0001f) {\n            wRoot /= weightSum;\n            wThird /= weightSum;\n            wFifth /= weightSum;\n        }\n\n        const uint8_t bRoot = clampU8(static_cast<int>(roundf(brightness * wRoot)));\n        const uint8_t bThird = clampU8(static_cast<int>(roundf(brightness * wThird)));\n        const uint8_t bFifth = clampU8(static_cast<int>(roundf(brightness * wFifth)));\n\n        CRGB c = CRGB::Black;\n        if (bRoot) c += ctx.palette.getColor(static_cast<uint8_t>(hueRoot + paletteIndex), bRoot);\n        if (bThird) c += ctx.palette.getColor(static_cast<uint8_t>(hueThird + paletteIndex), bThird);\n        if (bFifth) c += ctx.palette.getColor(static_cast<uint8_t>(hueFifth + paletteIndex), bFifth);\n        if (m_burst > 0.20f && env > 0.25f) {\n            const uint8_t accentB = clampU8(static_cast<int>(roundf(brightness * m_burst * 0.55f)));\n            c += ctx.palette.getColor(static_cast<uint8_t>(hueRoot + 128 + paletteIndex), accentB);\n        }\n\n        ctx.leds[i] += c;\n        if (i + STRIP_LENGTH < ctx.ledCount) {\n            const uint8_t harmonyShift = 85;\n            CRGB c2 = CRGB::Black;\n            if (bRoot) c2 += ctx.palette.getColor(static_cast<uint8_t>(hueRoot + harmonyShift + paletteIndex), bRoot);\n            if (bThird) c2 += ctx.palette.getColor(static_cast<uint8_t>(hueThird + harmonyShift + paletteIndex), bThird);\n            if (bFifth) c2 += ctx.palette.getColor(static_cast<uint8_t>(hueFifth + harmonyShift + paletteIndex), bFifth);\n            if (m_burst > 0.20f && env > 0.25f) {\n                const uint8_t accentB = clampU8(static_cast<int>(roundf(brightness * m_burst * 0.55f)));\n                c2 += ctx.palette.getColor(static_cast<uint8_t>(hueRoot + harmonyShift + 128 + paletteIndex), accentB);\n            }\n            ctx.leds[i + STRIP_LENGTH] += c2;\n        }\n    }\n}\n\nvoid LGPStarBurstNarrativeEffect::cleanup() {\n    // No resources to free.\n}\n\nconst plugins::EffectMetadata& LGPStarBurstNarrativeEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Star Burst (Narrative)\",\n        \"Legacy starburst core with phrase-gated harmonic commits\",\n        plugins::EffectCategory::GEOMETRIC,\n        1\n    };\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
