{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_LGP_TIME_REVERSAL_MIRROR",
  "effectIdHex": "0x1B00",
  "className": "LGPTimeReversalMirrorEffect",
  "displayName": "LGP Time-Reversal Mirror",
  "headerPath": "firmware/v2/src/effects/ieffect/LGPTimeReversalMirrorEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/LGPTimeReversalMirrorEffect.cpp",
  "renderRange": [
    116,
    329
  ],
  "phaseRanges": {
    "input": [
      [
        134,
        134
      ],
      [
        136,
        136
      ],
      [
        138,
        139
      ],
      [
        142,
        142
      ],
      [
        161,
        161
      ]
    ],
    "mapping": [
      [
        123,
        124
      ],
      [
        135,
        135
      ],
      [
        139,
        139
      ],
      [
        142,
        142
      ],
      [
        146,
        147
      ],
      [
        151,
        151
      ],
      [
        164,
        164
      ],
      [
        170,
        170
      ],
      [
        183,
        183
      ],
      [
        243,
        243
      ],
      [
        255,
        256
      ],
      [
        280,
        280
      ],
      [
        283,
        283
      ],
      [
        301,
        301
      ]
    ],
    "modulation": [
      [
        133,
        133
      ],
      [
        146,
        147
      ],
      [
        150,
        150
      ],
      [
        154,
        155
      ],
      [
        158,
        158
      ],
      [
        160,
        161
      ],
      [
        164,
        166
      ],
      [
        170,
        172
      ],
      [
        176,
        176
      ],
      [
        178,
        179
      ],
      [
        182,
        182
      ],
      [
        184,
        184
      ],
      [
        187,
        188
      ],
      [
        195,
        195
      ],
      [
        199,
        199
      ],
      [
        242,
        242
      ],
      [
        244,
        244
      ],
      [
        247,
        248
      ],
      [
        271,
        271
      ],
      [
        274,
        274
      ],
      [
        293,
        293
      ],
      [
        317,
        317
      ]
    ],
    "render": [
      [
        141,
        141
      ],
      [
        149,
        149
      ],
      [
        204,
        204
      ],
      [
        212,
        212
      ],
      [
        254,
        254
      ],
      [
        273,
        273
      ],
      [
        286,
        286
      ],
      [
        296,
        296
      ],
      [
        309,
        309
      ],
      [
        315,
        315
      ],
      [
        326,
        326
      ]
    ],
    "post": [
      [
        304,
        318
      ]
    ],
    "output": [
      [
        203,
        203
      ],
      [
        296,
        296
      ],
      [
        314,
        315
      ],
      [
        317,
        317
      ],
      [
        324,
        324
      ],
      [
        326,
        326
      ]
    ]
  },
  "mappingConfidence": "medium",
  "mappingWarnings": [
    "Phase 'post' inferred from fallback segmentation."
  ],
  "sourceText": "/**\n * @file LGPTimeReversalMirrorEffect.cpp\n * @brief LGP Time-Reversal Mirror effect implementation\n *\n * 1D damped wave equation recorded in a PSRAM history ring buffer then\n * played back in reverse with a phase flip -- \"physics rewinding inside glass.\"\n *\n * Centre-origin compliant: field is indexed by centerPairDistance(i), so\n * wave propagation radiates outward from LEDs 79/80.\n */\n\n#include \"LGPTimeReversalMirrorEffect.h\"\n#include \"ChromaUtils.h\"\n#include \"../CoreEffects.h\"\n#include <FastLED.h>\n#include <cmath>\n#include <cstring>\n\n#ifndef NATIVE_BUILD\n#include <esp_heap_caps.h>\n#include \"../../utils/Log.h\"\n#endif\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\n// =========================================================================\n// Helpers\n// =========================================================================\n\nstatic inline float clampf(float x, float lo, float hi) {\n    return (x < lo) ? lo : (x > hi) ? hi : x;\n}\n\n// =========================================================================\n// Construction\n// =========================================================================\n\nLGPTimeReversalMirrorEffect::LGPTimeReversalMirrorEffect()\n    : m_ps(nullptr)\n    , m_phaseTimer(0.0f)\n    , m_isReverse(false)\n    , m_frameInPhase(0)\n    , m_historyWrite(0)\n    , m_historyCount(0)\n    , m_historyRead(0)\n    , m_frameSinceImpulse(0)\n    , m_fallbackPhase(0.0f)\n{\n}\n\n// =========================================================================\n// init()\n// =========================================================================\n\nbool LGPTimeReversalMirrorEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n\n    // Allocate large field + history buffers in PSRAM\n#ifndef NATIVE_BUILD\n    if (!m_ps) {\n        m_ps = static_cast<PsramData*>(\n            heap_caps_malloc(sizeof(PsramData), MALLOC_CAP_SPIRAM));\n        if (!m_ps) {\n            LW_LOGE(\"LGPTimeReversalMirror: PSRAM alloc failed (%u bytes)\",\n                     (unsigned)sizeof(PsramData));\n            return false;\n        }\n    }\n    memset(m_ps, 0, sizeof(PsramData));\n#else\n    // Native build stub -- no PSRAM\n    m_ps = nullptr;\n#endif\n\n    // Reset phase state\n    m_phaseTimer       = 0.0f;\n    m_isReverse        = false;\n    m_frameInPhase     = 0;\n    m_historyWrite     = 0;\n    m_historyCount     = 0;\n    m_historyRead      = 0;\n    m_frameSinceImpulse = 0;\n    m_fallbackPhase    = 0.0f;\n\n    // Seed the field with a gentle centre bump to avoid a dead start\n    if (m_ps) {\n        for (uint16_t i = 0; i < kFieldSize; i++) {\n            float distNorm = (float)i / (float)(kFieldSize - 1);\n            float bump = expf(-distNorm * distNorm * 20.0f) * 0.3f;\n            m_ps->u_curr[i] = 0.5f + bump;\n            m_ps->u_prev[i] = 0.5f;\n        }\n    }\n\n#if FEATURE_AUDIO_SYNC\n    for (uint8_t i = 0; i < 12; i++) {\n        m_chromaFollowers[i].reset(0.0f);\n        m_chromaSmoothed[i] = 0.0f;\n        m_chromaTargets[i]  = 0.0f;\n    }\n    m_chromaAngle = 0.0f;\n    m_rmsFollower.reset(0.0f);\n    m_targetRms   = 0.0f;\n    m_lastHopSeq  = 0;\n#endif\n\n    return true;\n}\n\n// =========================================================================\n// render()\n// =========================================================================\n\nvoid LGPTimeReversalMirrorEffect::render(plugins::EffectContext& ctx) {\n    if (!m_ps) return;  // PSRAM guard\n\n    // -----------------------------------------------------------------\n    // Timing\n    // -----------------------------------------------------------------\n    float rawDt     = ctx.getSafeRawDeltaSeconds();\n    float speedNorm = ctx.speed / 50.0f;\n    float moodNorm  = ctx.getMoodNormalized();\n\n    // -----------------------------------------------------------------\n    // Audio processing\n    // -----------------------------------------------------------------\n    float impulseStrength = 0.6f;   // Default impulse strength (no audio)\n    uint8_t chromaHue     = 0;\n\n#if FEATURE_AUDIO_SYNC\n    bool beatTriggered    = false;\n    if (ctx.audio.available) {\n        // Hop-gated target updates\n        bool newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n        if (newHop) {\n            m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n            m_targetRms  = ctx.audio.rms();\n\n            for (uint8_t i = 0; i < 12; i++) {\n                m_chromaTargets[i] = ctx.audio.controlBus.heavy_chroma[i];\n            }\n        }\n\n        // Smooth toward targets every frame\n        float smoothedRms = m_rmsFollower.updateWithMood(m_targetRms, rawDt, moodNorm);\n\n        for (uint8_t i = 0; i < 12; i++) {\n            m_chromaSmoothed[i] = m_chromaFollowers[i].updateWithMood(\n                m_chromaTargets[i], rawDt, moodNorm);\n        }\n\n        chromaHue = effects::chroma::circularChromaHueSmoothed(\n            m_chromaSmoothed, m_chromaAngle, rawDt, 0.20f);\n\n        // RMS modulates impulse strength (0.3 .. 1.0)\n        impulseStrength = 0.3f + 0.7f * clampf(smoothedRms * 2.0f, 0.0f, 1.0f);\n\n        // Beat triggers extra impulse in forward phase\n        beatTriggered = ctx.audio.isOnBeat();\n    } else {\n        // No audio available -- gentle fallback\n        m_fallbackPhase += speedNorm * 0.4f * rawDt;\n        if (m_fallbackPhase > 6.2831853f) m_fallbackPhase -= 6.2831853f;\n        chromaHue = (uint8_t)(m_fallbackPhase * (255.0f / 6.2831853f));\n    }\n#else\n    // Audio feature disabled -- fallback animation\n    m_fallbackPhase += speedNorm * 0.4f * rawDt;\n    if (m_fallbackPhase > 6.2831853f) m_fallbackPhase -= 6.2831853f;\n    chromaHue = (uint8_t)(m_fallbackPhase * (255.0f / 6.2831853f));\n#endif\n\n    // -----------------------------------------------------------------\n    // Phase machine: forward vs reverse\n    // -----------------------------------------------------------------\n    m_phaseTimer += rawDt;\n    m_frameInPhase++;\n\n    if (!m_isReverse) {\n        // === FORWARD PHASE ===\n        float forwardDur = kForwardSec / fmaxf(speedNorm, 0.2f);\n        if (m_phaseTimer >= forwardDur) {\n            // Transition to reverse\n            m_isReverse    = true;\n            m_phaseTimer   = 0.0f;\n            m_frameInPhase = 0;\n            // Set read cursor to last written snapshot\n            m_historyRead  = (int16_t)m_historyCount - 1;\n        } else {\n            // -------------------------------------------------------\n            // Wave equation step (1D damped wave, Neumann boundaries)\n            // -------------------------------------------------------\n            // Inject centre impulse periodically (and on beat)\n            m_frameSinceImpulse++;\n            bool doImpulse = (m_frameSinceImpulse >= kImpulseEvery);\n#if FEATURE_AUDIO_SYNC\n            if (beatTriggered && !m_isReverse) doImpulse = true;\n#endif\n            if (doImpulse) {\n                m_frameSinceImpulse = 0;\n                // Gaussian impulse centred at field[0] (= strip centre)\n                for (uint16_t k = 0; k < 8; k++) {\n                    float g = expf(-(float)(k * k) * 0.5f) * impulseStrength * 0.25f;\n                    m_ps->u_curr[k] += g;\n                    m_ps->u_curr[k] = clampf(m_ps->u_curr[k], 0.0f, 1.0f);\n                }\n            }\n\n            // Compute u_next from wave equation\n            for (uint16_t i = 0; i < kFieldSize; i++) {\n                // Laplacian with Neumann (reflecting) boundary conditions\n                float left  = (i > 0)              ? m_ps->u_curr[i - 1] : m_ps->u_curr[0];\n                float right = (i < kFieldSize - 1) ? m_ps->u_curr[i + 1] : m_ps->u_curr[kFieldSize - 1];\n                float laplacian = left - 2.0f * m_ps->u_curr[i] + right;\n\n                m_ps->u_next[i] = 2.0f * m_ps->u_curr[i]\n                                 - m_ps->u_prev[i]\n                                 + kCsq * laplacian\n                                 - kDamping * m_ps->u_curr[i];\n\n                // Clamp to prevent divergence\n                m_ps->u_next[i] = clampf(m_ps->u_next[i], -0.5f, 1.5f);\n            }\n\n            // Rotate buffers\n            memcpy(m_ps->u_prev, m_ps->u_curr, sizeof(float) * kFieldSize);\n            memcpy(m_ps->u_curr, m_ps->u_next, sizeof(float) * kFieldSize);\n\n            // Record snapshot into history ring buffer\n            if (m_historyWrite < kHistoryDepth) {\n                memcpy(m_ps->history[m_historyWrite], m_ps->u_curr,\n                       sizeof(float) * kFieldSize);\n                m_historyWrite++;\n                if (m_historyCount < m_historyWrite) {\n                    m_historyCount = m_historyWrite;\n                }\n            }\n        }\n    } else {\n        // === REVERSE PHASE ===\n        float reverseDur = kReverseSec / fmaxf(speedNorm, 0.2f);\n        if (m_phaseTimer >= reverseDur || m_historyRead < 0) {\n            // Transition back to forward\n            m_isReverse    = false;\n            m_phaseTimer   = 0.0f;\n            m_frameInPhase = 0;\n            m_historyWrite = 0;\n            m_historyCount = 0;\n            m_frameSinceImpulse = 0;\n\n            // Re-seed field for next forward pass\n            for (uint16_t i = 0; i < kFieldSize; i++) {\n                float distNorm = (float)i / (float)(kFieldSize - 1);\n                float bump = expf(-distNorm * distNorm * 20.0f) * 0.3f;\n                m_ps->u_curr[i] = 0.5f + bump;\n                m_ps->u_prev[i] = 0.5f;\n            }\n        } else {\n            // Read history backwards; step read cursor by speed\n            // (skip frames at high speed to fill the time window)\n            uint16_t step = 1;\n            if (m_historyCount > 0) {\n                float idealSteps = (float)m_historyCount / (reverseDur / fmaxf(rawDt, 0.001f));\n                step = (uint16_t)fmaxf(1.0f, idealSteps);\n            }\n            m_historyRead -= (int16_t)step;\n            if (m_historyRead < 0) m_historyRead = 0;\n\n            // Load reversed snapshot into u_curr with phase flip (invert around 0.5)\n            const float* snap = m_ps->history[m_historyRead];\n            for (uint16_t i = 0; i < kFieldSize; i++) {\n                m_ps->u_curr[i] = 1.0f - snap[i];  // Phase flip\n            }\n        }\n    }\n\n    // -----------------------------------------------------------------\n    // Render: map field to LEDs via centre-origin distance\n    // -----------------------------------------------------------------\n\n    // Compute normalisation range of the current field\n    float fieldMin = m_ps->u_curr[0];\n    float fieldMax = m_ps->u_curr[0];\n    for (uint16_t i = 1; i < kFieldSize; i++) {\n        if (m_ps->u_curr[i] < fieldMin) fieldMin = m_ps->u_curr[i];\n        if (m_ps->u_curr[i] > fieldMax) fieldMax = m_ps->u_curr[i];\n    }\n    float fieldRange = fieldMax - fieldMin;\n    if (fieldRange < 0.01f) fieldRange = 0.01f;  // Avoid division by zero\n\n    // Reverse-phase visual indicator: slight hue shift\n    uint8_t reverseHueShift = m_isReverse ? 20 : 0;\n\n    for (uint16_t i = 0; i < STRIP_LENGTH; i++) {\n        uint16_t dist = centerPairDistance(i);\n        // Clamp to field size (distances 0..79)\n        uint16_t fi = (dist < kFieldSize) ? dist : (kFieldSize - 1);\n\n        // Normalise field value to 0..1\n        float fieldVal = (m_ps->u_curr[fi] - fieldMin) / fieldRange;\n        fieldVal = clampf(fieldVal, 0.0f, 1.0f);\n\n        // Brightness from field value, scaled by master brightness\n        uint8_t brightness = (uint8_t)(fieldVal * (float)ctx.brightness);\n\n        // Hue: base chroma hue + small spatial offset (max ~40 hue units)\n        // No rainbow -- two-tone palette shift capped at 40 units\n        uint8_t spatialHue = (uint8_t)((float)dist * 0.5f);  // 0..39 over 80 LEDs\n        if (spatialHue > 40) spatialHue = 40;\n        uint8_t hue = (uint8_t)(ctx.gHue + chromaHue + spatialHue + reverseHueShift);\n\n        // Strip 1\n        ctx.leds[i] = ctx.palette.getColor(hue, brightness);\n\n        // Strip 2: slight phase offset (+10 field index, clamped) and hue +30\n        uint16_t fi2 = (fi + 10 < kFieldSize) ? (fi + 10) : (kFieldSize - 1);\n        float fieldVal2 = (m_ps->u_curr[fi2] - fieldMin) / fieldRange;\n        fieldVal2 = clampf(fieldVal2, 0.0f, 1.0f);\n        uint8_t brightness2 = (uint8_t)(fieldVal2 * (float)ctx.brightness);\n        uint8_t hue2 = (uint8_t)(hue + 30);\n\n        uint16_t s2idx = i + STRIP_LENGTH;\n        if (s2idx < ctx.ledCount) {\n            ctx.leds[s2idx] = ctx.palette.getColor(hue2, brightness2);\n        }\n    }\n}\n\n// =========================================================================\n// cleanup()\n// =========================================================================\n\nvoid LGPTimeReversalMirrorEffect::cleanup() {\n#ifndef NATIVE_BUILD\n    if (m_ps) {\n        heap_caps_free(m_ps);\n        m_ps = nullptr;\n    }\n#endif\n}\n\n// =========================================================================\n// getMetadata()\n// =========================================================================\n\nconst plugins::EffectMetadata& LGPTimeReversalMirrorEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Time-Reversal Mirror\",\n        \"Damped wave recorded then replayed in reverse with phase flip\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
