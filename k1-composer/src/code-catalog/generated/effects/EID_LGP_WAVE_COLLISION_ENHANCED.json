{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_LGP_WAVE_COLLISION_ENHANCED",
  "effectIdHex": "0x0E08",
  "className": "LGPWaveCollisionEnhancedEffect",
  "displayName": "LGP Wave Collision Enhanced",
  "headerPath": "firmware/v2/src/effects/ieffect/LGPWaveCollisionEffectEnhanced.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/LGPWaveCollisionEffectEnhanced.cpp",
  "renderRange": [
    49,
    282
  ],
  "phaseRanges": {
    "input": [
      [
        53,
        53
      ],
      [
        58,
        58
      ],
      [
        60,
        60
      ],
      [
        64,
        64
      ],
      [
        92,
        92
      ],
      [
        125,
        125
      ],
      [
        129,
        129
      ],
      [
        140,
        140
      ],
      [
        147,
        147
      ],
      [
        176,
        176
      ],
      [
        190,
        190
      ]
    ],
    "mapping": [
      [
        51,
        52
      ],
      [
        62,
        62
      ],
      [
        64,
        64
      ],
      [
        77,
        79
      ],
      [
        82,
        83
      ],
      [
        87,
        87
      ],
      [
        94,
        94
      ],
      [
        107,
        107
      ],
      [
        113,
        113
      ],
      [
        116,
        116
      ],
      [
        120,
        121
      ],
      [
        141,
        141
      ],
      [
        143,
        144
      ],
      [
        152,
        152
      ],
      [
        157,
        160
      ],
      [
        163,
        163
      ],
      [
        186,
        186
      ],
      [
        191,
        191
      ],
      [
        193,
        194
      ],
      [
        224,
        224
      ],
      [
        227,
        227
      ],
      [
        265,
        265
      ],
      [
        267,
        267
      ]
    ],
    "modulation": [
      [
        70,
        71
      ],
      [
        109,
        109
      ],
      [
        112,
        112
      ],
      [
        115,
        115
      ],
      [
        119,
        121
      ],
      [
        124,
        124
      ],
      [
        134,
        134
      ],
      [
        143,
        143
      ],
      [
        149,
        149
      ],
      [
        153,
        153
      ],
      [
        156,
        156
      ],
      [
        162,
        165
      ],
      [
        167,
        167
      ],
      [
        169,
        170
      ],
      [
        183,
        183
      ],
      [
        185,
        186
      ],
      [
        188,
        188
      ],
      [
        190,
        191
      ],
      [
        194,
        196
      ],
      [
        198,
        198
      ],
      [
        201,
        202
      ],
      [
        205,
        207
      ],
      [
        209,
        209
      ],
      [
        213,
        216
      ],
      [
        218,
        218
      ],
      [
        248,
        248
      ],
      [
        250,
        250
      ],
      [
        257,
        257
      ]
    ],
    "render": [
      [
        63,
        63
      ],
      [
        69,
        69
      ],
      [
        91,
        91
      ],
      [
        111,
        111
      ],
      [
        206,
        207
      ],
      [
        220,
        220
      ],
      [
        226,
        226
      ],
      [
        231,
        231
      ],
      [
        237,
        238
      ],
      [
        243,
        243
      ],
      [
        268,
        268
      ],
      [
        273,
        274
      ],
      [
        278,
        279
      ]
    ],
    "post": [
      [
        167,
        167
      ],
      [
        188,
        188
      ],
      [
        198,
        198
      ],
      [
        205,
        205
      ],
      [
        220,
        220
      ],
      [
        254,
        254
      ],
      [
        271,
        271
      ]
    ],
    "output": [
      [
        231,
        231
      ],
      [
        234,
        235
      ],
      [
        237,
        237
      ],
      [
        243,
        243
      ],
      [
        274,
        274
      ],
      [
        276,
        276
      ],
      [
        279,
        279
      ]
    ]
  },
  "mappingConfidence": "high",
  "mappingWarnings": [],
  "sourceText": "/**\n * @file LGPWaveCollisionEffect.cpp\n * @brief LGP Wave Collision effect implementation\n */\n\n#include \"LGPWaveCollisionEffectEnhanced.h\"\n#include \"../CoreEffects.h\"\n#include \"../../config/features.h\"\n#include \"../../validation/EffectValidationMacros.h\"\n#include <FastLED.h>\n#include <cmath>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nbool LGPWaveCollisionEnhancedEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    // CRITICAL FIX: Single phase for traveling waves\n    m_phase = 0.0f;\n    m_lastHopSeq = 0;\n    m_chromaEnergySum = 0.0f;\n    m_chromaHistIdx = 0;\n    for (uint8_t i = 0; i < CHROMA_HISTORY; ++i) {\n        m_chromaEnergyHist[i] = 0.0f;\n    }\n    m_energyAvg = 0.0f;\n    m_energyDelta = 0.0f;\n    m_chromaAngle = 0.0f;\n    m_collisionBoost = 0.0f;\n    m_speedTarget = 1.0f;\n\n    // Initialize chromagram smoothing\n    for (uint8_t i = 0; i < 12; i++) {\n        m_chromaFollowers[i].reset(0.0f);\n        m_chromaSmoothed[i] = 0.0f;\n        m_chromaTargets[i] = 0.0f;\n    }\n    \n    // Initialize enhancement utilities\n    m_speedSpring.init(50.0f, 1.0f);  // stiffness=50, mass=1 (critically damped)\n    m_speedSpring.reset(1.0f);         // Start at base speed\n    m_energyAvgFollower.reset(0.0f);\n    m_energyDeltaFollower.reset(0.0f);\n    m_tempoLocked = false;\n    return true;\n}\n\nvoid LGPWaveCollisionEnhancedEffect::render(plugins::EffectContext& ctx) {\n    // CENTRE ORIGIN WAVE COLLISION - Wave packets expand outward from centre and collide\n    float speedNorm = ctx.speed / 50.0f;\n    float intensityNorm = ctx.brightness / 255.0f;\n    const bool hasAudio = ctx.audio.available;\n    bool newHop = false;\n\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n        if (newHop) {\n            m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n            \n            // Update chromagram targets\n            for (uint8_t i = 0; i < 12; i++) {\n                m_chromaTargets[i] = ctx.audio.controlBus.heavy_chroma[i];\n            }\n\n            const float led_share = 255.0f / 12.0f;\n            float chromaEnergy = 0.0f;\n            for (uint8_t i = 0; i < 12; ++i) {\n                // Use smoothed chromagram for energy calculation\n                float bin = m_chromaSmoothed[i];\n                // FIX: Use sqrt scaling instead of squaring to preserve low-level signals\n                float bright = sqrtf(bin) * 1.5f;\n                if (bright > 1.0f) bright = 1.0f;\n                chromaEnergy += bright * led_share;\n            }\n            float energyNorm = chromaEnergy / 255.0f;\n            if (energyNorm < 0.0f) energyNorm = 0.0f;\n            if (energyNorm > 1.0f) energyNorm = 1.0f;\n\n            m_chromaEnergySum -= m_chromaEnergyHist[m_chromaHistIdx];\n            m_chromaEnergyHist[m_chromaHistIdx] = energyNorm;\n            m_chromaEnergySum += energyNorm;\n            m_chromaHistIdx = (m_chromaHistIdx + 1) % CHROMA_HISTORY;\n\n            m_energyAvg = m_chromaEnergySum / CHROMA_HISTORY;\n            m_energyDelta = energyNorm - m_energyAvg;\n            if (m_energyDelta < 0.0f) m_energyDelta = 0.0f;\n            // Enhanced: 64-bin Sub-Bass Detection (bins 0-5 = ~110-155 Hz)\n            float subBassSum = 0.0f;\n            for (uint8_t i = 0; i < 6; ++i) {\n                subBassSum += ctx.audio.bin(i);\n            }\n            m_targetSubBass = subBassSum / 6.0f;\n        }\n    } else\n#endif\n    {\n        // dt-corrected decay when audio unavailable\n        float dtFallback = enhancement::getSafeDeltaSeconds(ctx.rawDeltaTimeSeconds);\n        m_energyAvg *= powf(0.98f, dtFallback * 60.0f);\n        m_energyDelta = 0.0f;\n    }\n\n    float rawDt = enhancement::getSafeDeltaSeconds(ctx.rawDeltaTimeSeconds);\n    float dt = enhancement::getSafeDeltaSeconds(ctx.deltaTimeSeconds);\n    float moodNorm = ctx.getMoodNormalized();\n\n    // Smooth chromagram with AsymmetricFollower (every frame)\n    if (hasAudio) {\n        for (uint8_t i = 0; i < 12; i++) {\n            m_chromaSmoothed[i] = m_chromaFollowers[i].updateWithMood(\n                m_chromaTargets[i], rawDt, moodNorm);\n        }\n        // Enhanced: Smooth sub-bass energy\n        m_subBassEnergy = m_subBassFollower.updateWithMood(m_targetSubBass, rawDt, moodNorm);\n    }\n\n    // True exponential smoothing with AsymmetricFollower (frame-rate independent)\n    float energyAvgSmooth = m_energyAvgFollower.updateWithMood(m_energyAvg, rawDt, moodNorm);\n    float energyDeltaSmooth = m_energyDeltaFollower.updateWithMood(m_energyDelta, rawDt, moodNorm);\n\n    // Circular chroma hue (replaces argmax + linear EMA to eliminate bin-flip rainbow sweeps)\n    uint8_t chromaHue = effects::chroma::circularChromaHueSmoothed(\n        ctx.audio.controlBus.heavy_chroma, m_chromaAngle, rawDt, 0.20f);\n\n    // Enhanced: Percussion-driven collision boost (snare = collision event!)\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio && ctx.audio.isSnareHit()) {\n        // Enhanced: Boost intensity with sub-bass energy\n        m_collisionBoost = 1.0f + m_subBassEnergy * 0.3f;  // Up to 1.3x on snare with bass\n    } else {\n        // Fallback: energy delta still contributes, but weaker\n        m_collisionBoost += energyDeltaSmooth * 0.4f;\n    }\n    if (m_collisionBoost > 1.3f) m_collisionBoost = 1.3f;  // Enhanced: Allow higher boost\n    m_collisionBoost = effects::chroma::dtDecay(m_collisionBoost, 0.88f, rawDt);  // dt-corrected decay for snappier response\n\n    // Hi-hat driven speed burst\n    if (hasAudio && ctx.audio.isHihatHit()) {\n        m_speedTarget = 1.6f;  // Temporary speed boost on hi-hat\n    }\n    // Decay speed target back to normal (exponential smoothing)\n    m_speedTarget = m_speedTarget * 0.95f + 1.0f * 0.05f;\n\n    // Enhanced: Use 64-bin sub-bass for wave intensity (more responsive than heavy_bands)\n    float bassEnergy = m_subBassEnergy * 0.7f + ctx.audio.heavyBass() * 0.3f;  // Blend sub-bass with heavy_bands\n#else\n    m_collisionBoost += energyDeltaSmooth * 0.4f;\n    if (m_collisionBoost > 1.0f) m_collisionBoost = 1.0f;\n    m_collisionBoost = effects::chroma::dtDecay(m_collisionBoost, 0.88f, rawDt);\n    m_speedTarget = m_speedTarget * 0.95f + 1.0f * 0.05f;\n    float bassEnergy = energyAvgSmooth;\n#endif\n\n    // Speed modulation with Spring physics (natural momentum, no jitter)\n    // Now modulated by bassEnergy (from heavy_bands) and speedTarget (from hi-hat)\n    float rawSpeedScale = (0.7f + 0.6f * bassEnergy) * m_speedTarget;  // Capture raw speed for validation\n    float speedTargetClamped = rawSpeedScale;\n    if (speedTargetClamped > 1.6f) speedTargetClamped = 1.6f;  // Allow higher speed with hi-hat boost\n\n    // Spring physics for speed modulation (replaces linear slew limiting)\n    float smoothedSpeed = m_speedSpring.update(speedTargetClamped, dt);\n    if (smoothedSpeed > 1.6f) smoothedSpeed = 1.6f;  // Hard clamp\n    if (smoothedSpeed < 0.3f) smoothedSpeed = 0.3f;  // Prevent stalling\n\n    // Enhanced: Use beatPhase for synchronization when tempo confidence high (PLL-style correction)\n    // Domain constants (compute once, use consistently)\n    const float PHASE_DOMAIN = 628.3f;      // 100 * 2 * PI\n    const float HALF_DOMAIN = 314.15f;     // PHASE_DOMAIN / 2\n\n    // Tempo lock hysteresis (Schmitt trigger: prevents chatter near threshold)\n    if (!hasAudio) {\n        m_tempoLocked = false;  // Clear lock when audio drops (prevents ghost lock)\n    } else {\n        float tempoConf = ctx.audio.tempoConfidence();\n        \n        // Update lock state with hysteresis (0.6 lock / 0.4 unlock)\n        if (tempoConf > 0.6f) m_tempoLocked = true;\n        else if (tempoConf < 0.4f) m_tempoLocked = false;\n    }\n\n    float prevPhase = m_phase;\n    \n    // Always advance phase (free-run oscillator)\n    m_phase += speedNorm * 240.0f * smoothedSpeed * dt;\n    \n    // Apply phase correction when tempo-locked (PLL-style P-only correction)\n    if (hasAudio && m_tempoLocked) {\n        float beatPhase = ctx.audio.beatPhase();\n        float targetPhase = beatPhase * PHASE_DOMAIN;\n        \n        // Compute wrapped error (shortest path to target)\n        float phaseError = targetPhase - m_phase;\n        if (phaseError > HALF_DOMAIN) phaseError -= PHASE_DOMAIN;\n        if (phaseError < -HALF_DOMAIN) phaseError += PHASE_DOMAIN;\n        \n        // Proportional correction (tau ~100ms gives smooth lock)\n        // Compute ONCE per frame, not per pixel\n        const float tau = 0.1f;\n        const float correctionAlpha = 1.0f - expf(-dt / tau);\n        m_phase += phaseError * correctionAlpha;\n    }\n    \n    // CRITICAL: Wrap phase AFTER correction (handles negative and overflow)\n    while (m_phase >= PHASE_DOMAIN) m_phase -= PHASE_DOMAIN;\n    while (m_phase < 0.0f) m_phase += PHASE_DOMAIN;\n    \n    float phaseDelta = m_phase - prevPhase;\n\n    // Validation instrumentation\n    VALIDATION_INIT(17);  // Effect ID 17\n    VALIDATION_PHASE(m_phase, phaseDelta);\n    VALIDATION_SPEED(rawSpeedScale, smoothedSpeed);\n    VALIDATION_AUDIO(m_chromaAngle, energyAvgSmooth, energyDeltaSmooth);\n    VALIDATION_REVERSAL_CHECK(m_prevPhaseDelta, phaseDelta);\n    VALIDATION_SUBMIT(::lightwaveos::validation::g_validationRing);\n    m_prevPhaseDelta = phaseDelta;\n\n    fadeToBlackBy(ctx.leds, ctx.ledCount, ctx.fadeAmount);\n\n    // Anti-aliased collision core at true center (79.5) using SubpixelRenderer\n    if (m_collisionBoost > 0.05f) {\n        float intensityNorm = ctx.brightness / 255.0f;\n        uint8_t baseHue = (uint8_t)(ctx.gHue + chromaHue);\n        CRGB collisionColor = ctx.palette.getColor(baseHue, 255);\n        uint8_t collisionBright = (uint8_t)(m_collisionBoost * 200.0f * intensityNorm);\n\n        // Render bright core at fractional center (between LED 79 and 80)\n        enhancement::SubpixelRenderer::renderPoint(\n            ctx.leds, STRIP_LENGTH, 79.5f, collisionColor, collisionBright\n        );\n\n        // Also render on strip 2\n        if (STRIP_LENGTH * 2 <= ctx.ledCount) {\n            enhancement::SubpixelRenderer::renderPoint(\n                ctx.leds + STRIP_LENGTH, STRIP_LENGTH, 79.5f,\n                ctx.palette.getColor(baseHue + 90, 255), collisionBright\n            );\n        }\n    }\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        // CENTRE ORIGIN: Calculate distance from centre pair\n        float distFromCenter = (float)centerPairDistance((uint16_t)i);\n\n        // DIFFERENTIATED WAVE COLLISION: Longer wavelength than Interference Scanner\n        // sin(k*dist - phase) produces OUTWARD motion when phase increases\n        const float freqBase = 0.15f;  // ~42 LED wavelength (vs Scanner's ~25-31)\n        float wave1 = sinf(distFromCenter * freqBase - m_phase);\n\n        // COLLISION FLASH: Center-focused explosion on snare hits\n        // collisionBoost decays from 1.0 (snare hit) with spatial falloff from center\n        float collisionFlash = m_collisionBoost * expf(-distFromCenter * 0.12f);  // Bright at center, fades out\n\n        // Base audio intensity (without uniform collision boost - moved to spatial flash)\n        float audioIntensity = 0.4f + 0.5f * energyAvgSmooth + 0.4f * energyDeltaSmooth;\n        // FIX: Add minimum amplitude floor for wave visibility at low bass\n        audioIntensity = fmaxf(0.2f, audioIntensity);\n        float interference = wave1 * audioIntensity + collisionFlash * 0.8f;  // Collision adds separate layer\n\n        // CRITICAL: Use tanhf for uniform brightness (like ChevronWaves)\n        interference = tanhf(interference * 2.0f) * 0.5f + 0.5f;\n\n        uint8_t brightness = (uint8_t)(interference * 255.0f * intensityNorm);\n\n        // CENTRE ORIGIN colour mapping\n        uint8_t paletteIndex = (uint8_t)(distFromCenter * 2.0f + interference * 50.0f);\n        uint8_t baseHue = (uint8_t)(ctx.gHue + chromaHue);\n\n        // Blend with existing pixel (preserves trails from fadeToBlackBy)\n        // nblend uses 8-bit amount: 0=keep existing, 255=full replace\n        CRGB newColor = ctx.palette.getColor((uint8_t)(baseHue + paletteIndex), brightness);\n        nblend(ctx.leds[i], newColor, 180);  // ~70% new, ~30% existing\n        \n        if (i + STRIP_LENGTH < ctx.ledCount) {\n            // FIX: Hue offset +90 matches ChevronWaves pattern (was +128)\n            CRGB newColor2 = ctx.palette.getColor((uint8_t)(baseHue + paletteIndex + 90), brightness);\n            nblend(ctx.leds[i + STRIP_LENGTH], newColor2, 180);  // Apply same blend to BOTH strips\n        }\n    }\n}\n\nvoid LGPWaveCollisionEnhancedEffect::cleanup() {\n    // No resources to free\n}\n\nconst plugins::EffectMetadata& LGPWaveCollisionEnhancedEffect::getMetadata() const {\n    static plugins::EffectMetadata meta(\n        \"LGP Wave Collision Enhanced\",\n        \"Enhanced: 64-bin sub-bass, enhanced snare/hi-hat triggers, beatPhase sync\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    );\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
