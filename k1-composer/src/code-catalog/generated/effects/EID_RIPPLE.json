{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_RIPPLE",
  "effectIdHex": "0x0108",
  "className": "RippleEffect",
  "displayName": "Ripple",
  "headerPath": "firmware/v2/src/effects/ieffect/RippleEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/RippleEffect.cpp",
  "renderRange": [
    63,
    306
  ],
  "phaseRanges": {
    "input": [
      [
        67,
        67
      ],
      [
        72,
        72
      ],
      [
        74,
        74
      ],
      [
        83,
        83
      ],
      [
        98,
        98
      ],
      [
        115,
        115
      ],
      [
        126,
        126
      ],
      [
        168,
        169
      ],
      [
        171,
        171
      ],
      [
        207,
        207
      ],
      [
        214,
        214
      ]
    ],
    "mapping": [
      [
        106,
        106
      ],
      [
        133,
        135
      ],
      [
        138,
        139
      ],
      [
        143,
        143
      ],
      [
        145,
        145
      ],
      [
        186,
        186
      ],
      [
        213,
        213
      ]
    ],
    "modulation": [
      [
        116,
        116
      ]
    ],
    "render": [
      [
        82,
        82
      ],
      [
        97,
        97
      ],
      [
        125,
        125
      ],
      [
        165,
        165
      ],
      [
        190,
        190
      ],
      [
        195,
        195
      ],
      [
        208,
        208
      ],
      [
        213,
        213
      ],
      [
        226,
        226
      ],
      [
        259,
        259
      ],
      [
        270,
        270
      ],
      [
        290,
        290
      ],
      [
        303,
        303
      ]
    ],
    "post": [
      [
        65,
        65
      ],
      [
        275,
        276
      ],
      [
        282,
        282
      ],
      [
        285,
        286
      ]
    ],
    "output": [
      [
        294,
        306
      ]
    ]
  },
  "mappingConfidence": "medium",
  "mappingWarnings": [
    "Phase 'output' inferred from fallback segmentation."
  ],
  "sourceText": "/**\n * @file RippleEffect.cpp\n * @brief Ripple effect implementation\n */\n\n#include \"RippleEffect.h\"\n#include \"ChromaUtils.h\"\n#include \"../CoreEffects.h\"\n#include \"../../config/features.h\"\n#include <FastLED.h>\n#include <cmath>\n#include <cstring>\n\n#ifndef NATIVE_BUILD\n#include <esp_heap_caps.h>\n#endif\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nRippleEffect::RippleEffect()\n    : m_ps(nullptr)\n{\n    for (uint8_t i = 0; i < MAX_RIPPLES; i++) {\n        m_ripples[i].active = false;\n        m_ripples[i].radius = 0;\n        m_ripples[i].speed = 0;\n        m_ripples[i].hue = 0;\n        m_ripples[i].intensity = 255;\n    }\n}\n\nbool RippleEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    for (uint8_t i = 0; i < MAX_RIPPLES; i++) {\n        m_ripples[i].active = false;\n        m_ripples[i].radius = 0;\n        m_ripples[i].intensity = 255;\n    }\n    m_lastHopSeq = 0;\n    m_spawnCooldown = 0;\n    m_lastChromaEnergy = 0.0f;\n    m_chromaEnergySum = 0.0f;\n    m_chromaHistIdx = 0;\n    for (uint8_t i = 0; i < CHROMA_HISTORY; ++i) {\n        m_chromaEnergyHist[i] = 0.0f;\n    }\n#ifndef NATIVE_BUILD\n    if (!m_ps) {\n        m_ps = static_cast<RipplePsram*>(\n            heap_caps_malloc(sizeof(RipplePsram), MALLOC_CAP_SPIRAM));\n        if (!m_ps) return false;\n    }\n    memset(m_ps, 0, sizeof(RipplePsram));\n#endif\n    m_chromaAngle = 0.0f;\n    m_kickPulse = 0.0f;\n    m_trebleShimmer = 0.0f;\n    return true;\n}\n\nvoid RippleEffect::render(plugins::EffectContext& ctx) {\n    if (!m_ps) return;\n    fadeToBlackBy(m_ps->radial, HALF_LENGTH, 45);\n\n    const bool hasAudio = ctx.audio.available;\n    bool newHop = false;\n    const float rawDtEarly = ctx.getSafeRawDeltaSeconds();\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n        if (newHop) {\n            m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n\n            // =====================================================================\n            // 64-bin Sub-Bass Kick Detection (bins 0-5 = 110-155 Hz)\n            // Deep kick drums that the 12-bin chromagram misses entirely.\n            // Gives powerful punch on bass drops - instant attack, fast decay.\n            // =====================================================================\n            float kickSum = 0.0f;\n            for (uint8_t i = 0; i < 6; ++i) {\n                kickSum += ctx.audio.bin(i);\n            }\n            float kickAvg = kickSum / 6.0f;\n            if (kickAvg > m_kickPulse) {\n                m_kickPulse = kickAvg;  // Instant attack\n            } else {\n                m_kickPulse = effects::chroma::dtDecay(m_kickPulse, 0.80f, rawDtEarly);   // dt-corrected ~80ms decay\n            }\n\n            // =====================================================================\n            // 64-bin Treble Shimmer (bins 48-63 = 1.3-4.2 kHz)\n            // Hi-hat and cymbal energy for wavefront sparkle enhancement.\n            // =====================================================================\n            float trebleSum = 0.0f;\n            for (uint8_t i = 48; i < 64; ++i) {\n                trebleSum += ctx.audio.bin(i);\n            }\n            m_trebleShimmer = trebleSum / 16.0f;\n        }\n    }\n#endif\n\n    uint8_t spawnChance = 0;\n    float energyNorm = 0.0f;\n    float energyDelta = 0.0f;\n    float energyAvg = 0.0f;\n\n    // Circular chroma hue (prevents argmax discontinuities and wrapping artefacts).\n    float rawDt = ctx.getSafeRawDeltaSeconds();\n    uint8_t chromaHueOffset = 0;\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        const float* chroma = ctx.audio.controlBus.chroma;\n        chromaHueOffset = effects::chroma::circularChromaHueSmoothed(\n            chroma, m_chromaAngle, rawDt, 0.20f);\n    }\n#endif\n\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio && newHop) {\n        const float led_share = 255.0f / 12.0f;\n        float chromaEnergy = 0.0f;\n        for (uint8_t i = 0; i < 12; ++i) {\n            float bin = ctx.audio.controlBus.chroma[i];\n            float bright = bin;\n            bright = bright * bright;\n            bright *= 1.5f;\n            if (bright > 1.0f) bright = 1.0f;\n            chromaEnergy += bright * led_share;\n        }\n        energyNorm = chromaEnergy / 255.0f;\n        if (energyNorm < 0.0f) energyNorm = 0.0f;\n        if (energyNorm > 1.0f) energyNorm = 1.0f;\n\n        m_chromaEnergySum -= m_chromaEnergyHist[m_chromaHistIdx];\n        m_chromaEnergyHist[m_chromaHistIdx] = energyNorm;\n        m_chromaEnergySum += energyNorm;\n        m_chromaHistIdx = (m_chromaHistIdx + 1) % CHROMA_HISTORY;\n        energyAvg = m_chromaEnergySum / CHROMA_HISTORY;\n\n        energyDelta = energyNorm - energyAvg;\n        if (energyDelta < 0.0f) energyDelta = 0.0f;\n        m_lastChromaEnergy = energyNorm;\n\n        float chanceF = energyDelta * 510.0f + energyAvg * 80.0f;\n        if (chanceF > 255.0f) chanceF = 255.0f;\n        spawnChance = (uint8_t)chanceF;\n    } else\n#endif\n    if (!hasAudio) {\n        spawnChance = 0;  // No ripples without audio - audio is mandatory for this product\n    }\n\n    if (m_spawnCooldown > 0) {\n        m_spawnCooldown--;\n    }\n\n    // Spawn new ripples at centre (audio-reactive when available)\n    if (hasAudio && !newHop) {\n        spawnChance = 0;\n    }\n\n    // Calculate chord-based hue shift (palette INDEX offset, not HSV rotation)\n    int8_t chordHueShift = 0;\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio && ctx.audio.chordConfidence() > 0.3f) {\n        if (ctx.audio.isMajor()) {\n            chordHueShift = 25;   // Warm shift for major chords\n        } else if (ctx.audio.isMinor()) {\n            chordHueShift = -25;  // Cool shift for minor chords\n        }\n    }\n#endif\n\n    // =========================================================================\n    // UNIFIED SPEED SCALING - all ripple types use ctx.speed\n    // Range: 1.0 (slow) to 3.0 (fast) based on speed slider\n    // =========================================================================\n    const float speedScale = 1.0f + 2.0f * (ctx.speed / 50.0f);\n\n    // =========================================================================\n    // 64-bin KICK-TRIGGERED RIPPLE (sub-bass bins 0-5)\n    // Most powerful ripple spawn - deep bass drops that chromagram misses.\n    // Bypasses normal spawn chance for immediate punchy response.\n    // =========================================================================\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio && m_kickPulse > 0.5f && m_spawnCooldown == 0) {\n        for (uint8_t r = 0; r < MAX_RIPPLES; ++r) {\n            if (!m_ripples[r].active) {\n                m_ripples[r].radius = 0.0f;      // Start at center\n                m_ripples[r].intensity = 255;    // Max intensity for bass punch\n                m_ripples[r].speed = speedScale; // Uses unified speed from slider\n                // Bass-driven warm hue (palette index based on kick intensity)\n                m_ripples[r].hue = ctx.gHue + (uint8_t)(m_kickPulse * 30.0f) + chordHueShift;\n                m_ripples[r].active = true;\n                m_spawnCooldown = 2;             // Prevent overlapping bass ripples\n                break;\n            }\n        }\n    }\n#endif\n\n    // Force ripple spawn on snare hit (percussion trigger)\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio && ctx.audio.isSnareHit()) {\n        for (uint8_t r = 0; r < MAX_RIPPLES; ++r) {\n            if (!m_ripples[r].active) {\n                m_ripples[r].radius = 0.0f;      // Reset at center\n                m_ripples[r].intensity = 255;    // Max intensity for snare burst\n                m_ripples[r].speed = speedScale; // Uses unified speed from slider\n                // Use chord root note for hue (0-11 mapped to palette index range)\n                m_ripples[r].hue = (uint8_t)((ctx.audio.rootNote() * 21) + chordHueShift);\n                m_ripples[r].active = true;\n                m_spawnCooldown = 1;             // Brief cooldown\n                break;\n            }\n        }\n    }\n#endif\n\n    // Gate spawn check to audio hop rate (not every render frame)\n    // This makes spawn rate consistent across devices regardless of FPS\n    if (newHop && spawnChance > 0 && m_spawnCooldown == 0 && random8() < spawnChance) {\n        for (int i = 0; i < MAX_RIPPLES; i++) {\n            if (!m_ripples[i].active) {\n                // Random variation around speedScale (0.5 to 1.5x speedScale)\n                float speedVariation = 0.5f + (random8() / 255.0f);\n                uint8_t intensity = 180;\n                if (hasAudio) {\n                    float energy = energyAvg;\n                    // Energy boost adds 0 to 0.5x variation\n                    speedVariation += (energy * 0.3f + energyDelta * 0.2f);\n                    float intensityF = 100.0f + energy * 155.0f + energyDelta * 100.0f;\n                    if (intensityF > 255.0f) intensityF = 255.0f;\n                    intensity = (uint8_t)intensityF;\n                }\n\n                m_ripples[i].radius = 0;\n                m_ripples[i].speed = speedScale * speedVariation;\n                if (m_ripples[i].speed > speedScale * 1.5f) m_ripples[i].speed = speedScale * 1.5f;\n                if (hasAudio) {\n                    // Apply chord warmth shift to chroma-based hue\n                    float hueBase = (float)chromaHueOffset + ctx.gHue;\n                    m_ripples[i].hue = (uint8_t)(hueBase + chordHueShift);\n                } else {\n                    m_ripples[i].hue = random8();\n                }\n                m_ripples[i].intensity = intensity;\n                m_ripples[i].active = true;\n                m_spawnCooldown = hasAudio ? 1 : 4;\n                break;\n            }\n        }\n    }\n\n    // Update and render ripples\n    for (int r = 0; r < MAX_RIPPLES; r++) {\n        if (!m_ripples[r].active) continue;\n\n        m_ripples[r].radius += m_ripples[r].speed * (ctx.speed / 10.0f);\n\n        if (m_ripples[r].radius > HALF_LENGTH) {\n            m_ripples[r].active = false;\n            continue;\n        }\n\n        // Draw ripple into radial history buffer\n        for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n            float wavePos = (float)dist - m_ripples[r].radius;\n            float waveAbs = fabsf(wavePos);\n            if (waveAbs < 3.0f) {\n                uint8_t brightness = 255 - (uint8_t)(waveAbs * 85.0f);\n                uint8_t edgeFade = (uint8_t)((HALF_LENGTH - m_ripples[r].radius) * 255.0f / HALF_LENGTH);\n                brightness = scale8(brightness, edgeFade);\n                brightness = scale8(brightness, m_ripples[r].intensity);\n\n                // =========================================================\n                // 64-bin TREBLE SHIMMER on wavefront (bins 48-63)\n                // Hi-hat/cymbal energy adds sparkle to the leading edge.\n                // Stronger at wavefront (waveAbs~0), fades toward trailing edge.\n                // =========================================================\n                if (m_trebleShimmer > 0.1f) {\n                    float shimmerFade = 1.0f - (waveAbs / 3.0f);  // 1.0 at front, 0.0 at back\n                    uint8_t shimmerBoost = (uint8_t)(m_trebleShimmer * shimmerFade * 60.0f);\n                    brightness = qadd8(brightness, shimmerBoost);\n                }\n\n                CRGB color = ctx.palette.getColor(\n                    m_ripples[r].hue + (uint8_t)dist,\n                    brightness);\n                m_ps->radial[dist].r = qadd8(m_ps->radial[dist].r, color.r);\n                m_ps->radial[dist].g = qadd8(m_ps->radial[dist].g, color.g);\n                m_ps->radial[dist].b = qadd8(m_ps->radial[dist].b, color.b);\n            }\n        }\n    }\n\n    memcpy(m_ps->radialAux, m_ps->radial, sizeof(m_ps->radial));\n\n    // Render radial history buffer to LEDs (centre-origin)\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        SET_CENTER_PAIR(ctx, dist, m_ps->radialAux[dist]);\n    }\n}\n\nvoid RippleEffect::cleanup() {\n#ifndef NATIVE_BUILD\n    if (m_ps) {\n        heap_caps_free(m_ps);\n        m_ps = nullptr;\n    }\n#endif\n}\n\nconst plugins::EffectMetadata& RippleEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Ripple\",\n        \"Audio-reactive ripples expanding from centre\",\n        plugins::EffectCategory::WATER,\n        1\n    };\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
