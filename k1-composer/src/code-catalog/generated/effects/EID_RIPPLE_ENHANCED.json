{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_RIPPLE_ENHANCED",
  "effectIdHex": "0x0E09",
  "className": "RippleEnhancedEffect",
  "displayName": "Ripple Enhanced",
  "headerPath": "firmware/v2/src/effects/ieffect/RippleEnhancedEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/RippleEnhancedEffect.cpp",
  "renderRange": [
    73,
    350
  ],
  "phaseRanges": {
    "input": [
      [
        77,
        77
      ],
      [
        88,
        89
      ],
      [
        95,
        95
      ],
      [
        97,
        97
      ],
      [
        105,
        105
      ],
      [
        115,
        115
      ],
      [
        121,
        121
      ],
      [
        149,
        149
      ],
      [
        219,
        219
      ],
      [
        253,
        253
      ]
    ],
    "mapping": [
      [
        83,
        83
      ],
      [
        107,
        107
      ],
      [
        117,
        117
      ],
      [
        119,
        119
      ],
      [
        121,
        121
      ],
      [
        125,
        127
      ],
      [
        132,
        132
      ],
      [
        141,
        141
      ],
      [
        166,
        168
      ],
      [
        171,
        172
      ],
      [
        176,
        176
      ],
      [
        180,
        180
      ],
      [
        232,
        232
      ]
    ],
    "modulation": [
      [
        79,
        80
      ],
      [
        87,
        93
      ],
      [
        125,
        125
      ],
      [
        129,
        129
      ],
      [
        131,
        131
      ],
      [
        135,
        136
      ],
      [
        150,
        150
      ],
      [
        160,
        160
      ],
      [
        210,
        210
      ],
      [
        213,
        213
      ],
      [
        217,
        218
      ]
    ],
    "render": [
      [
        104,
        104
      ],
      [
        114,
        114
      ],
      [
        120,
        120
      ],
      [
        130,
        130
      ],
      [
        159,
        159
      ],
      [
        214,
        214
      ],
      [
        236,
        236
      ],
      [
        241,
        241
      ],
      [
        254,
        254
      ],
      [
        270,
        270
      ],
      [
        303,
        303
      ],
      [
        314,
        314
      ],
      [
        329,
        329
      ],
      [
        333,
        333
      ],
      [
        336,
        336
      ],
      [
        347,
        347
      ]
    ],
    "post": [
      [
        75,
        75
      ],
      [
        319,
        320
      ],
      [
        328,
        329
      ]
    ],
    "output": [
      [
        337,
        350
      ]
    ]
  },
  "mappingConfidence": "medium",
  "mappingWarnings": [
    "Phase 'output' inferred from fallback segmentation."
  ],
  "sourceText": "/**\n * @file RippleEnhancedEffect.cpp\n * @brief Ripple Enhanced effect - Enhanced version with improved thresholds and snare triggers\n */\n\n#include \"RippleEnhancedEffect.h\"\n#include \"ChromaUtils.h\"\n#include \"../CoreEffects.h\"\n#include \"../enhancement/SmoothingEngine.h\"\n#include \"../../config/features.h\"\n#include <FastLED.h>\n#include <cmath>\n#include <cstring>\n\n#ifndef NATIVE_BUILD\n#include <esp_heap_caps.h>\n#endif\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nRippleEnhancedEffect::RippleEnhancedEffect()\n    : m_ps(nullptr)\n{\n    for (uint8_t i = 0; i < MAX_RIPPLES; i++) {\n        m_ripples[i].active = false;\n        m_ripples[i].radius = 0;\n        m_ripples[i].speed = 0;\n        m_ripples[i].hue = 0;\n        m_ripples[i].intensity = 255;\n    }\n}\n\nbool RippleEnhancedEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    for (uint8_t i = 0; i < MAX_RIPPLES; i++) {\n        m_ripples[i].active = false;\n        m_ripples[i].radius = 0;\n        m_ripples[i].intensity = 255;\n    }\n    m_lastHopSeq = 0;\n    m_spawnCooldown = 0;\n    m_lastChromaEnergy = 0.0f;\n    m_chromaEnergySum = 0.0f;\n    m_chromaHistIdx = 0;\n    for (uint8_t i = 0; i < CHROMA_HISTORY; ++i) {\n        m_chromaEnergyHist[i] = 0.0f;\n    }\n    m_lastBeatState = false;\n    m_lastDownbeatState = false;\n#ifndef NATIVE_BUILD\n    if (!m_ps) {\n        m_ps = static_cast<RippleEnhancedPsram*>(\n            heap_caps_malloc(sizeof(RippleEnhancedPsram), MALLOC_CAP_SPIRAM));\n        if (!m_ps) return false;\n    }\n    memset(m_ps, 0, sizeof(RippleEnhancedPsram));\n    for (uint8_t i = 0; i < 12; i++) {\n        m_ps->chromaFollowers[i].reset(0.0f);\n    }\n#endif\n    m_chromaAngle = 0.0f;\n    m_kickFollower.reset(0.0f);\n    m_trebleFollower.reset(0.0f);\n    m_kickPulse = 0.0f;\n    m_trebleShimmer = 0.0f;\n    m_targetKick = 0.0f;\n    m_targetTreble = 0.0f;\n    return true;\n}\n\nvoid RippleEnhancedEffect::render(plugins::EffectContext& ctx) {\n    if (!m_ps) return;\n    fadeToBlackBy(m_ps->radial, HALF_LENGTH, ctx.fadeAmount);\n\n    const bool hasAudio = ctx.audio.available;\n    bool newHop = false;\n    bool beatOnset = false;\n    bool downbeatOnset = false;\n    float rawDt = ctx.getSafeRawDeltaSeconds();\n    float dt = ctx.getSafeDeltaSeconds();\n    float moodNorm = ctx.getMoodNormalized();\n\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        // Beat/downbeat edge detection (not hop-gated)\n        const bool currentBeat = ctx.audio.isOnBeat();\n        const bool currentDownbeat = ctx.audio.isOnDownbeat();\n        beatOnset = currentBeat && !m_lastBeatState;\n        downbeatOnset = currentDownbeat && !m_lastDownbeatState;\n        m_lastBeatState = currentBeat;\n        m_lastDownbeatState = currentDownbeat;\n\n        newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n        if (newHop) {\n            m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n\n            // =====================================================================\n            // 64-bin Sub-Bass Kick Detection (bins 0-5 = 110-155 Hz)\n            // Deep kick drums that the 12-bin chromagram misses entirely.\n            // =====================================================================\n            float kickSum = 0.0f;\n            for (uint8_t i = 0; i < 6; ++i) {\n                kickSum += ctx.audio.bin(i);\n            }\n            m_targetKick = kickSum / 6.0f;\n\n            // =====================================================================\n            // 64-bin Treble Shimmer (bins 48-63 = 1.3-4.2 kHz)\n            // Hi-hat and cymbal energy for wavefront sparkle enhancement.\n            // =====================================================================\n            float trebleSum = 0.0f;\n            for (uint8_t i = 48; i < 64; ++i) {\n                trebleSum += ctx.audio.bin(i);\n            }\n            m_targetTreble = trebleSum / 16.0f;\n\n            // Update chromagram targets\n            for (uint8_t i = 0; i < 12; i++) {\n                m_ps->chromaTargets[i] = ctx.audio.controlBus.heavy_chroma[i];\n            }\n        }\n\n        // Smooth toward targets every frame with MOOD-adjusted smoothing\n        m_kickPulse = m_kickFollower.updateWithMood(m_targetKick, rawDt, moodNorm);\n        m_trebleShimmer = m_trebleFollower.updateWithMood(m_targetTreble, rawDt, moodNorm);\n\n        // Smooth chromagram with AsymmetricFollower\n        for (uint8_t i = 0; i < 12; i++) {\n            m_ps->chromaSmoothed[i] = m_ps->chromaFollowers[i].updateWithMood(\n                m_ps->chromaTargets[i], rawDt, moodNorm);\n        }\n    } else {\n        m_lastBeatState = false;\n        m_lastDownbeatState = false;\n    }\n#endif\n\n    uint8_t spawnChance = 0;\n    float energyNorm = 0.0f;\n    float energyDelta = 0.0f;\n    float energyAvg = 0.0f;\n\n    // Circular chroma hue (prevents argmax discontinuities and wrapping artefacts).\n    uint8_t chromaHueOffset = 0;\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        const float* chroma = ctx.audio.controlBus.chroma;\n        chromaHueOffset = effects::chroma::circularChromaHueSmoothed(\n            chroma, m_chromaAngle, rawDt, 0.20f);\n    }\n#endif\n\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio && newHop) {\n        const float led_share = 255.0f / 12.0f;\n        float chromaEnergy = 0.0f;\n        for (uint8_t i = 0; i < 12; ++i) {\n            float bin = m_ps->chromaSmoothed[i];  // Use smoothed chromagram\n            // FIX: Use sqrt scaling instead of squaring to preserve low-level signals\n            float bright = sqrtf(bin) * 1.5f;\n            if (bright > 1.0f) bright = 1.0f;\n            chromaEnergy += bright * led_share;\n        }\n        energyNorm = chromaEnergy / 255.0f;\n        if (energyNorm < 0.0f) energyNorm = 0.0f;\n        if (energyNorm > 1.0f) energyNorm = 1.0f;\n\n        m_chromaEnergySum -= m_chromaEnergyHist[m_chromaHistIdx];\n        m_chromaEnergyHist[m_chromaHistIdx] = energyNorm;\n        m_chromaEnergySum += energyNorm;\n        m_chromaHistIdx = (m_chromaHistIdx + 1) % CHROMA_HISTORY;\n        energyAvg = m_chromaEnergySum / CHROMA_HISTORY;\n\n        energyDelta = energyNorm - energyAvg;\n        // FIX: Allow small negative delta to still contribute (halve threshold)\n        if (energyDelta < -0.1f) energyDelta = 0.0f;\n        else if (energyDelta < 0.0f) energyDelta = 0.0f;  // Clamp to zero but don't skip\n        m_lastChromaEnergy = energyNorm;\n\n        // FIX: Lower spawn threshold multipliers for more activity\n        float chanceF = energyDelta * 400.0f + energyAvg * 120.0f;\n        if (chanceF > 255.0f) chanceF = 255.0f;\n        spawnChance = (uint8_t)chanceF;\n    } else\n#endif\n    if (!hasAudio) {\n        spawnChance = 0;  // No ripples without audio - audio is mandatory for this product\n    }\n\n    if (m_spawnCooldown > 0) {\n        m_spawnCooldown--;\n    }\n\n    // Spawn new ripples at centre (audio-reactive when available)\n    if (hasAudio && !newHop) {\n        spawnChance = 0;\n    }\n\n    // Enhanced: No chord reactivity (removed - not proven feature)\n\n    // =========================================================================\n    // UNIFIED SPEED SCALING - all ripple types use ctx.speed\n    // Range: 1.0 (slow) to 3.0 (fast) based on speed slider\n    // =========================================================================\n    const float speedScale = 1.0f + 2.0f * (ctx.speed / 50.0f);\n\n    // =========================================================================\n    // BEAT/DOWNBEAT EDGE RIPPLE (latched, not hop-gated)\n    // =========================================================================\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio && (beatOnset || downbeatOnset)) {\n        for (uint8_t r = 0; r < MAX_RIPPLES; ++r) {\n            if (!m_ripples[r].active) {\n                m_ripples[r].radius = 0.0f;\n                m_ripples[r].intensity = downbeatOnset ? 255 : 210;\n                m_ripples[r].speed = speedScale * (downbeatOnset ? 1.2f : 1.0f);\n                float harmonicShift = ctx.audio.harmonicSaliency() * 40.0f;\n                m_ripples[r].hue = ctx.gHue + (uint8_t)harmonicShift;\n                m_ripples[r].active = true;\n                m_spawnCooldown = 1;\n                break;\n            }\n        }\n    }\n#endif\n\n    // =========================================================================\n    // 64-bin KICK-TRIGGERED RIPPLE (sub-bass bins 0-5)\n    // Most powerful ripple spawn - deep bass drops that chromagram misses.\n    // Bypasses normal spawn chance for immediate punchy response.\n    // =========================================================================\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio && m_kickPulse > 0.4f && m_spawnCooldown == 0) {  // Enhanced: Lower threshold (0.4f instead of 0.5f)\n        for (uint8_t r = 0; r < MAX_RIPPLES; ++r) {\n            if (!m_ripples[r].active) {\n                m_ripples[r].radius = 0.0f;      // Start at center\n                m_ripples[r].intensity = 255;    // Max intensity for bass punch\n                m_ripples[r].speed = speedScale; // Uses unified speed from slider\n                // Bass-driven warm hue (palette index based on kick intensity)\n                m_ripples[r].hue = ctx.gHue + (uint8_t)(m_kickPulse * 30.0f);\n                m_ripples[r].active = true;\n                m_spawnCooldown = 2;             // Prevent overlapping bass ripples\n                break;\n            }\n        }\n    }\n#endif\n\n    // Force ripple spawn on snare hit (percussion trigger)\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio && ctx.audio.isSnareHit()) {\n        for (uint8_t r = 0; r < MAX_RIPPLES; ++r) {\n            if (!m_ripples[r].active) {\n                m_ripples[r].radius = 0.0f;      // Reset at center\n                m_ripples[r].intensity = 255;    // Max intensity for snare burst\n                m_ripples[r].speed = speedScale; // Uses unified speed from slider\n                // Enhanced: Use circular chroma hue (no chord reactivity)\n                m_ripples[r].hue = ctx.gHue + chromaHueOffset;\n                m_ripples[r].active = true;\n                m_spawnCooldown = 1;             // Brief cooldown\n                break;\n            }\n        }\n    }\n#endif\n\n    if (spawnChance > 0 && m_spawnCooldown == 0 && random8() < spawnChance) {\n        for (int i = 0; i < MAX_RIPPLES; i++) {\n            if (!m_ripples[i].active) {\n                // Random variation around speedScale (0.5 to 1.5x speedScale)\n                float speedVariation = 0.5f + (random8() / 255.0f);\n                uint8_t intensity = 180;\n                if (hasAudio) {\n                    float energy = energyAvg;\n                    // Energy boost adds 0 to 0.5x variation\n                    speedVariation += (energy * 0.3f + energyDelta * 0.2f);\n                    float intensityF = 100.0f + energy * 155.0f + energyDelta * 100.0f;\n                    if (intensityF > 255.0f) intensityF = 255.0f;\n                    intensity = (uint8_t)intensityF;\n                }\n\n                m_ripples[i].radius = 0;\n                m_ripples[i].speed = speedScale * speedVariation;\n                if (m_ripples[i].speed > speedScale * 1.5f) m_ripples[i].speed = speedScale * 1.5f;\n                if (hasAudio) {\n                    // Enhanced: Use circular chroma hue (no chord reactivity)\n                    float hueBase = (float)chromaHueOffset + ctx.gHue;\n                    m_ripples[i].hue = (uint8_t)hueBase;\n                } else {\n                    m_ripples[i].hue = random8();\n                }\n                m_ripples[i].intensity = intensity;\n                m_ripples[i].active = true;\n                m_spawnCooldown = hasAudio ? 1 : 4;\n                break;\n            }\n        }\n    }\n\n    // Update and render ripples\n    for (int r = 0; r < MAX_RIPPLES; r++) {\n        if (!m_ripples[r].active) continue;\n\n        m_ripples[r].radius += m_ripples[r].speed * (ctx.speed / 10.0f);\n\n        if (m_ripples[r].radius > HALF_LENGTH) {\n            m_ripples[r].active = false;\n            continue;\n        }\n\n        // Draw ripple into radial history buffer\n        for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n            float wavePos = (float)dist - m_ripples[r].radius;\n            float waveAbs = fabsf(wavePos);\n            if (waveAbs < 3.0f) {\n                uint8_t brightness = 255 - (uint8_t)(waveAbs * 85.0f);\n                uint8_t edgeFade = (uint8_t)((HALF_LENGTH - m_ripples[r].radius) * 255.0f / HALF_LENGTH);\n                brightness = scale8(brightness, edgeFade);\n                brightness = scale8(brightness, m_ripples[r].intensity);\n\n                // =========================================================\n                // 64-bin TREBLE SHIMMER on wavefront (bins 48-63)\n                // Hi-hat/cymbal energy adds sparkle; capped to avoid brightness stacking wash (colour fix).\n                // =========================================================\n                if (m_trebleShimmer > 0.08f) {\n                    float shimmerFade = 1.0f - (waveAbs / 3.0f);  // 1.0 at front, 0.0 at back\n                    uint8_t shimmerBoost = (uint8_t)(m_trebleShimmer * shimmerFade * 30.0f);  // was 60; halved to preserve palette\n                    brightness = qadd8(brightness, shimmerBoost);\n                }\n\n                CRGB color = ctx.palette.getColor(\n                    m_ripples[r].hue + (uint8_t)dist,\n                    brightness);\n                // Keep colours within palette: select brightest contributor.\n                if (brightness > m_ps->radial[dist].getAverageLight()) {\n                    m_ps->radial[dist] = color;\n                }\n            }\n        }\n    }\n\n    memcpy(m_ps->radialAux, m_ps->radial, sizeof(m_ps->radial));\n\n    // Render radial history buffer to LEDs (centre-origin)\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        SET_CENTER_PAIR(ctx, dist, m_ps->radialAux[dist]);\n    }\n}\n\nvoid RippleEnhancedEffect::cleanup() {\n#ifndef NATIVE_BUILD\n    if (m_ps) {\n        heap_caps_free(m_ps);\n        m_ps = nullptr;\n    }\n#endif\n}\n\nconst plugins::EffectMetadata& RippleEnhancedEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Ripple Enhanced\",\n        \"Enhanced: Improved 64-bin thresholds, snare triggers, treble shimmer\",\n        plugins::EffectCategory::WATER,\n        1\n    };\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
