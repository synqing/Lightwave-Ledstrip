{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_WAVE_AMBIENT",
  "effectIdHex": "0x0107",
  "className": "WaveAmbientEffect",
  "displayName": "Wave Ambient",
  "headerPath": "firmware/v2/src/effects/ieffect/WaveAmbientEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/WaveAmbientEffect.cpp",
  "renderRange": [
    42,
    106
  ],
  "phaseRanges": {
    "input": [
      [
        53,
        53
      ],
      [
        59,
        59
      ],
      [
        64,
        64
      ]
    ],
    "mapping": [
      [
        49,
        59
      ]
    ],
    "modulation": [
      [
        63,
        67
      ],
      [
        69,
        69
      ],
      [
        77,
        79
      ],
      [
        90,
        90
      ],
      [
        93,
        94
      ]
    ],
    "render": [
      [
        82,
        82
      ],
      [
        84,
        84
      ],
      [
        99,
        99
      ],
      [
        101,
        101
      ],
      [
        103,
        103
      ]
    ],
    "post": [
      [
        46,
        46
      ],
      [
        81,
        82
      ]
    ],
    "output": [
      [
        84,
        84
      ],
      [
        101,
        103
      ]
    ]
  },
  "mappingConfidence": "medium",
  "mappingWarnings": [
    "Phase 'mapping' inferred from fallback segmentation."
  ],
  "sourceText": "/**\n * @file WaveAmbientEffect.cpp\n * @brief Wave Ambient - Time-driven sine wave with audio amplitude modulation\n *\n * Pattern: AMBIENT (Sensory Bridge Bloom-style)\n * - Motion: TIME-BASED (user speed parameter only)\n * - Audio: RMS → amplitude, Flux → brightness boost\n *\n * This is the \"calm\" wave effect. Speed is controlled by user parameter,\n * audio only affects brightness/amplitude. No jitter from audio metrics.\n *\n * For reactive wave motion, see WaveReactiveEffect.\n */\n\n#include \"WaveAmbientEffect.h\"\n#include \"../CoreEffects.h\"\n#include <FastLED.h>\n#include <cmath>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\n// Flux boost decay rate\nstatic constexpr float FLUX_BOOST_DECAY = 0.9f;\n\nWaveAmbientEffect::WaveAmbientEffect()\n    : m_waveOffset(0)\n    , m_lastFlux(0.0f)\n    , m_fluxBoost(0.0f)\n{\n}\n\nbool WaveAmbientEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_waveOffset = 0;\n    m_lastFlux = 0.0f;\n    m_fluxBoost = 0.0f;\n    return true;\n}\n\nvoid WaveAmbientEffect::render(plugins::EffectContext& ctx) {\n    // CENTER ORIGIN WAVE - Waves propagate from center\n    // AMBIENT pattern: time-based speed, audio→amplitude only\n\n    // Speed is TIME-BASED only (Sensory Bridge Bloom pattern)\n    // NO audio→speed coupling - prevents jitter\n    float waveSpeed = (float)ctx.speed;\n    float amplitude = 1.0f;\n    float waveFreq = 15.0f;  // Fixed wave frequency\n\n#if FEATURE_AUDIO_SYNC\n    if (ctx.audio.available) {\n        // Speed remains TIME-BASED - no modification from audio\n        // This is the key difference from the old broken pattern\n\n        // RMS drives amplitude (audio→brightness - the valid coupling)\n        // sqrt scaling for more visible low-RMS response\n        float rms = ctx.audio.rms();\n        float rmsScaled = sqrtf(rms);  // 0.1 RMS -> 0.316 scaled\n        amplitude = 0.1f + 0.9f * rmsScaled;  // 10-100% amplitude\n\n        // Flux transient detection (brightness boost)\n        float flux = ctx.audio.flux();\n        float fluxDelta = flux - m_lastFlux;\n        if (fluxDelta > 0.1f && flux > 0.2f) {\n            m_fluxBoost = fmaxf(m_fluxBoost, flux);\n        }\n        m_lastFlux = flux;\n    }\n#endif\n\n    // Update wave offset (time-based only)\n    m_waveOffset += (uint32_t)waveSpeed;\n    if (m_waveOffset > 65535) m_waveOffset = m_waveOffset % 65536;\n\n    // Decay flux boost\n    m_fluxBoost *= FLUX_BOOST_DECAY;\n    if (m_fluxBoost < 0.01f) m_fluxBoost = 0.0f;\n\n    // Gentle fade\n    fadeToBlackBy(ctx.leds, ctx.ledCount, 12);\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float distFromCenter = (float)centerPairDistance((uint16_t)i);\n\n        // Wave propagates outward from center\n        uint8_t rawBrightness = sin8((uint16_t)(distFromCenter * waveFreq) + (m_waveOffset >> 4));\n\n        // Apply amplitude modulation from RMS (audio→brightness)\n        uint8_t brightness = (uint8_t)(rawBrightness * amplitude);\n\n        // Add flux boost for transients\n        brightness = qadd8(brightness, (uint8_t)(m_fluxBoost * 50.0f));\n\n        // Color follows wave with subtle motion\n        uint8_t colorIndex = (uint8_t)(distFromCenter * 8) + (m_waveOffset >> 6);\n\n        CRGB color = ctx.palette.getColor(colorIndex, brightness);\n\n        ctx.leds[i] = color;\n        if (i + STRIP_LENGTH < ctx.ledCount) {\n            ctx.leds[i + STRIP_LENGTH] = color;\n        }\n    }\n}\n\nvoid WaveAmbientEffect::cleanup() {\n    // No resources to free\n}\n\nconst plugins::EffectMetadata& WaveAmbientEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Wave Ambient\",\n        \"Time-driven sine wave with audio amplitude modulation\",\n        plugins::EffectCategory::WATER,\n        1\n    };\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n\n"
}
