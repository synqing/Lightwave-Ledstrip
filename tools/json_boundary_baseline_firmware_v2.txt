firmware/v2/src/network/ApiResponse.h|P2|response["success"] = true;
firmware/v2/src/network/ApiResponse.h|P2|response["timestamp"] = millis();
firmware/v2/src/network/ApiResponse.h|P2|response["version"] = API_VERSION;
firmware/v2/src/network/WebServer.cpp|P1|const char* msgType = doc["type"] | "";
firmware/v2/src/network/WebServer.cpp|P1|const char* providedKey = doc["apiKey"] | "";
firmware/v2/src/network/WebServer.cpp|P1|uint8_t type = params["type"] | 0;
firmware/v2/src/network/webserver/handlers/AudioHandlers.cpp|P1|const char* action = doc["action"] | "";
firmware/v2/src/network/webserver/handlers/AudioHandlers.cpp|P1|const char* name = doc["name"] | "Unnamed";
firmware/v2/src/network/webserver/handlers/AudioHandlers.cpp|P1|resetState = doc["resetState"] | false;
firmware/v2/src/network/webserver/handlers/AudioHandlers.cpp|P2|data["activeEffects"] = registry.getActiveEffectCount();
firmware/v2/src/network/webserver/handlers/AudioHandlers.cpp|P2|data["effectId"] = effectId;
firmware/v2/src/network/webserver/handlers/AudioHandlers.cpp|P2|data["totalMappings"] = registry.getTotalMappingCount();
firmware/v2/src/network/webserver/handlers/BatchHandlers.cpp|P2|data["failed"] = failed;
firmware/v2/src/network/webserver/handlers/BatchHandlers.cpp|P2|data["processed"] = processed;
firmware/v2/src/network/webserver/handlers/DebugHandlers.cpp|P1|int interval = doc["baseInterval"].as<int>();
firmware/v2/src/network/webserver/handlers/DebugHandlers.cpp|P1|int verbosity = doc["verbosity"].as<int>();
firmware/v2/src/network/webserver/handlers/DebugHandlers.cpp|P2|data["baseInterval"] = cfg.baseInterval;
firmware/v2/src/network/webserver/handlers/DebugHandlers.cpp|P2|data["verbosity"] = cfg.verbosity;
firmware/v2/src/network/webserver/handlers/DebugHandlers.cpp|P2|data["verbosity"] = cfg.verbosity;
firmware/v2/src/network/webserver/handlers/DeviceHandlers.cpp|P2|data["freeHeap"] = ESP.getFreeHeap();
firmware/v2/src/network/webserver/handlers/DeviceHandlers.cpp|P2|data["heapSize"] = ESP.getHeapSize();
firmware/v2/src/network/webserver/handlers/DeviceHandlers.cpp|P2|data["uptime"] = (millis() - startTime) / 1000;
firmware/v2/src/network/webserver/handlers/EffectHandlers.cpp|P1|bool useTransition = doc["transition"] | false;
firmware/v2/src/network/webserver/handlers/EffectHandlers.cpp|P1|if (!doc.containsKey("parameters") || !doc["parameters"].is<JsonObject>()) {
firmware/v2/src/network/webserver/handlers/EffectHandlers.cpp|P1|JsonObject params = doc["parameters"].as<JsonObject>();
firmware/v2/src/network/webserver/handlers/EffectHandlers.cpp|P2|data["limit"] = capturedLimit;
firmware/v2/src/network/webserver/handlers/EffectHandlers.cpp|P2|data["offset"] = capturedOffset;
firmware/v2/src/network/webserver/handlers/EffectHandlers.cpp|P2|data["total"] = capturedTotal;
firmware/v2/src/network/webserver/handlers/NarrativeHandlers.cpp|P1|narrative.setDurationVariance(doc["durationVariance"] | 0.0f);
firmware/v2/src/network/webserver/handlers/NarrativeHandlers.cpp|P1|narrative.setHoldBreathe(doc["holdBreathe"] | 0.0f);
firmware/v2/src/network/webserver/handlers/NarrativeHandlers.cpp|P1|narrative.setSnapAmount(doc["snapAmount"] | 0.0f);
firmware/v2/src/network/webserver/handlers/NarrativeHandlers.cpp|P2|data["enabled"] = narrative.isEnabled();
firmware/v2/src/network/webserver/handlers/NarrativeHandlers.cpp|P2|data["phaseT"] = narrative.getPhaseT();
firmware/v2/src/network/webserver/handlers/NarrativeHandlers.cpp|P2|data["tension"] = narrative.getTension() * 100.0f;  // Convert 0-1 to 0-100
firmware/v2/src/network/webserver/handlers/PaletteHandlers.cpp|P1|JsonObject data = doc["data"].to<JsonObject>();
firmware/v2/src/network/webserver/handlers/PaletteHandlers.cpp|P2|data["limit"] = limit;
firmware/v2/src/network/webserver/handlers/PaletteHandlers.cpp|P2|data["offset"] = actualOffset;
firmware/v2/src/network/webserver/handlers/PaletteHandlers.cpp|P2|data["total"] = filteredCount;
firmware/v2/src/network/webserver/handlers/ParameterHandlers.cpp|P2|data["brightness"] = cachedState.brightness;
firmware/v2/src/network/webserver/handlers/ParameterHandlers.cpp|P2|data["paletteId"] = cachedState.paletteIndex;
firmware/v2/src/network/webserver/handlers/ParameterHandlers.cpp|P2|data["speed"] = cachedState.speed;
firmware/v2/src/network/webserver/handlers/PluginHandlers.cpp|P2|data["loadedFromLittleFS"] = stats.loadedFromLittleFS;
firmware/v2/src/network/webserver/handlers/PluginHandlers.cpp|P2|data["overrideModeEnabled"] = stats.overrideModeEnabled;
firmware/v2/src/network/webserver/handlers/PluginHandlers.cpp|P2|data["registeredCount"] = stats.registeredCount;
firmware/v2/src/network/webserver/handlers/SystemHandlers.cpp|P1|JsonObject data = doc["data"].to<JsonObject>();
firmware/v2/src/network/webserver/handlers/SystemHandlers.cpp|P1|JsonObject paramsGet = params["get"].to<JsonObject>();
firmware/v2/src/network/webserver/handlers/SystemHandlers.cpp|P1|JsonObject paramsPost = params["post"].to<JsonObject>();
firmware/v2/src/network/webserver/handlers/SystemHandlers.cpp|P2|data["freeHeap"] = ESP.getFreeHeap();
firmware/v2/src/network/webserver/handlers/SystemHandlers.cpp|P2|data["totalHeap"] = ESP.getHeapSize();
firmware/v2/src/network/webserver/handlers/SystemHandlers.cpp|P2|data["uptime"] = millis() / 1000;
firmware/v2/src/network/webserver/handlers/TransitionHandlers.cpp|P1|bool randomType = doc["random"] | false;
firmware/v2/src/network/webserver/handlers/TransitionHandlers.cpp|P1|uint16_t duration = doc["defaultDuration"] | 1000;
firmware/v2/src/network/webserver/handlers/TransitionHandlers.cpp|P1|uint8_t transitionType = doc["type"] | 0;
firmware/v2/src/network/webserver/handlers/TransitionHandlers.cpp|P2|data["defaultDuration"] = 1000;
firmware/v2/src/network/webserver/handlers/TransitionHandlers.cpp|P2|data["defaultType"] = 0;  // FADE
firmware/v2/src/network/webserver/handlers/TransitionHandlers.cpp|P2|data["enabled"] = true;  // Transitions always enabled in v2
firmware/v2/src/network/webserver/handlers/ZoneHandlers.cpp|P2|data["enabled"] = composer->isEnabled();
firmware/v2/src/network/webserver/handlers/ZoneHandlers.cpp|P2|data["id"] = zoneId;
firmware/v2/src/network/webserver/handlers/ZoneHandlers.cpp|P2|data["zoneCount"] = composer->getZoneCount();
firmware/v2/src/network/webserver/V1ApiRoutes.cpp|P2|data["message"] = "Audio sync not enabled";
firmware/v2/src/network/webserver/V1ApiRoutes.cpp|P2|data["verbosity"] = 0;
firmware/v2/src/network/webserver/V1ApiRoutes.cpp|P2|eventDoc["type"] = "zone.enabledChanged";
firmware/v2/src/network/webserver/ws/WsAudioCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsAudioCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsAudioCommands.cpp|P1|resetState = doc["resetState"] | false;
firmware/v2/src/network/webserver/ws/WsAudioCommands.cpp|P2|data["clientId"] = clientId;
firmware/v2/src/network/webserver/ws/WsAudioCommands.cpp|P2|data["frameSize"] = AudioStreamConfig::FRAME_SIZE;
firmware/v2/src/network/webserver/ws/WsAudioCommands.cpp|P2|data["streamVersion"] = AudioStreamConfig::STREAM_VERSION;
firmware/v2/src/network/webserver/ws/WsBatchCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsBatchCommands.cpp|P1|if (!doc.containsKey("operations") || !doc["operations"].is<JsonArray>()) {
firmware/v2/src/network/webserver/ws/WsBatchCommands.cpp|P2|data["failed"] = failed;
firmware/v2/src/network/webserver/ws/WsBatchCommands.cpp|P2|data["processed"] = processed;
firmware/v2/src/network/webserver/ws/WsColorCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsColorCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsColorCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsColorCommands.cpp|P2|data["active"] = engine.isActive();
firmware/v2/src/network/webserver/ws/WsColorCommands.cpp|P2|data["blendEnabled"] = engine.isCrossBlendEnabled();
firmware/v2/src/network/webserver/ws/WsColorCommands.cpp|P2|data["rotationEnabled"] = engine.isRotationEnabled();
firmware/v2/src/network/webserver/ws/WsDebugCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsDebugCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsDebugCommands.cpp|P1|int verbosity = doc["verbosity"].as<int>();
firmware/v2/src/network/webserver/ws/WsDebugCommands.cpp|P2|data["baseInterval"] = config.baseInterval;
firmware/v2/src/network/webserver/ws/WsDebugCommands.cpp|P2|data["verbosity"] = config.verbosity;
firmware/v2/src/network/webserver/ws/WsDebugCommands.cpp|P2|data["verbosity"] = config.verbosity;
firmware/v2/src/network/webserver/ws/WsDeviceCommands.cpp|P2|data["freeHeap"] = ESP.getFreeHeap();
firmware/v2/src/network/webserver/ws/WsDeviceCommands.cpp|P2|data["heapSize"] = ESP.getHeapSize();
firmware/v2/src/network/webserver/ws/WsDeviceCommands.cpp|P2|data["uptime"] = (millis() - ctx.startTime) / 1000;
firmware/v2/src/network/webserver/ws/WsEffectsCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsEffectsCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsEffectsCommands.cpp|P1|JsonObject params = doc["parameters"].as<JsonObject>();
firmware/v2/src/network/webserver/ws/WsEffectsCommands.cpp|P2|data["family"] = familyName;
firmware/v2/src/network/webserver/ws/WsEffectsCommands.cpp|P2|data["id"] = effectId;
firmware/v2/src/network/webserver/ws/WsEffectsCommands.cpp|P2|data["name"] = ctx.renderer->getEffectName(effectId);
firmware/v2/src/network/webserver/ws/WsMotionCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsMotionCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsMotionCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsMotionCommands.cpp|P2|data["autoRotateSpeed"] = engine.getPhaseController().phaseVelocity;
firmware/v2/src/network/webserver/ws/WsMotionCommands.cpp|P2|data["enabled"] = engine.isEnabled();
firmware/v2/src/network/webserver/ws/WsMotionCommands.cpp|P2|data["phaseOffset"] = engine.getPhaseController().stripPhaseOffset;
firmware/v2/src/network/webserver/ws/WsPaletteCommands.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/ws/WsPaletteCommands.cpp|P1|uint8_t paletteId = doc["paletteId"] | 255;
firmware/v2/src/network/webserver/ws/WsPaletteCommands.cpp|P2|data["category"] = getPaletteCategory(paletteId);
firmware/v2/src/network/webserver/ws/WsPaletteCommands.cpp|P2|data["name"] = MasterPaletteNames[paletteId];
firmware/v2/src/network/webserver/ws/WsPaletteCommands.cpp|P2|data["paletteId"] = paletteId;
firmware/v2/src/network/webserver/WsCommandRouter.cpp|P1|const char* requestId = doc["requestId"] | "";
firmware/v2/src/network/webserver/WsCommandRouter.cpp|P1|String typeStr = doc["type"].as<String>();
firmware/v2/src/network/webserver/WsGateway.cpp|P1|const char* msgType = doc["type"] | "";
firmware/v2/src/network/webserver/WsGateway.cpp|P1|const char* requestId = doc["requestId"] | "";
