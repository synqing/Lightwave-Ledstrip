{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_BREATHING",
  "effectIdHex": "0x010B",
  "className": "BreathingEffect",
  "displayName": "Breathing",
  "headerPath": "firmware/v2/src/effects/ieffect/BreathingEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/BreathingEffect.cpp",
  "renderRange": [
    156,
    178
  ],
  "phaseRanges": {
    "input": [
      [
        156,
        157
      ]
    ],
    "mapping": [
      [
        158,
        161
      ]
    ],
    "modulation": [
      [
        165,
        165
      ]
    ],
    "render": [
      [
        166,
        175
      ]
    ],
    "post": [
      [
        176,
        176
      ]
    ],
    "output": [
      [
        177,
        178
      ]
    ]
  },
  "mappingConfidence": "low",
  "mappingWarnings": [
    "Phase inference used fallback segmentation due to sparse signal.",
    "Phase 'input' inferred from fallback segmentation.",
    "Phase 'mapping' inferred from fallback segmentation.",
    "Phase 'render' inferred from fallback segmentation.",
    "Phase 'post' inferred from fallback segmentation.",
    "Phase 'output' inferred from fallback segmentation."
  ],
  "sourceText": "/**\n * @file BreathingEffect.cpp\n * @brief Bloom-inspired breathing effect using Sensory Bridge architecture\n *\n * REDESIGNED based on Sensory Bridge Bloom mode principles:\n *\n * Core Architecture (Sensory Bridge Pattern):\n * - Audio → Color/Brightness (AUDIO-REACTIVE)\n * - Time → Motion Speed (TIME-BASED, USER-CONTROLLED)\n *\n * Key innovations:\n * 1. Separation of concerns: Audio drives color/brightness, time drives motion\n * 2. Frame persistence: Alpha blending (0.99) creates smooth motion through accumulation\n * 3. Chromatic color: 12-bin chromagram → summed RGB color (musical colors)\n * 4. Multi-stage smoothing: Chromagram (0.75 alpha) + Energy (0.3 alpha)\n * 5. History buffer: 4-frame rolling average filters single-frame spikes\n * 6. Exponential foreshortening: Visual acceleration toward edges\n *\n * This eliminates jittery motion by removing audio→motion coupling.\n */\n\n#include \"BreathingEffect.h\"\n#include \"../CoreEffects.h\"\n#include <FastLED.h>\n#include <cmath>\n\n// Unified logging system\n#define LW_LOG_TAG \"Breathing\"\n#include \"../../utils/Log.h\"\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\n// Slew rates for smooth motion\nstatic constexpr float RADIUS_SLEW = 0.25f;      // ~33ms at 120fps (faster response)\nstatic constexpr float FLUX_BOOST_DECAY = 0.85f; // ~100ms decay\n\n// Exponential foreshortening exponent (Bloom's secret)\n// < 1.0 = acceleration toward edges, 1.0 = linear\nstatic constexpr float FORESHORTEN_EXP = 0.7f;\n\n// Fallback breathing rate when tempo confidence low\nstatic constexpr float FALLBACK_BREATH_RATE = 0.02f;  // ~1.5 second period\n\n// ============================================================================\n// Helper: Compute Chromatic Color from 12-bin Chromagram (Sensory Bridge Pattern)\n// ============================================================================\nstatic CRGB computeChromaticColor(const float chroma[12], const plugins::EffectContext& ctx) {\n    CRGB sum = CRGB::Black;\n    float share = 1.0f / 6.0f;  // Divide brightness among notes (Sensory Bridge uses 1/6.0)\n    \n    for (int i = 0; i < 12; i++) {\n        float prog = i / 12.0f;  // 0.0 to 0.917 (0° to 330°)\n        float brightness = chroma[i] * chroma[i] * share;  // Quadratic contrast (like Sensory Bridge)\n        \n        // Clamp brightness to valid range\n        if (brightness > 1.0f) brightness = 1.0f;\n        \n        // Use palette system (matches WaveformEffect/SnapwaveEffect pattern)\n        uint8_t paletteIdx = (uint8_t)(prog * 255.0f + ctx.gHue);\n        uint8_t brightU8 = (uint8_t)(brightness * 255.0f);\n        // Apply brightness scaling\n        brightU8 = (uint8_t)((brightU8 * ctx.brightness) / 255);\n        CRGB noteColor = ctx.palette.getColor(paletteIdx, brightU8);\n\n        // PRE-SCALE: Prevent white accumulation from 12-bin chromagram sum\n        // With 12 bins at full intensity, worst case is 12 * 255 = 3060\n        // Scale by ~70% (180/255) to leave headroom for accumulation\n        constexpr uint8_t PRE_SCALE = 180;\n        noteColor.r = scale8(noteColor.r, PRE_SCALE);\n        noteColor.g = scale8(noteColor.g, PRE_SCALE);\n        noteColor.b = scale8(noteColor.b, PRE_SCALE);\n\n        // Accumulate color contributions (now with reduced intensity)\n        sum.r = qadd8(sum.r, noteColor.r);\n        sum.g = qadd8(sum.g, noteColor.g);\n        sum.b = qadd8(sum.b, noteColor.b);\n    }\n    \n    // Clamp to valid range (qadd8 already handles overflow, but be safe)\n    if (sum.r > 255) sum.r = 255;\n    if (sum.g > 255) sum.g = 255;\n    if (sum.b > 255) sum.b = 255;\n    \n    return sum;\n}\n\nBreathingEffect::BreathingEffect()\n    : m_currentRadius(0.0f)\n    , m_prevRadius(0.0f)\n    , m_pulseIntensity(0.0f)\n    , m_phase(0.0f)\n    , m_fallbackPhase(0.0f)\n    , m_lastFlux(0.0f)\n    , m_fluxBoost(0.0f)\n    , m_texturePhase(0.0f)\n    , m_energySmoothed(0.0f)\n    , m_radiusTargetSum(0.0f)\n    , m_histIdx(0)\n{\n    // Initialize history buffer\n    for (uint8_t i = 0; i < HISTORY_SIZE; ++i) {\n        m_radiusTargetHist[i] = 0.0f;\n    }\n    \n    // Initialize chromagram smoothing\n    for (uint8_t i = 0; i < 12; ++i) {\n        m_chromaSmoothed[i] = 0.0f;\n    }\n}\n\nbool BreathingEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n\n    // Initialize state\n    m_currentRadius = 0.0f;\n    m_prevRadius = 0.0f;\n    m_pulseIntensity = 0.0f;\n    m_phase = 0.0f;\n    m_fallbackPhase = 0.0f;\n    m_lastFlux = 0.0f;\n    m_fluxBoost = 0.0f;\n    m_texturePhase = 0.0f;\n    m_energySmoothed = 0.0f;\n\n    // Initialize history buffer\n    for (uint8_t i = 0; i < HISTORY_SIZE; ++i) {\n        m_radiusTargetHist[i] = 0.0f;\n    }\n    m_radiusTargetSum = 0.0f;\n    m_histIdx = 0;\n\n    // Initialize chromagram smoothing\n    for (uint8_t i = 0; i < 12; ++i) {\n        m_chromaSmoothed[i] = 0.0f;\n    }\n\n    // Register behaviors this effect supports\n    m_selector.registerBehavior(plugins::VisualBehavior::BREATHE_WITH_DYNAMICS, 2.0f);\n    m_selector.registerBehavior(plugins::VisualBehavior::PULSE_ON_BEAT, 1.5f);\n    m_selector.registerBehavior(plugins::VisualBehavior::TEXTURE_FLOW, 1.0f);\n\n    // Set fallback for when audio unavailable\n    m_selector.setFallbackBehavior(plugins::VisualBehavior::BREATHE_WITH_DYNAMICS);\n\n    // Smooth 400ms transitions between behaviors\n    m_selector.setTransitionTime(400);\n\n    // Reset selector state\n    m_selector.reset();\n\n    return true;\n}\n\nvoid BreathingEffect::render(plugins::EffectContext& ctx) {\n    // Update audio behavior selector\n    m_selector.update(ctx);\n\n    // Get current behavior\n    plugins::VisualBehavior behavior = m_selector.currentBehavior();\n\n    // Dispatch to appropriate render method\n    switch (behavior) {\n        case plugins::VisualBehavior::PULSE_ON_BEAT:\n            renderPulsing(ctx);\n            break;\n\n        case plugins::VisualBehavior::TEXTURE_FLOW:\n            renderTexture(ctx);\n            break;\n\n        case plugins::VisualBehavior::BREATHE_WITH_DYNAMICS:\n        default:\n            renderBreathing(ctx);\n            break;\n    }\n}\n\nvoid BreathingEffect::renderBreathing(plugins::EffectContext& ctx) {\n    // BLOOM_BREATHE: Sensory Bridge Pattern\n    // Audio → Color/Brightness (AUDIO-REACTIVE)\n    // Time → Motion Speed (TIME-BASED, USER-CONTROLLED)\n\n    fadeToBlackBy(ctx.leds, ctx.ledCount, 15);\n\n    // ========================================================================\n    // PHASE 1: TIME-BASED MOTION (User-controlled speed, NOT audio-reactive)\n    // ========================================================================\n    float dt = ctx.getSafeDeltaSeconds();\n    float baseSpeed = ctx.speed / 200.0f;  // User speed parameter (like CONFIG.MOOD)\n    m_phase += baseSpeed * dt;  // Time-based phase accumulation\n    \n    // Generate breathing cycle from phase (sine wave)\n    float timeBasedRadius = (sinf(m_phase) * 0.5f + 0.5f) * (float)HALF_LENGTH * 0.6f;\n\n    // ========================================================================\n    // PHASE 2: AUDIO-REACTIVE COLOR & BRIGHTNESS\n    // ========================================================================\n    CRGB chromaticColor = CRGB::Black;\n    float energyEnvelope = 0.0f;\n    float brightness = 0.0f;\n\n#if FEATURE_AUDIO_SYNC\n    if (ctx.audio.available) {\n        // ====================================================================\n        // Multi-Stage Smoothing Pipeline (Sensory Bridge Pattern)\n        // ====================================================================\n        \n        // Stage 1: Smooth chromagram (0.75 alpha - fast attack/release)\n        for (int i = 0; i < 12; i++) {\n            float alpha = 0.75f;  // Like spectrogram_smooth in Sensory Bridge\n            m_chromaSmoothed[i] = ctx.audio.controlBus.heavy_chroma[i] * alpha + \n                                  m_chromaSmoothed[i] * (1.0f - alpha);\n        }\n        \n        // Stage 2: Smooth energy envelope (0.3 alpha - slower smoothing)\n        float alpha_energy = 0.3f;  // Like magnitudes_normalized_avg in Sensory Bridge\n        m_energySmoothed = ctx.audio.rms() * alpha_energy + \n                           m_energySmoothed * (1.0f - alpha_energy);\n        \n        // ====================================================================\n        // Compute Chromatic Color from Smoothed Chromagram\n        // ====================================================================\n        chromaticColor = computeChromaticColor(m_chromaSmoothed, ctx);\n        \n        // ====================================================================\n        // Compute Energy Envelope for Brightness Modulation\n        // ====================================================================\n        energyEnvelope = m_energySmoothed;\n        brightness = energyEnvelope * energyEnvelope;  // Quadratic contrast (like Sensory Bridge)\n        \n        // Optional: Beat sync - reset phase on beat (optional feature)\n        if (ctx.audio.isOnBeat()) {\n            // Optional: Could reset phase to 0.0f for beat sync, but Sensory Bridge doesn't do this\n            // m_phase = 0.0f;  // Uncomment if beat sync desired\n        }\n    } else\n#endif\n    {\n        // NO AUDIO: Use default color and minimal brightness\n        chromaticColor = ctx.palette.getColor(ctx.gHue, 128);\n        brightness = 0.3f;  // Dim fallback\n    }\n\n    // ========================================================================\n    // PHASE 3: COMBINE MOTION + AUDIO (Audio modulates size, not speed)\n    // ========================================================================\n    // Audio brightness modulates the radius size (0.4-1.0 range)\n    // This creates breathing that expands with music, but motion speed is constant\n    float targetRadius = timeBasedRadius * (0.4f + 0.6f * brightness);\n    targetRadius = fmaxf(0.0f, fminf(targetRadius, (float)HALF_LENGTH));\n\n    // ========================================================================\n    // PHASE 4: ROLLING AVERAGE - Filter single-frame spikes\n    // ========================================================================\n    m_radiusTargetSum -= m_radiusTargetHist[m_histIdx];\n    m_radiusTargetHist[m_histIdx] = targetRadius;\n    m_radiusTargetSum += targetRadius;\n    float avgTargetRadius = m_radiusTargetSum / (float)HISTORY_SIZE;\n    m_histIdx = (m_histIdx + 1) % HISTORY_SIZE;\n\n    // ========================================================================\n    // PHASE 5: FRAME PERSISTENCE (Sensory Bridge Bloom Pattern)\n    // ========================================================================\n    // Alpha blending with previous frame (0.99 alpha = 99% persistence)\n    // This creates smooth motion through frame accumulation, not exponential decay\n    float alpha = 0.99f;  // Like Bloom's draw_sprite() alpha\n    m_currentRadius = m_prevRadius * alpha + avgTargetRadius * (1.0f - alpha);\n    m_prevRadius = m_currentRadius;  // Store for next frame\n\n    // Wrap phase to prevent overflow\n    if (m_phase > 2.0f * 3.14159f * 10.0f) {\n        m_phase -= 2.0f * 3.14159f * 10.0f;\n    }\n\n    // ========================================================================\n    // PHASE 6: RENDERING with Chromatic Color & Energy-Modulated Brightness\n    // ========================================================================\n    if (m_currentRadius > 0.001f) {\n        for (int i = 0; i < STRIP_LENGTH; i++) {\n            float dist = (float)centerPairDistance((uint16_t)i);\n\n            // Only render within current radius\n            if (dist <= m_currentRadius) {\n                // Simple linear falloff (smooth propagation)\n                float intensity = 1.0f - (dist / m_currentRadius) * 0.5f;\n                intensity = fmaxf(0.0f, intensity);\n                \n                // Apply subtle exponential foreshortening for visual depth\n                float normalizedDist = dist / (float)HALF_LENGTH;\n                float foreshortened = powf(normalizedDist, FORESHORTEN_EXP);\n                float expMod = expf(-foreshortened * 1.5f);\n                intensity *= (0.7f + 0.3f * expMod);\n\n                // Apply energy-modulated brightness (audio drives brightness, not motion)\n                float finalBrightness = intensity * brightness;  // brightness from audio energy\n                uint8_t ledBrightness = (uint8_t)(255.0f * finalBrightness);\n\n                // Use chromatic color (from chromagram) instead of palette\n                CRGB color = chromaticColor;\n                \n                // Scale color by brightness\n                color.r = scale8(color.r, ledBrightness);\n                color.g = scale8(color.g, ledBrightness);\n                color.b = scale8(color.b, ledBrightness);\n\n                ctx.leds[i] = color;\n                if (i + STRIP_LENGTH < ctx.ledCount) {\n                    ctx.leds[i + STRIP_LENGTH] = color;\n                }\n            }\n        }\n    }\n    \n    // ========================================================================\n    // PHASE 7: SPATIAL FALLOFF (Quadratic Edge Fade - like Sensory Bridge Bloom)\n    // ========================================================================\n    // Fade outer 32 LEDs using quadratic curve for smooth edge\n    for (uint8_t i = 0; i < 32; i++) {\n        float prog = i / 31.0f;  // 0.0 to 1.0\n        float falloff = prog * prog;  // Quadratic fade (like Bloom mode)\n        \n        // Apply to outer LEDs (from edge inward)\n        uint16_t edgeIdx = STRIP_LENGTH - 1 - i;\n        if (edgeIdx < ctx.ledCount) {\n            ctx.leds[edgeIdx].r = scale8(ctx.leds[edgeIdx].r, (uint8_t)(255.0f * (1.0f - falloff)));\n            ctx.leds[edgeIdx].g = scale8(ctx.leds[edgeIdx].g, (uint8_t)(255.0f * (1.0f - falloff)));\n            ctx.leds[edgeIdx].b = scale8(ctx.leds[edgeIdx].b, (uint8_t)(255.0f * (1.0f - falloff)));\n        }\n    }\n}\n\nvoid BreathingEffect::renderPulsing(plugins::EffectContext& ctx) {\n    // BLOOM_PULSE: Sharp radial expansion on beat with BPM-adaptive decay\n    // Falls back to flux-driven transients when beat tracking unreliable\n\n    fadeToBlackBy(ctx.leds, ctx.ledCount, 30);  // Faster fade for snappy feel\n\n    float decayRate = 0.92f;  // Default: ~200ms decay\n\n#if FEATURE_AUDIO_SYNC\n    if (ctx.audio.available) {\n        float tempoConf = ctx.audio.tempoConfidence();\n\n        if (tempoConf > 0.4f) {\n            // RELIABLE BEAT TRACKING: BPM-adaptive decay\n            // Clamp to 60-180 BPM to prevent wild decay rates from jitter\n            float bpm = ctx.audio.bpm();\n            if (bpm < 60.0f) bpm = 60.0f;   // Floor: prevents very slow decay\n            if (bpm > 180.0f) bpm = 180.0f; // Cap: prevents very fast decay\n\n            // Decay should reach ~20% by next beat\n            float beatPeriodFrames = (60.0f / bpm) * 120.0f;\n            decayRate = powf(0.2f, 1.0f / beatPeriodFrames);\n\n            // Trigger pulse on beat, weighted by beat strength\n            if (m_selector.isOnBeat()) {\n                float strength = ctx.audio.beatStrength();\n                m_pulseIntensity = fmaxf(m_pulseIntensity, strength);\n            }\n\n            // Stronger pulse on downbeat\n            if (ctx.audio.isOnDownbeat()) {\n                m_pulseIntensity = 1.0f;\n            }\n        } else {\n            // UNRELIABLE BEAT: Use flux for transient detection\n            float flux = ctx.audio.flux();\n            float fluxDelta = flux - m_lastFlux;\n\n            // Rising flux above threshold triggers pulse\n            if (fluxDelta > 0.12f && flux > 0.2f) {\n                m_pulseIntensity = fmaxf(m_pulseIntensity, fminf(flux * 1.5f, 1.0f));\n            }\n\n            m_lastFlux = flux;\n        }\n    }\n#endif\n\n    // Apply decay\n    m_pulseIntensity *= decayRate;\n    if (m_pulseIntensity < 0.01f) m_pulseIntensity = 0.0f;\n\n    // Compute effective radius from pulse\n    float pulseRadius = m_pulseIntensity * (float)HALF_LENGTH;\n\n    // Render with exponential foreshortening\n    if (pulseRadius > 1.0f) {\n        for (int i = 0; i < STRIP_LENGTH; i++) {\n            float dist = (float)centerPairDistance((uint16_t)i);\n            float normalizedDist = dist / (float)HALF_LENGTH;\n\n            // Exponential foreshortening: acceleration toward edges\n            float foreshortened = powf(normalizedDist, FORESHORTEN_EXP);\n\n            // Sharp exponential falloff for punchy pulse\n            float intensity = m_pulseIntensity * expf(-foreshortened * 4.0f);\n\n            // Quadratic intensity curve for extra punch\n            intensity = intensity * intensity;\n\n            if (dist <= pulseRadius * 1.5f && intensity > 0.01f) {\n                uint8_t brightness = (uint8_t)(255.0f * intensity);\n\n                // Warmer color on pulse (shift toward red)\n                uint8_t hueOffset = (uint8_t)(20.0f * m_pulseIntensity);\n\n                CRGB color = ctx.palette.getColor(\n                    ctx.gHue + hueOffset,\n                    brightness\n                );\n\n                ctx.leds[i] = color;\n                if (i + STRIP_LENGTH < ctx.ledCount) {\n                    ctx.leds[i + STRIP_LENGTH] = color;\n                }\n            }\n        }\n    }\n\n    // Keep fallback phase moving for smooth transition back (dt-corrected)\n    float dtFallback = ctx.getSafeDeltaSeconds();\n    m_fallbackPhase += ctx.speed / 300.0f * 60.0f * dtFallback;\n    if (m_fallbackPhase > 2.0f * 3.14159f * 10.0f) {\n        m_fallbackPhase -= 2.0f * 3.14159f * 10.0f;\n    }\n}\n\nvoid BreathingEffect::renderTexture(plugins::EffectContext& ctx) {\n    // BLOOM_TEXTURE: Slow organic drift with audio-modulated amplitude\n    // Motion is TIME-BASED (Sensory Bridge pattern), audio→amplitude only\n\n    fadeToBlackBy(ctx.leds, ctx.ledCount, 8);  // Slow fade for dreamy feel\n\n    // Audio-modulated wave AMPLITUDE parameters (not speed!)\n    float timbralMod = 0.5f;   // Default if no audio\n    float fluxMod = 0.3f;\n    float rhythmMod = 0.5f;\n\n#if FEATURE_AUDIO_SYNC\n    if (ctx.audio.available) {\n        // Timbral saliency modulates wave amplitude (high-freq content → more texture)\n        timbralMod = 0.3f + 0.5f * ctx.audio.timbralSaliency();\n\n        // Flux modulates secondary wave amplitude (spectral change → wave strength)\n        fluxMod = 0.2f + 0.4f * ctx.audio.flux();\n\n        // Rhythmic saliency modulates primary wave amplitude (NOT speed!)\n        rhythmMod = 0.5f + ctx.audio.rhythmicSaliency();\n\n        // RMS provides baseline brightness modulation\n        float rms = ctx.audio.rms();\n        timbralMod *= 0.6f + 0.4f * rms;\n    }\n#endif\n\n    // Speed is TIME-BASED only (Sensory Bridge pattern - no audio→speed coupling)\n    float driftSpeed = ctx.speed / 500.0f;\n    // REMOVED: driftSpeed *= rhythmMod;  // This was audio→speed coupling!\n\n    // Multiple overlapping waves - rhythmMod now affects amplitude, not speed\n    float wave1 = sinf(m_texturePhase) * timbralMod * rhythmMod;  // rhythmMod here\n    float wave2 = sinf(m_texturePhase * 1.3f + 1.0f) * fluxMod;\n    float wave3 = sinf(m_texturePhase * 0.7f + 2.0f) * 0.2f;\n\n    float combinedWave = (wave1 + wave2 + wave3) / 3.0f + 0.5f;\n    float waveRadius = combinedWave * (float)HALF_LENGTH * 0.7f;\n\n    // Render with exponential foreshortening\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float dist = (float)centerPairDistance((uint16_t)i);\n        float normalizedDist = dist / (float)HALF_LENGTH;\n\n        // Exponential foreshortening\n        float foreshortened = powf(normalizedDist, FORESHORTEN_EXP);\n\n        // Soft gaussian-like falloff\n        float intensity = expf(-foreshortened * foreshortened * 2.0f);\n\n        // Modulate by wave position\n        float waveInfluence = 1.0f - fabsf(dist - waveRadius) / 25.0f;\n        waveInfluence = fmaxf(0.0f, waveInfluence);\n        intensity = intensity * 0.5f + waveInfluence * 0.5f;\n\n        // Apply combined wave and timbral modulation\n        intensity *= combinedWave;\n        intensity *= timbralMod;\n\n        uint8_t brightness = (uint8_t)(200.0f * intensity);\n\n        if (brightness > 10) {\n            // Cooler colors for texture (blue-green shift)\n            uint8_t hueOffset = (uint8_t)(dist * 0.5f);\n            CRGB color = ctx.palette.getColor(\n                ctx.gHue + 128 + hueOffset,\n                brightness\n            );\n\n            ctx.leds[i] = color;\n            if (i + STRIP_LENGTH < ctx.ledCount) {\n                ctx.leds[i + STRIP_LENGTH] = color;\n            }\n        }\n    }\n\n    // Update texture phase\n    m_texturePhase += driftSpeed;\n    if (m_texturePhase > 2.0f * 3.14159f * 10.0f) {\n        m_texturePhase -= 2.0f * 3.14159f * 10.0f;\n    }\n\n    // Keep fallback phase synced for smooth transitions\n    m_fallbackPhase = combinedWave * 2.0f * 3.14159f;\n}\n\nvoid BreathingEffect::cleanup() {\n    // No resources to free\n}\n\nconst plugins::EffectMetadata& BreathingEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Breathing\",\n        \"Bloom-inspired radial expansion with robust audio reactivity\",\n        plugins::EffectCategory::AMBIENT,\n        1\n    };\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
