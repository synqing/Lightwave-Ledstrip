{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_BREATHING_ENHANCED",
  "effectIdHex": "0x0E01",
  "className": "BreathingEnhancedEffect",
  "displayName": "Breathing Enhanced",
  "headerPath": "firmware/v2/src/effects/ieffect/BreathingEnhancedEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/BreathingEnhancedEffect.cpp",
  "renderRange": [
    103,
    321
  ],
  "phaseRanges": {
    "input": [
      [
        123,
        123
      ],
      [
        126,
        127
      ],
      [
        134,
        134
      ],
      [
        179,
        179
      ],
      [
        183,
        183
      ],
      [
        185,
        185
      ],
      [
        189,
        189
      ],
      [
        191,
        191
      ],
      [
        198,
        198
      ],
      [
        221,
        221
      ]
    ],
    "mapping": [
      [
        140,
        140
      ],
      [
        142,
        143
      ],
      [
        181,
        181
      ],
      [
        187,
        187
      ],
      [
        189,
        189
      ],
      [
        191,
        191
      ],
      [
        200,
        200
      ],
      [
        206,
        206
      ],
      [
        210,
        211
      ],
      [
        248,
        249
      ],
      [
        254,
        257
      ],
      [
        264,
        264
      ],
      [
        286,
        287
      ]
    ],
    "modulation": [
      [
        109,
        109
      ],
      [
        114,
        114
      ],
      [
        116,
        116
      ],
      [
        119,
        119
      ],
      [
        127,
        127
      ],
      [
        135,
        136
      ],
      [
        138,
        138
      ],
      [
        140,
        140
      ],
      [
        143,
        145
      ],
      [
        147,
        147
      ],
      [
        150,
        151
      ],
      [
        154,
        156
      ],
      [
        159,
        160
      ],
      [
        163,
        164
      ],
      [
        167,
        168
      ],
      [
        171,
        171
      ],
      [
        203,
        203
      ],
      [
        205,
        205
      ],
      [
        209,
        210
      ],
      [
        214,
        214
      ],
      [
        216,
        217
      ],
      [
        246,
        246
      ],
      [
        252,
        252
      ],
      [
        261,
        261
      ],
      [
        263,
        264
      ],
      [
        267,
        269
      ],
      [
        271,
        272
      ],
      [
        276,
        276
      ],
      [
        308,
        308
      ]
    ],
    "render": [
      [
        106,
        106
      ],
      [
        155,
        156
      ],
      [
        188,
        188
      ],
      [
        197,
        197
      ],
      [
        204,
        204
      ],
      [
        240,
        240
      ],
      [
        276,
        276
      ],
      [
        279,
        279
      ],
      [
        299,
        299
      ],
      [
        301,
        301
      ],
      [
        310,
        310
      ],
      [
        316,
        318
      ]
    ],
    "post": [
      [
        106,
        106
      ],
      [
        114,
        114
      ],
      [
        138,
        138
      ],
      [
        147,
        147
      ],
      [
        154,
        154
      ],
      [
        261,
        261
      ],
      [
        308,
        308
      ],
      [
        312,
        312
      ]
    ],
    "output": [
      [
        279,
        279
      ],
      [
        299,
        301
      ],
      [
        314,
        314
      ],
      [
        316,
        318
      ]
    ]
  },
  "mappingConfidence": "high",
  "mappingWarnings": [],
  "sourceText": "/**\n * @file BreathingEnhancedEffect.cpp\n * @brief Breathing Enhanced - Enhanced version with 64-bin sub-bass, beatPhase sync, snare triggers\n */\n\n#include \"BreathingEnhancedEffect.h\"\n#include \"../CoreEffects.h\"\n#include <FastLED.h>\n#include <cmath>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\n// Exponential foreshortening exponent (Bloom's secret)\nstatic constexpr float FORESHORTEN_EXP = 0.7f;\n\n// Helper: Compute Chromatic Color from 12-bin Chromagram\nstatic CRGB computeChromaticColor(const float chroma[12], const plugins::EffectContext& ctx) {\n    CRGB sum = CRGB::Black;\n    float share = 1.0f / 6.0f;\n    \n    for (int i = 0; i < 12; i++) {\n        float prog = i / 12.0f;\n        float brightness = sqrtf(chroma[i]) * share * 2.0f;  // Sqrt boost for visibility\n        if (brightness > 1.0f) brightness = 1.0f;\n        \n        uint8_t paletteIdx = (uint8_t)(prog * 255.0f + ctx.gHue);\n        uint8_t brightU8 = (uint8_t)(brightness * 255.0f);\n        brightU8 = (uint8_t)((brightU8 * ctx.brightness) / 255);\n        CRGB noteColor = ctx.palette.getColor(paletteIdx, brightU8);\n\n        constexpr uint8_t PRE_SCALE = 180;\n        noteColor.r = scale8(noteColor.r, PRE_SCALE);\n        noteColor.g = scale8(noteColor.g, PRE_SCALE);\n        noteColor.b = scale8(noteColor.b, PRE_SCALE);\n\n        sum.r = qadd8(sum.r, noteColor.r);\n        sum.g = qadd8(sum.g, noteColor.g);\n        sum.b = qadd8(sum.b, noteColor.b);\n    }\n    \n    if (sum.r > 255) sum.r = 255;\n    if (sum.g > 255) sum.g = 255;\n    if (sum.b > 255) sum.b = 255;\n    \n    return sum;\n}\n\nBreathingEnhancedEffect::BreathingEnhancedEffect()\n    : m_currentRadius(0.0f)\n    , m_prevRadius(0.0f)\n    , m_pulseIntensity(0.0f)\n    , m_phase(0.0f)\n    , m_fallbackPhase(0.0f)\n    , m_energySmoothed(0.0f)\n    , m_radiusTargetSum(0.0f)\n    , m_histIdx(0)\n{\n    for (uint8_t i = 0; i < HISTORY_SIZE; ++i) {\n        m_radiusTargetHist[i] = 0.0f;\n    }\n    for (uint8_t i = 0; i < 12; ++i) {\n        m_chromaSmoothed[i] = 0.0f;\n    }\n}\n\nbool BreathingEnhancedEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n\n    m_currentRadius = 0.0f;\n    m_prevRadius = 0.0f;\n    m_pulseIntensity = 0.0f;\n    m_phase = 0.0f;\n    m_fallbackPhase = 0.0f;\n    m_energySmoothed = 0.0f;\n    \n    m_rmsFollower.reset(0.0f);\n    m_subBassFollower.reset(0.0f);\n    for (int i = 0; i < 12; i++) {\n        m_chromaFollowers[i].reset(0.0f);\n        m_chromaTargets[i] = 0.0f;\n    }\n    m_lastHopSeq = 0;\n    m_targetRms = 0.0f;\n    m_targetSubBass = 0.0f;\n\n    for (uint8_t i = 0; i < HISTORY_SIZE; ++i) {\n        m_radiusTargetHist[i] = 0.0f;\n    }\n    m_radiusTargetSum = 0.0f;\n    m_histIdx = 0;\n\n    for (uint8_t i = 0; i < 12; ++i) {\n        m_chromaSmoothed[i] = 0.0f;\n    }\n    \n    m_tempoLocked = false;\n\n    return true;\n}\n\nvoid BreathingEnhancedEffect::render(plugins::EffectContext& ctx) {\n    // Enhanced Breathing: Audio → Color/Brightness, Time → Motion Speed\n\n    fadeToBlackBy(ctx.leds, ctx.ledCount, ctx.fadeAmount);\n\n    // ========================================================================\n    // PHASE 1: TIME-BASED MOTION (User-controlled speed, NOT audio-reactive)\n    // ========================================================================\n    float dt = ctx.getSafeDeltaSeconds();\n    float baseSpeed = ctx.speed / 200.0f;\n    \n    // Enhanced: Use beatPhase for sync when tempo confidence high (PLL-style correction)\n    float tempoConf = 0.0f;\n    float beatPhase = 0.0f;\n#if FEATURE_AUDIO_SYNC\n    // Domain constants (2*PI domain for BreathingEnhanced)\n    const float PHASE_DOMAIN = 2.0f * 3.14159f;  // 2*PI\n    const float HALF_DOMAIN = 3.14159f;          // PI\n\n    // Tempo lock hysteresis (Schmitt trigger: prevents chatter near threshold)\n    if (!ctx.audio.available) {\n        m_tempoLocked = false;  // Clear lock when audio drops (prevents ghost lock)\n    } else {\n        tempoConf = ctx.audio.tempoConfidence();\n        beatPhase = ctx.audio.beatPhase();\n        \n        // Update lock state with hysteresis (0.6 lock / 0.4 unlock)\n        if (tempoConf > 0.6f) m_tempoLocked = true;\n        else if (tempoConf < 0.4f) m_tempoLocked = false;\n    }\n\n    if (ctx.audio.available) {\n        // Always advance phase (free-run oscillator)\n        m_phase += baseSpeed * dt;\n        \n        // Apply phase correction when tempo-locked (PLL-style P-only correction)\n        if (m_tempoLocked) {\n            float targetPhase = beatPhase * PHASE_DOMAIN;\n            \n            // Compute wrapped error (shortest path to target)\n            float phaseError = targetPhase - m_phase;\n            if (phaseError > HALF_DOMAIN) phaseError -= PHASE_DOMAIN;\n            if (phaseError < -HALF_DOMAIN) phaseError += PHASE_DOMAIN;\n            \n            // Proportional correction (tau ~100ms gives smooth lock)\n            // Compute ONCE per frame, not per pixel\n            const float tau = 0.1f;\n            const float correctionAlpha = 1.0f - expf(-dt / tau);\n            m_phase += phaseError * correctionAlpha;\n        }\n        \n        // CRITICAL: Wrap phase AFTER correction (handles negative and overflow)\n        while (m_phase >= PHASE_DOMAIN) m_phase -= PHASE_DOMAIN;\n        while (m_phase < 0.0f) m_phase += PHASE_DOMAIN;\n    } else {\n        // No audio: fallback slow animation\n        m_fallbackPhase += baseSpeed * 0.3f * dt;\n        m_phase = m_fallbackPhase;\n    }\n#else\n    m_fallbackPhase += baseSpeed * 0.3f * dt;\n    m_phase = m_fallbackPhase;\n#endif\n    \n    // Generate breathing cycle from phase (sine wave)\n    float timeBasedRadius = (sinf(m_phase) * 0.5f + 0.5f) * (float)HALF_LENGTH * 0.6f;\n\n    // ========================================================================\n    // PHASE 2: AUDIO-REACTIVE COLOR & BRIGHTNESS (Enhanced)\n    // ========================================================================\n    CRGB chromaticColor = CRGB::Black;\n    float energyEnvelope = 0.0f;\n    float brightness = 0.0f;\n    float subBassEnergy = 0.0f;\n\n#if FEATURE_AUDIO_SYNC\n    if (ctx.audio.available) {\n        float rawDt = ctx.getSafeRawDeltaSeconds();\n        float moodNorm = ctx.getMoodNormalized();\n        \n        bool newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n        if (newHop) {\n            m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n            \n            // Update chromagram targets (use heavy_chroma for stability)\n            for (int i = 0; i < 12; i++) {\n                m_chromaTargets[i] = ctx.audio.controlBus.heavy_chroma[i];\n            }\n            m_targetRms = ctx.audio.rms();\n            \n            // =================================================================\n            // 64-bin Sub-Bass Detection (bins 0-5 = ~110-155 Hz)\n            // =================================================================\n            float subBassSum = 0.0f;\n            for (uint8_t i = 0; i < 6; ++i) {\n                subBassSum += ctx.audio.bin(i);\n            }\n            m_targetSubBass = subBassSum / 6.0f;\n        }\n        \n        // Smooth chromagram with AsymmetricFollower\n        for (int i = 0; i < 12; i++) {\n            m_chromaSmoothed[i] = m_chromaFollowers[i].updateWithMood(\n                m_chromaTargets[i], rawDt, moodNorm);\n        }\n        \n        // Smooth energy envelope\n        m_energySmoothed = m_rmsFollower.updateWithMood(m_targetRms, rawDt, moodNorm);\n        subBassEnergy = m_subBassFollower.updateWithMood(m_targetSubBass, rawDt, moodNorm);\n        \n        // Compute Chromatic Color\n        chromaticColor = computeChromaticColor(m_chromaSmoothed, ctx);\n        \n        // Compute Energy Envelope for Brightness Modulation\n        energyEnvelope = m_energySmoothed;\n        brightness = sqrtf(energyEnvelope) * 1.5f;  // Sqrt boost for visibility\n        \n        // Enhanced: Snare hit triggers sharp pulse\n        if (ctx.audio.isSnareHit()) {\n            m_pulseIntensity = 1.0f;\n        }\n        \n        // Enhanced: Sub-bass boosts pulse intensity\n        if (subBassEnergy > 0.15f) {  // Lower threshold for sensitivity\n            m_pulseIntensity = fmaxf(m_pulseIntensity, subBassEnergy * 0.8f);\n        }\n        \n        // Decay pulse intensity (dt-corrected)\n        m_pulseIntensity *= powf(0.92f, rawDt * 60.0f);\n        if (m_pulseIntensity < 0.01f) m_pulseIntensity = 0.0f;\n        \n        // Boost brightness with pulse\n        brightness = fminf(1.0f, brightness + m_pulseIntensity * 0.3f);\n    } else\n#endif\n    {\n        // NO AUDIO: Use default color and minimal brightness\n        chromaticColor = ctx.palette.getColor(ctx.gHue, 128);\n        brightness = 0.3f;\n        m_pulseIntensity = 0.0f;\n    }\n\n    // ========================================================================\n    // PHASE 3: COMBINE MOTION + AUDIO (Audio modulates size, not speed)\n    // ========================================================================\n    float targetRadius = timeBasedRadius * (0.4f + 0.6f * brightness);\n    targetRadius = fmaxf(0.0f, fminf(targetRadius, (float)HALF_LENGTH));\n\n    // ========================================================================\n    // PHASE 4: ROLLING AVERAGE - Filter single-frame spikes\n    // ========================================================================\n    m_radiusTargetSum -= m_radiusTargetHist[m_histIdx];\n    m_radiusTargetHist[m_histIdx] = targetRadius;\n    m_radiusTargetSum += targetRadius;\n    float avgTargetRadius = m_radiusTargetSum / (float)HISTORY_SIZE;\n    m_histIdx = (m_histIdx + 1) % HISTORY_SIZE;\n\n    // ========================================================================\n    // PHASE 5: FRAME PERSISTENCE (Sensory Bridge Bloom Pattern)\n    // ========================================================================\n    float alpha = 0.99f;\n    m_currentRadius = m_prevRadius * alpha + avgTargetRadius * (1.0f - alpha);\n    m_prevRadius = m_currentRadius;\n\n    // Wrap phase to prevent overflow\n    if (m_phase > 2.0f * 3.14159f * 10.0f) {\n        m_phase -= 2.0f * 3.14159f * 10.0f;\n    }\n    if (m_fallbackPhase > 2.0f * 3.14159f * 10.0f) {\n        m_fallbackPhase -= 2.0f * 3.14159f * 10.0f;\n    }\n\n    // ========================================================================\n    // PHASE 6: RENDERING with Chromatic Color & Energy-Modulated Brightness\n    // ========================================================================\n    if (m_currentRadius > 0.0001f) {  // Lower threshold for visibility\n        for (int i = 0; i < STRIP_LENGTH; i++) {\n            float dist = (float)centerPairDistance((uint16_t)i);\n\n            if (dist <= m_currentRadius) {\n                float intensity = 1.0f - (dist / m_currentRadius) * 0.5f;\n                intensity = fmaxf(0.0f, intensity);\n                \n                float normalizedDist = dist / (float)HALF_LENGTH;\n                float foreshortened = powf(normalizedDist, FORESHORTEN_EXP);\n                float expMod = expf(-foreshortened * 1.5f);\n                intensity *= (0.7f + 0.3f * expMod);\n\n                float finalBrightness = intensity * brightness;\n                uint8_t ledBrightness = (uint8_t)(255.0f * finalBrightness);\n\n                CRGB color = chromaticColor;\n                color.r = scale8(color.r, ledBrightness);\n                color.g = scale8(color.g, ledBrightness);\n                color.b = scale8(color.b, ledBrightness);\n\n                ctx.leds[i] = color;\n                if (i + STRIP_LENGTH < ctx.ledCount) {\n                    ctx.leds[i + STRIP_LENGTH] = color;\n                }\n            }\n        }\n    }\n    \n    // ========================================================================\n    // PHASE 7: SPATIAL FALLOFF (Quadratic Edge Fade)\n    // ========================================================================\n    for (uint8_t i = 0; i < 32; i++) {\n        float prog = i / 31.0f;\n        float falloff = prog * 0.7f;  // Linear fade (was quadratic)\n        \n        uint16_t edgeIdx = STRIP_LENGTH - 1 - i;\n        if (edgeIdx < ctx.ledCount) {\n            ctx.leds[edgeIdx].r = scale8(ctx.leds[edgeIdx].r, (uint8_t)(255.0f * (1.0f - falloff)));\n            ctx.leds[edgeIdx].g = scale8(ctx.leds[edgeIdx].g, (uint8_t)(255.0f * (1.0f - falloff)));\n            ctx.leds[edgeIdx].b = scale8(ctx.leds[edgeIdx].b, (uint8_t)(255.0f * (1.0f - falloff)));\n        }\n    }\n}\n\nvoid BreathingEnhancedEffect::cleanup() {\n    // No resources to free\n}\n\nconst plugins::EffectMetadata& BreathingEnhancedEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Breathing Enhanced\",\n        \"Enhanced: 64-bin sub-bass, beatPhase sync, snare triggers\",\n        plugins::EffectCategory::AMBIENT,\n        1\n    };\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n\n"
}
