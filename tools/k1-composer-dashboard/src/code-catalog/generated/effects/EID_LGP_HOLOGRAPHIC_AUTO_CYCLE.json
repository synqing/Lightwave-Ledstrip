{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_LGP_HOLOGRAPHIC_AUTO_CYCLE",
  "effectIdHex": "0x1000",
  "className": "LGPHolographicAutoCycleEffect",
  "displayName": "LGP Holo Auto-Cycle",
  "headerPath": "firmware/v2/src/effects/ieffect/LGPHolographicAutoCycleEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/LGPHolographicAutoCycleEffect.cpp",
  "renderRange": [
    71,
    139
  ],
  "phaseRanges": {
    "input": [
      [
        71,
        78
      ]
    ],
    "mapping": [
      [
        73,
        74
      ],
      [
        76,
        78
      ],
      [
        91,
        91
      ],
      [
        94,
        94
      ],
      [
        119,
        119
      ],
      [
        123,
        123
      ]
    ],
    "modulation": [
      [
        72,
        72
      ],
      [
        76,
        78
      ],
      [
        81,
        82
      ],
      [
        108,
        108
      ],
      [
        111,
        111
      ],
      [
        114,
        114
      ],
      [
        117,
        117
      ]
    ],
    "render": [
      [
        86,
        86
      ],
      [
        89,
        89
      ],
      [
        91,
        91
      ],
      [
        93,
        94
      ],
      [
        99,
        99
      ],
      [
        102,
        102
      ],
      [
        126,
        127
      ],
      [
        129,
        131
      ],
      [
        134,
        135
      ]
    ],
    "post": [
      [
        89,
        89
      ]
    ],
    "output": [
      [
        102,
        102
      ],
      [
        130,
        130
      ],
      [
        133,
        134
      ]
    ]
  },
  "mappingConfidence": "medium",
  "mappingWarnings": [
    "Phase 'input' inferred from fallback segmentation."
  ],
  "sourceText": "/**\n * @file LGPHolographicAutoCycleEffect.cpp\n * @brief LGP Holographic Auto-Cycle effect implementation\n *\n * Rendering math is identical to LGPHolographicEffect.cpp.\n * The key difference is internal palette management with auto-cycling.\n */\n\n#include \"LGPHolographicAutoCycleEffect.h\"\n#include \"../CoreEffects.h\"\n#include \"../../palettes/Palettes_Master.h\"\n#include <FastLED.h>\n#include <cmath>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\n// The 20 hand-selected palette IDs (source of truth, never mutated)\nstatic constexpr uint8_t PALETTE_IDS[LGPHolographicAutoCycleEffect::PLAYLIST_SIZE] = {\n     0,  1, 10, 11, 12, 13, 15, 16, 17, 18,\n    20, 23, 25, 31, 33, 36, 43, 44, 57, 61\n};\n\nstatic constexpr float TWO_PI_F = 6.283185307f;\n\n// ---------------------------------------------------------------------------\n// Construction\n// ---------------------------------------------------------------------------\n\nLGPHolographicAutoCycleEffect::LGPHolographicAutoCycleEffect()\n    : m_phase1(0.0f)\n    , m_phase2(0.0f)\n    , m_phase3(0.0f)\n    , m_activePalette()\n    , m_targetPalette()\n    , m_lastCycleCount(0)\n    , m_playlistIndex(0)\n    , m_isTransitioning(false)\n{\n    memcpy(m_playlist, PALETTE_IDS, PLAYLIST_SIZE);\n}\n\n// ---------------------------------------------------------------------------\n// Lifecycle\n// ---------------------------------------------------------------------------\n\nbool LGPHolographicAutoCycleEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n\n    // Reset rendering phases\n    m_phase1 = 0.0f;\n    m_phase2 = 0.0f;\n    m_phase3 = 0.0f;\n\n    // Reset cycle tracking\n    m_lastCycleCount = 0;\n\n    // Shuffle and start from first palette\n    shufflePlaylist();\n    m_playlistIndex = 0;\n\n    // Load first palette as both active and target (no transition on start)\n    loadPaletteFromId(m_playlist[0], m_activePalette);\n    m_targetPalette = m_activePalette;\n    m_isTransitioning = false;\n\n    return true;\n}\n\nvoid LGPHolographicAutoCycleEffect::render(plugins::EffectContext& ctx) {\n    // ===== Phase advancement (identical to LGPHolographicEffect) =====\n    float speedNorm = ctx.speed / 50.0f;\n    float intensityNorm = ctx.brightness / 255.0f;\n\n    m_phase1 += speedNorm * 0.02f;\n    m_phase2 += speedNorm * 0.03f;\n    m_phase3 += speedNorm * 0.05f;\n\n    // ===== Cycle detection =====\n    // A \"cycle\" is one full 2*PI rotation of m_phase1\n    int32_t currentCycleCount = (int32_t)floorf(m_phase1 / TWO_PI_F);\n\n    if (currentCycleCount > m_lastCycleCount) {\n        m_lastCycleCount = currentCycleCount;\n        advancePalette();\n    }\n\n    // ===== Palette crossfade =====\n    if (m_isTransitioning) {\n        nblendPaletteTowardPalette(m_activePalette, m_targetPalette, 24);\n\n        // Check convergence: all 16 palette entries must match\n        if (m_activePalette == m_targetPalette) {\n            m_isTransitioning = false;\n        }\n    }\n\n    // ===== LED rendering (identical math to LGPHolographicEffect) =====\n    const int numLayers = 4;\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float dist = (float)centerPairDistance((uint16_t)i);\n\n        float layerSum = 0.0f;\n\n        // Layer 1 - Slow, wide pattern\n        layerSum += sinf(dist * 0.05f + m_phase1);\n\n        // Layer 2 - Medium pattern\n        layerSum += sinf(dist * 0.15f + m_phase2) * 0.7f;\n\n        // Layer 3 - Fast, tight pattern\n        layerSum += sinf(dist * 0.3f + m_phase3) * 0.5f;\n\n        // Layer 4 - Very fast shimmer\n        layerSum += sinf(dist * 0.6f - m_phase1 * 3.0f) * 0.3f;\n\n        // Normalize\n        layerSum = layerSum / (float)numLayers;\n        layerSum = tanhf(layerSum);\n\n        uint8_t brightness = (uint8_t)(128.0f + 127.0f * layerSum * intensityNorm);\n\n        // Chromatic dispersion effect\n        uint8_t paletteIndex1 = (uint8_t)((dist * 0.5f) + (layerSum * 20.0f));\n        int paletteIndex2 = (int)(128.0f - (dist * 0.5f) - (layerSum * 20.0f));\n\n        // Use internal auto-cycled palette instead of ctx.palette\n        ctx.leds[i] = ColorFromPalette(m_activePalette,\n                                       (uint8_t)(ctx.gHue + paletteIndex1),\n                                       brightness, LINEARBLEND);\n        if (i + STRIP_LENGTH < ctx.ledCount) {\n            ctx.leds[i + STRIP_LENGTH] = ColorFromPalette(m_activePalette,\n                                                          (uint8_t)(ctx.gHue + (uint8_t)paletteIndex2),\n                                                          brightness, LINEARBLEND);\n        }\n    }\n}\n\nvoid LGPHolographicAutoCycleEffect::cleanup() {\n    // No dynamic resources to free\n}\n\nconst plugins::EffectMetadata& LGPHolographicAutoCycleEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Holo Auto-Cycle\",\n        \"Holographic interference with auto-cycling palettes\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------------------------------------\n// Internal: Palette Management\n// ---------------------------------------------------------------------------\n\nvoid LGPHolographicAutoCycleEffect::shufflePlaylist() {\n    // Reset playlist from source IDs\n    memcpy(m_playlist, PALETTE_IDS, PLAYLIST_SIZE);\n\n    // Fisher-Yates shuffle using FastLED's random8()\n    for (uint8_t i = PLAYLIST_SIZE - 1; i > 0; i--) {\n        uint8_t j = random8(i + 1);  // random in [0, i]\n        uint8_t tmp = m_playlist[i];\n        m_playlist[i] = m_playlist[j];\n        m_playlist[j] = tmp;\n    }\n}\n\nvoid LGPHolographicAutoCycleEffect::advancePalette() {\n    m_playlistIndex++;\n\n    // If we've exhausted the playlist, reshuffle\n    if (m_playlistIndex >= PLAYLIST_SIZE) {\n        // Save last palette ID to avoid immediate repeat after reshuffle\n        uint8_t lastPaletteId = m_playlist[PLAYLIST_SIZE - 1];\n\n        shufflePlaylist();\n        m_playlistIndex = 0;\n\n        // If first palette after shuffle matches last before shuffle, swap to avoid repeat\n        if (m_playlist[0] == lastPaletteId && PLAYLIST_SIZE > 1) {\n            uint8_t swapIdx = 1 + random8(PLAYLIST_SIZE - 1);\n            uint8_t tmp = m_playlist[0];\n            m_playlist[0] = m_playlist[swapIdx];\n            m_playlist[swapIdx] = tmp;\n        }\n    }\n\n    // Load the new target palette and begin crossfade\n    loadPaletteFromId(m_playlist[m_playlistIndex], m_targetPalette);\n    m_isTransitioning = true;\n}\n\nvoid LGPHolographicAutoCycleEffect::loadPaletteFromId(uint8_t paletteId, CRGBPalette16& dest) {\n    uint8_t safeId = palettes::validatePaletteId(paletteId);\n    dest = palettes::gMasterPalettes[safeId];\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
