{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_LGP_STAR_BURST_ENHANCED",
  "effectIdHex": "0x0E07",
  "className": "LGPStarBurstEnhancedEffect",
  "displayName": "LGP Star Burst Enhanced",
  "headerPath": "firmware/v2/src/effects/ieffect/LGPStarBurstEffectEnhanced.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/LGPStarBurstEffectEnhanced.cpp",
  "renderRange": [
    57,
    243
  ],
  "phaseRanges": {
    "input": [
      [
        61,
        61
      ],
      [
        64,
        64
      ],
      [
        68,
        68
      ],
      [
        70,
        70
      ],
      [
        74,
        74
      ],
      [
        78,
        78
      ],
      [
        85,
        85
      ],
      [
        109,
        109
      ],
      [
        118,
        118
      ],
      [
        126,
        126
      ],
      [
        147,
        147
      ],
      [
        159,
        159
      ]
    ],
    "mapping": [
      [
        59,
        60
      ],
      [
        72,
        72
      ],
      [
        74,
        74
      ],
      [
        87,
        87
      ],
      [
        97,
        97
      ],
      [
        103,
        103
      ],
      [
        106,
        106
      ],
      [
        133,
        134
      ],
      [
        155,
        155
      ],
      [
        160,
        160
      ],
      [
        162,
        163
      ],
      [
        199,
        199
      ],
      [
        234,
        234
      ]
    ],
    "modulation": [
      [
        93,
        93
      ],
      [
        99,
        99
      ],
      [
        102,
        102
      ],
      [
        105,
        105
      ],
      [
        117,
        117
      ],
      [
        132,
        132
      ],
      [
        134,
        136
      ],
      [
        138,
        138
      ],
      [
        140,
        141
      ],
      [
        154,
        155
      ],
      [
        157,
        157
      ],
      [
        159,
        160
      ],
      [
        163,
        165
      ],
      [
        167,
        167
      ],
      [
        170,
        171
      ],
      [
        174,
        176
      ],
      [
        220,
        220
      ]
    ],
    "render": [
      [
        73,
        73
      ],
      [
        84,
        84
      ],
      [
        101,
        101
      ],
      [
        175,
        176
      ],
      [
        185,
        185
      ],
      [
        187,
        187
      ],
      [
        193,
        193
      ],
      [
        203,
        203
      ],
      [
        209,
        210
      ],
      [
        215,
        215
      ],
      [
        235,
        235
      ],
      [
        238,
        238
      ],
      [
        240,
        240
      ]
    ],
    "post": [
      [
        138,
        138
      ],
      [
        157,
        157
      ],
      [
        167,
        167
      ],
      [
        174,
        174
      ],
      [
        187,
        187
      ]
    ],
    "output": [
      [
        203,
        203
      ],
      [
        206,
        207
      ],
      [
        209,
        209
      ],
      [
        215,
        215
      ],
      [
        238,
        240
      ]
    ]
  },
  "mappingConfidence": "high",
  "mappingWarnings": [],
  "sourceText": "/**\n * @file LGPStarBurstEffect.cpp\n * @brief LGP Star Burst effect - explosive radial lines from center\n *\n * REPAIRED: Simplified to match Wave Collision's proven pattern.\n * Previous version was over-engineered with 9+ audio inputs causing chaos.\n *\n * Pattern: CENTER_ORIGIN radial waves with snare-driven bursts\n *\n * Audio Integration (Wave Collision pattern):\n * - Heavy Bass → Speed modulation (slew-limited)\n * - Snare Hit → Burst flash (center-focused)\n * - Chroma → Color (dominant bin for hue offset)\n */\n\n#include \"LGPStarBurstEffectEnhanced.h\"\n#include \"../CoreEffects.h\"\n#include \"../../config/features.h\"\n#include <FastLED.h>\n#include <cmath>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nLGPStarBurstEnhancedEffect::LGPStarBurstEnhancedEffect()\n    : m_phase(0.0f)\n{\n}\n\nbool LGPStarBurstEnhancedEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    m_phase = 0.0f;\n    m_burst = 0.0f;\n    m_lastHopSeq = 0;\n    m_chromaAngle = 0.0f;\n    m_subBassEnergy = 0.0f;\n    m_targetSubBass = 0.0f;\n    m_hihatSparkle = 0.0f;\n\n    // Initialize chromagram smoothing\n    for (uint8_t i = 0; i < 12; i++) {\n        m_chromaFollowers[i].reset(0.0f);\n        m_chromaSmoothed[i] = 0.0f;\n        m_chromaTargets[i] = 0.0f;\n    }\n    \n    // Initialize spring physics for natural speed momentum\n    m_phaseSpeedSpring.init(50.0f, 1.0f);  // stiffness=50, mass=1 (critically damped)\n    m_phaseSpeedSpring.reset(1.0f);        // Start at base speed\n    m_subBassFollower.reset(0.0f);\n    m_tempoLocked = false;\n\n    return true;\n}\n\nvoid LGPStarBurstEnhancedEffect::render(plugins::EffectContext& ctx) {\n    // CENTRE ORIGIN - Star-like patterns radiating from centre\n    float speedNorm = ctx.speed / 50.0f;\n    float intensityNorm = ctx.brightness / 255.0f;\n    const bool hasAudio = ctx.audio.available;\n\n    // =========================================================================\n    // Audio Analysis (per-hop, like Wave Collision)\n    // =========================================================================\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        bool newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n        if (newHop) {\n            m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n            \n            // Update chromagram targets\n            for (uint8_t i = 0; i < 12; i++) {\n                m_chromaTargets[i] = ctx.audio.controlBus.heavy_chroma[i];\n            }\n\n            // Enhanced: Snare = burst with sub-bass boost\n            if (ctx.audio.isSnareHit()) {\n                m_burst = 1.0f;\n            }\n            \n            // Enhanced: 64-bin Sub-Bass Detection (bins 0-5 = ~110-155 Hz)\n            float subBassSum = 0.0f;\n            for (uint8_t i = 0; i < 6; ++i) {\n                subBassSum += ctx.audio.bin(i);\n            }\n            m_targetSubBass = subBassSum / 6.0f;\n        }\n    }\n#endif\n\n    // =========================================================================\n    // Per-frame Updates (smooth animation)\n    // =========================================================================\n    float rawDt = ctx.getSafeRawDeltaSeconds();\n    float dt = ctx.getSafeDeltaSeconds();\n    float moodNorm = ctx.getMoodNormalized();\n    \n    // Smooth chromagram with AsymmetricFollower (every frame)\n    if (hasAudio) {\n        for (uint8_t i = 0; i < 12; i++) {\n            m_chromaSmoothed[i] = m_chromaFollowers[i].updateWithMood(\n                m_chromaTargets[i], rawDt, moodNorm);\n        }\n        // Enhanced: Smooth sub-bass energy\n        m_subBassEnergy = m_subBassFollower.updateWithMood(m_targetSubBass, rawDt, moodNorm);\n        \n        // Enhanced: Hi-hat hit triggers sparkle burst\n        if (ctx.audio.isHihatHit()) {\n            m_hihatSparkle = 1.0f;\n        }\n        m_hihatSparkle = effects::chroma::dtDecay(m_hihatSparkle, 0.85f, rawDt);  // dt-corrected decay for sparkle\n        if (m_hihatSparkle < 0.01f) m_hihatSparkle = 0.0f;\n    }\n\n    // Circular chroma hue (replaces argmax + linear EMA to eliminate bin-flip rainbow sweeps)\n    uint8_t chromaHue = effects::chroma::circularChromaHueSmoothed(\n        ctx.audio.controlBus.heavy_chroma, m_chromaAngle, rawDt, 0.20f);\n\n    // Enhanced: Use 64-bin sub-bass for speed (more responsive)\n    float heavyEnergy = 0.0f;\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        // Blend sub-bass with heavy_bands - use sqrt for gentler curve\n        float subBass = sqrtf(m_subBassEnergy) * 1.5f;\n        float heavyBass = sqrtf(ctx.audio.heavyBass()) * 1.5f;\n        heavyEnergy = subBass * 0.7f + heavyBass * 0.3f;\n        heavyEnergy = fmaxf(0.2f, heavyEnergy);  // Minimum floor for visibility\n    }\n#endif\n\n    // Spring physics for speed modulation (natural momentum, no jitter)\n    float targetSpeed = 0.7f + 0.6f * heavyEnergy;\n    float smoothedSpeed = m_phaseSpeedSpring.update(targetSpeed, rawDt);\n    if (smoothedSpeed > 2.0f) smoothedSpeed = 2.0f;\n    if (smoothedSpeed < 0.3f) smoothedSpeed = 0.3f;  // Prevent stalling\n\n    // Enhanced: Use beatPhase for synchronization when tempo confidence high (PLL-style correction)\n    // Domain constants (compute once, use consistently)\n    const float PHASE_DOMAIN = 628.3f;      // 100 * 2 * PI\n    const float HALF_DOMAIN = 314.15f;     // PHASE_DOMAIN / 2\n\n    // Tempo lock hysteresis (Schmitt trigger: prevents chatter near threshold)\n    if (!hasAudio) {\n        m_tempoLocked = false;  // Clear lock when audio drops (prevents ghost lock)\n    } else {\n        float tempoConf = ctx.audio.tempoConfidence();\n        \n        // Update lock state with hysteresis (0.6 lock / 0.4 unlock)\n        if (tempoConf > 0.6f) m_tempoLocked = true;\n        else if (tempoConf < 0.4f) m_tempoLocked = false;\n    }\n    \n    // Always advance phase (free-run oscillator)\n    m_phase += speedNorm * 240.0f * smoothedSpeed * dt;\n    \n    // Apply phase correction when tempo-locked (PLL-style P-only correction)\n    if (hasAudio && m_tempoLocked) {\n        float beatPhase = ctx.audio.beatPhase();\n        float targetPhase = beatPhase * PHASE_DOMAIN;\n        \n        // Compute wrapped error (shortest path to target)\n        float phaseError = targetPhase - m_phase;\n        if (phaseError > HALF_DOMAIN) phaseError -= PHASE_DOMAIN;\n        if (phaseError < -HALF_DOMAIN) phaseError += PHASE_DOMAIN;\n        \n        // Proportional correction (tau ~100ms gives smooth lock)\n        // Compute ONCE per frame, not per pixel\n        const float tau = 0.1f;\n        const float correctionAlpha = 1.0f - expf(-rawDt / tau);\n        m_phase += phaseError * correctionAlpha;\n    }\n    \n    // CRITICAL: Wrap phase AFTER correction (handles negative and overflow)\n    while (m_phase >= PHASE_DOMAIN) m_phase -= PHASE_DOMAIN;\n    while (m_phase < 0.0f) m_phase += PHASE_DOMAIN;\n\n    // Enhanced: Burst decay with sub-bass boost\n    m_burst = effects::chroma::dtDecay(m_burst, 0.88f, rawDt);\n    if (hasAudio && m_subBassEnergy > 0.3f) {\n        m_burst = fmaxf(m_burst, m_subBassEnergy * 0.5f);  // Boost burst with sub-bass\n    }\n\n    // =========================================================================\n    // Rendering\n    // =========================================================================\n    fadeToBlackBy(ctx.leds, ctx.ledCount, ctx.fadeAmount);\n\n    // Anti-aliased burst core at true center (79.5) using SubpixelRenderer\n    // Lower threshold from 0.05 to 0.02 for more visibility\n    if (m_burst > 0.02f) {\n        uint8_t baseHue = (uint8_t)(ctx.gHue + chromaHue);\n        CRGB burstColor = ctx.palette.getColor(baseHue, 255);\n        // Enhanced: Boost brightness with sub-bass and hi-hat sparkle\n        // Use sqrt for gentler curve on burst intensity\n        float burstIntensity = sqrtf(m_burst) * 1.5f + m_hihatSparkle * 0.4f;\n        burstIntensity = fmaxf(0.2f, burstIntensity);  // Minimum floor for visibility\n        if (burstIntensity > 1.0f) burstIntensity = 1.0f;\n        uint8_t burstBright = (uint8_t)(burstIntensity * 200.0f * intensityNorm);\n\n        // Render bright core at fractional center (between LED 79 and 80)\n        enhancement::SubpixelRenderer::renderPoint(\n            ctx.leds, STRIP_LENGTH, 79.5f, burstColor, burstBright\n        );\n\n        // Also render on strip 2\n        if (STRIP_LENGTH * 2 <= ctx.ledCount) {\n            enhancement::SubpixelRenderer::renderPoint(\n                ctx.leds + STRIP_LENGTH, STRIP_LENGTH, 79.5f,\n                ctx.palette.getColor(baseHue + 90, 255), burstBright\n            );\n        }\n    }\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float distFromCenter = (float)centerPairDistance((uint16_t)i);\n\n        // Spatial frequency for sharp radial lines\n        const float freqBase = 0.25f;\n        float star = sinf(distFromCenter * freqBase - m_phase);\n\n        // Center-focused burst flash (like Wave Collision's collision flash)\n        float burstFlash = m_burst * expf(-distFromCenter * 0.12f);\n\n        // Simple audio gain (like Wave Collision) - use sqrt for gentler curve\n        float audioGain = 0.5f + 0.5f * sqrtf(heavyEnergy) * 1.5f;\n        float pattern = star * audioGain + burstFlash * 0.8f;\n\n        // tanhf for uniform brightness (PROVEN PATTERN)\n        pattern = tanhf(pattern * 2.0f) * 0.5f + 0.5f;\n\n        // Add base brightness floor (0.2) so effect is visible without harmonic content\n        pattern = fmaxf(0.2f, pattern);\n        uint8_t brightness = (uint8_t)(pattern * 255.0f * intensityNorm);\n        uint8_t paletteIndex = (uint8_t)(distFromCenter * 2.0f + pattern * 50.0f);\n        uint8_t baseHue = (uint8_t)(ctx.gHue + chromaHue);\n\n        ctx.leds[i] = ctx.palette.getColor((uint8_t)(baseHue + paletteIndex), brightness);\n        if (i + STRIP_LENGTH < ctx.ledCount) {\n            ctx.leds[i + STRIP_LENGTH] = ctx.palette.getColor((uint8_t)(baseHue + paletteIndex + 90), brightness);\n        }\n    }\n}\n\nvoid LGPStarBurstEnhancedEffect::cleanup() {\n    // No resources to free\n}\n\nconst plugins::EffectMetadata& LGPStarBurstEnhancedEffect::getMetadata() const {\n    static plugins::EffectMetadata meta(\n        \"LGP Star Burst Enhanced\",\n        \"Enhanced: 64-bin sub-bass, enhanced snare/hi-hat triggers, beatPhase sync\",\n        plugins::EffectCategory::GEOMETRIC,\n        1\n    );\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
