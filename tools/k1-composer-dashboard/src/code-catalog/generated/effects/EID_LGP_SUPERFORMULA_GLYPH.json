{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_LGP_SUPERFORMULA_GLYPH",
  "effectIdHex": "0x1803",
  "className": "LGPSuperformulaGlyphEffect",
  "displayName": "Living Glyph",
  "headerPath": "firmware/v2/src/effects/ieffect/LGPShapeBangersPack.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/LGPShapeBangersPack.cpp",
  "renderRange": [
    257,
    296
  ],
  "phaseRanges": {
    "input": [
      [
        257,
        260
      ]
    ],
    "mapping": [
      [
        258,
        258
      ],
      [
        260,
        260
      ],
      [
        295,
        295
      ]
    ],
    "modulation": [
      [
        268,
        274
      ]
    ],
    "render": [
      [
        274,
        274
      ],
      [
        293,
        293
      ]
    ],
    "post": [
      [
        292,
        294
      ]
    ],
    "output": [
      [
        262,
        262
      ],
      [
        274,
        274
      ]
    ]
  },
  "mappingConfidence": "low",
  "mappingWarnings": [
    "Phase inference used fallback segmentation due to sparse signal.",
    "Phase 'input' inferred from fallback segmentation.",
    "Phase 'modulation' inferred from fallback segmentation.",
    "Phase 'post' inferred from fallback segmentation."
  ],
  "sourceText": "/**\n * @file LGPShapeBangersPack.cpp\n * @brief Implementation for 11 LGP shape bangers\n *\n * Pattern families: Talbot self-imaging, Airy self-accelerating beams,\n * moire interference, superformula supershapes, spirograph hypotrochoids,\n * rose curves, Lissajous/harmonograph orbits, Rule 30, Langton's ant,\n * standing waves/cymatics, shock diamonds.\n */\n\n#include \"LGPShapeBangersPack.h\"\n#include \"LGPFilmPost.h\"\n#include \"../CoreEffects.h\"\n#include <FastLED.h>\n#include <esp_heap_caps.h>\n#include <cmath>\n#include <cstdint>\n#include <cstring>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nstatic constexpr float SB_PI  = 3.14159265358979323846f;\nstatic constexpr float SB_TAU = 6.28318530717958647692f;\n\nstatic inline float clamp01(float x) { return (x < 0.0f) ? 0.0f : (x > 1.0f) ? 1.0f : x; }\nstatic inline float lerp(float a, float b, float t) { return a + (b - a) * t; }\nstatic inline float smoothstep(float a, float b, float x) {\n    float t = clamp01((x - a) / (b - a));\n    return t * t * (3.0f - 2.0f * t);\n}\nstatic inline float fract(float x) { return x - floorf(x); }\nstatic inline float tri01(float x) {\n    // triangle wave in [0..1]\n    float f = fract(x);\n    float t = 1.0f - fabsf(2.0f * f - 1.0f);\n    return clamp01(t);\n}\nstatic inline float gaussian(float x, float sigma) {\n    // exp(-(x^2)/(2*sigma^2))\n    float s2 = sigma * sigma;\n    return expf(-(x * x) / (2.0f * s2));\n}\n\n// Dual-strip lock: no wing rivalry\nstatic inline void writeDualLocked(plugins::EffectContext& ctx, int i, const CRGB& c) {\n    ctx.leds[i] = c;\n    int j = i + STRIP_LENGTH;\n    if (j < (int)ctx.ledCount) ctx.leds[j] = c;\n}\n\n// Shared \"premium LGP\" luminance mapping: contrast without harsh clipping\nstatic inline uint8_t luminanceToBr(float wave01, float master) {\n    const float base = 0.06f;\n    float out = clamp01(base + (1.0f - base) * clamp01(wave01)) * master;\n    return (uint8_t)(255.0f * out);\n}\n\n// ---------------------------------------------\n// 1) Talbot Carpet\n// ---------------------------------------------\nLGPTalbotCarpetEffect::LGPTalbotCarpetEffect() : m_t(0.0f) {}\n\nbool LGPTalbotCarpetEffect::init(plugins::EffectContext& ctx) { (void)ctx; m_t = 0.0f; lightwaveos::effects::cinema::reset(); return true; }\n\nvoid LGPTalbotCarpetEffect::render(plugins::EffectContext& ctx) {\n    const float speedNorm = ctx.speed / 50.0f;\n    const float master = ctx.brightness / 255.0f;\n\n    // \"Propagation distance\" (stylised Talbot carpet)\n    m_t += (0.010f + 0.040f * speedNorm);\n\n    const float mid = (STRIP_LENGTH - 1) * 0.5f;\n    const float invMid = 1.0f / mid;\n\n    // Base grating pitch in pixels\n    const float p = 10.0f + 8.0f * (1.0f - speedNorm);\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float dmid = (float)i - mid;\n        float distN = fabsf(dmid) * invMid;\n        float glue = 0.35f + 0.65f * expf(-(dmid * dmid) * 0.0016f);\n\n        // Fresnel-ish harmonic sum: phase ~ k^2 * z (Talbot self-imaging motif)\n        float phi = SB_TAU* ((float)i / p);\n        float z = m_t;\n\n        float sumC = 0.0f, sumS = 0.0f;\n        float norm = 0.0f;\n        for (int k = 1; k <= 7; k++) {\n            float ak = 1.0f / (float)k;\n            float phase = (float)k * phi + (float)(k * k) * z * 0.55f;\n            sumC += ak * cosf(phase);\n            sumS += ak * sinf(phase);\n            norm += ak;\n        }\n        float amp = sqrtf(sumC * sumC + sumS * sumS) / (norm + 1e-6f);\n        float wave = powf(clamp01(amp), 1.7f);\n\n        // Carpet \"loom\" feel: edge gets slightly tighter\n        wave *= lerp(1.0f, 0.85f, distN);\n\n        uint8_t br = luminanceToBr(wave * glue, master);\n        uint8_t hue = (uint8_t)(ctx.gHue + (int)(wave * 60.0f) + (int)(distN * 20.0f));\n\n        writeDualLocked(ctx, i, ctx.palette.getColor(hue, br));\n    }\n    lightwaveos::effects::cinema::apply(ctx, speedNorm);\n}\n\nvoid LGPTalbotCarpetEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPTalbotCarpetEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Talbot Carpet\",\n        \"Self-imaging lattice rug (near-field diffraction vibe)\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------\n// 2) Airy Comet\n// ---------------------------------------------\nLGPAiryCometEffect::LGPAiryCometEffect() : m_t(0.0f) {}\nbool LGPAiryCometEffect::init(plugins::EffectContext& ctx) { (void)ctx; m_t = 0.0f; lightwaveos::effects::cinema::reset(); return true; }\n\nvoid LGPAiryCometEffect::render(plugins::EffectContext& ctx) {\n    const float speedNorm = ctx.speed / 50.0f;\n    const float master = ctx.brightness / 255.0f;\n\n    m_t += (0.010f + 0.045f * speedNorm);\n\n    const float mid = (STRIP_LENGTH - 1) * 0.5f;\n\n    // Parabolic \"self-accelerating\" motion across the strip (bounce)\n    float s = fract(m_t * 0.12f);\n    float parab = (s * s);              // 0..1 with accelerating slope\n    float x0 = lerp(-mid * 0.92f, mid * 0.92f, parab);\n\n    // Alternate direction each half-cycle\n    bool flip = (fract(m_t * 0.06f) > 0.5f);\n    float dir = flip ? -1.0f : 1.0f;\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float x = (float)i - mid;\n        float dmid = x;\n\n        float glue = expf(-(dmid * dmid) * 0.0018f);\n\n        float dx = x - x0;\n        float head = gaussian(dx, 3.2f); // sharp head\n\n        // Airy-ish tail: oscillatory lobes behind the head, decaying\n        float behind = (dx * dir > 0.0f) ? (dx * dir) : 0.0f;\n        float tail = expf(-behind * 0.12f) * (0.55f + 0.45f * cosf(behind * 1.25f - m_t * 0.9f));\n\n        float wave = clamp01(head + 0.75f * tail);\n        wave = powf(wave, 1.25f);\n\n        // Melt into wings (no top/bottom fighting)\n        float glued = lerp(wave, wave * (0.45f + 0.55f * glue), 0.85f);\n\n        uint8_t br = luminanceToBr(glued, master);\n\n        // Head warm, tail cool (subtle)\n        uint8_t hue = (uint8_t)(ctx.gHue + (int)(60.0f * (1.0f - smoothstep(0.0f, 1.0f, head))) + (int)(15.0f * glue));\n\n        writeDualLocked(ctx, i, ctx.palette.getColor(hue, br));\n    }\n    lightwaveos::effects::cinema::apply(ctx, speedNorm);\n}\n\nvoid LGPAiryCometEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPAiryCometEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Airy Comet\",\n        \"Self-accelerating comet with trailing lobes\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------\n// 3) Moire Cathedral\n// ---------------------------------------------\nLGPMoireCathedralEffect::LGPMoireCathedralEffect() : m_t(0.0f) {}\nbool LGPMoireCathedralEffect::init(plugins::EffectContext& ctx) { (void)ctx; m_t = 0.0f; lightwaveos::effects::cinema::reset(); return true; }\n\nvoid LGPMoireCathedralEffect::render(plugins::EffectContext& ctx) {\n    const float speedNorm = ctx.speed / 50.0f;\n    const float master = ctx.brightness / 255.0f;\n    m_t += (0.008f + 0.030f * speedNorm);\n\n    const float mid = (STRIP_LENGTH - 1) * 0.5f;\n\n    // Two close gratings -> slow giant arches\n    float p1 = 7.5f;\n    float p2 = 8.1f;\n\n    float w1 = 0.65f + 0.40f * speedNorm;\n    float w2 = 0.58f + 0.35f * speedNorm;\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float x = (float)i;\n        float dmid = x - mid;\n        float glue = 0.40f + 0.60f * expf(-(dmid * dmid) * 0.0011f);\n\n        float g1 = sinf(SB_TAU * (x / p1) + m_t * w1);\n        float g2 = sinf(SB_TAU * (x / p2) - m_t * w2);\n\n        float moire = fabsf(g1 - g2);           // 0..2\n        float wave = clamp01(moire * 0.55f);    // ~0..1\n\n        // Cathedral ribs: compress highlights slightly\n        wave = powf(wave, 1.35f);\n\n        uint8_t br = luminanceToBr(wave * glue, master);\n\n        // Two-tone \"stained glass\" without rainbow spam\n        uint8_t hue = (uint8_t)(ctx.gHue + (int)(wave * 42.0f) + (int)(12.0f * glue));\n\n        writeDualLocked(ctx, i, ctx.palette.getColor(hue, br));\n    }\n    lightwaveos::effects::cinema::apply(ctx, speedNorm);\n}\n\nvoid LGPMoireCathedralEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPMoireCathedralEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Moire Cathedral\",\n        \"Interference arches from close gratings (giant beats)\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------\n// 4) Superformula Living Glyph\n// ---------------------------------------------\nLGPSuperformulaGlyphEffect::LGPSuperformulaGlyphEffect() : m_t(0.0f) {}\nbool LGPSuperformulaGlyphEffect::init(plugins::EffectContext& ctx) { (void)ctx; m_t = 0.0f; lightwaveos::effects::cinema::reset(); return true; }\n\nstatic inline float superformula(float phi, float m, float n1, float n2, float n3, float a=1.0f, float b=1.0f) {\n    float t1 = powf(fabsf(cosf(m * phi * 0.25f) / a), n2);\n    float t2 = powf(fabsf(sinf(m * phi * 0.25f) / b), n3);\n    float r  = powf(t1 + t2, -1.0f / n1);\n    return r;\n}\n\nvoid LGPSuperformulaGlyphEffect::render(plugins::EffectContext& ctx) {\n    const float speedNorm = ctx.speed / 50.0f;\n    const float master = ctx.brightness / 255.0f;\n    m_t += (0.010f + 0.030f * speedNorm);\n\n    const float mid = (STRIP_LENGTH - 1) * 0.5f;\n    const float invMid = 1.0f / mid;\n\n    // Morph parameters slowly (sigils)\n    float morph = 0.5f + 0.5f * sinf(m_t * 0.35f);\n    float sfm = lerp(3.0f, 11.0f, morph);      // \"lobes\"\n    float n1 = lerp(0.7f, 1.6f, 1.0f - morph);\n    float n2 = lerp(0.8f, 2.4f, morph);\n    float n3 = lerp(0.8f, 2.4f, 1.0f - morph);\n\n    float rot = m_t * 0.20f;\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float signedX = ((float)i - mid) * invMid;     // -1..1\n        float phi = signedX * SB_PI + rot;                 // -pi..pi plus rotation\n        float distN = fabsf((float)i - mid) * invMid;  // 0..1\n\n        float r = superformula(phi, sfm, n1, n2, n3);\n        r = clamp01(r * 0.92f);                        // keep inside\n\n        // Distance-to-curve band\n        float bandW = 0.055f;\n        float wave = expf(-fabsf(distN - r) / bandW);\n\n        // LGP glue: strengthen centre continuity\n        float glue = 0.35f + 0.65f * expf(-((float)i - mid) * ((float)i - mid) * 0.0015f);\n        wave *= glue;\n\n        uint8_t br = luminanceToBr(powf(wave, 1.15f), master);\n        uint8_t hue = (uint8_t)(ctx.gHue + (int)(morph * 50.0f) + (int)(wave * 90.0f));\n\n        writeDualLocked(ctx, i, ctx.palette.getColor(hue, br));\n    }\n    lightwaveos::effects::cinema::apply(ctx, speedNorm);\n}\n\nvoid LGPSuperformulaGlyphEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPSuperformulaGlyphEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Living Glyph\",\n        \"Superformula sigils (morphing supershapes)\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------\n// 5) Spirograph Crown (Hypotrochoid)\n// ---------------------------------------------\nLGPSpirographCrownEffect::LGPSpirographCrownEffect() : m_t(0.0f) {}\nbool LGPSpirographCrownEffect::init(plugins::EffectContext& ctx) { (void)ctx; m_t = 0.0f; lightwaveos::effects::cinema::reset(); return true; }\n\nstatic inline float hypotrochoid_radius(float theta, float R, float r, float d) {\n    // x = (R-r)cos(theta) + d cos((R-r)/r * theta)\n    // y = (R-r)sin(theta) - d sin((R-r)/r * theta)\n    float k = (R - r) / r;\n    float x = (R - r) * cosf(theta) + d * cosf(k * theta);\n    float y = (R - r) * sinf(theta) - d * sinf(k * theta);\n    return sqrtf(x * x + y * y);\n}\n\nvoid LGPSpirographCrownEffect::render(plugins::EffectContext& ctx) {\n    const float speedNorm = ctx.speed / 50.0f;\n    const float master = ctx.brightness / 255.0f;\n    m_t += (0.010f + 0.030f * speedNorm);\n\n    const float mid = (STRIP_LENGTH - 1) * 0.5f;\n    const float invMid = 1.0f / mid;\n\n    // Crown parameters\n    const float R = 1.0f;\n    const float r = 0.30f + 0.05f * sinf(m_t * 0.22f);\n    const float d = 0.78f;\n\n    float rot = m_t * 0.35f;\n    float maxRad = (R - r) + d; // safe normalisation\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float signedX = ((float)i - mid) * invMid;\n        float theta = signedX * SB_PI + rot;\n\n        float distN = fabsf((float)i - mid) * invMid;\n\n        float rr = hypotrochoid_radius(theta, R, r, d) / (maxRad + 1e-6f);\n        rr = clamp01(rr);\n\n        float bandW = 0.050f;\n        float wave = expf(-fabsf(distN - rr) / bandW);\n\n        float glue = 0.30f + 0.70f * expf(-((float)i - mid) * ((float)i - mid) * 0.0014f);\n        wave *= glue;\n\n        // Facet sparkle (tiny)\n        float facet = 0.85f + 0.15f * sinf(18.0f * theta + m_t * 0.6f);\n        wave *= facet;\n\n        uint8_t br = luminanceToBr(powf(wave, 1.2f), master);\n        uint8_t hue = (uint8_t)(ctx.gHue + (int)(rr * 70.0f) + (int)(wave * 80.0f));\n\n        writeDualLocked(ctx, i, ctx.palette.getColor(hue, br));\n    }\n    lightwaveos::effects::cinema::apply(ctx, speedNorm);\n}\n\nvoid LGPSpirographCrownEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPSpirographCrownEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Spirograph Crown\",\n        \"Hypotrochoid crown loops (gear-flower royal seal)\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------\n// 6) Rose Bloom (Rhodonea)\n// ---------------------------------------------\nLGPRoseBloomEffect::LGPRoseBloomEffect() : m_t(0.0f) {}\nbool LGPRoseBloomEffect::init(plugins::EffectContext& ctx) { (void)ctx; m_t = 0.0f; lightwaveos::effects::cinema::reset(); return true; }\n\nvoid LGPRoseBloomEffect::render(plugins::EffectContext& ctx) {\n    const float speedNorm = ctx.speed / 50.0f;\n    const float master = ctx.brightness / 255.0f;\n    m_t += (0.010f + 0.028f * speedNorm);\n\n    const float mid = (STRIP_LENGTH - 1) * 0.5f;\n    const float invMid = 1.0f / mid;\n\n    // Petal count drifts between 3 and 7 (integer-ish feel)\n    float kf = 5.0f + 2.0f * sinf(m_t * 0.18f);\n    float rot = m_t * 0.28f;\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float signedX = ((float)i - mid) * invMid;\n        float theta = signedX * SB_PI + rot;\n\n        float distN = fabsf((float)i - mid) * invMid;\n\n        float r = fabsf(cosf(kf * theta));\n        r = clamp01(r * 0.92f);\n\n        float bandW = 0.060f;\n        float wave = expf(-fabsf(distN - r) / bandW);\n\n        // \"Opening bloom\" modulation\n        float open = 0.55f + 0.45f * sinf(m_t * 0.35f);\n        wave *= (0.75f + 0.25f * open);\n\n        float glue = 0.30f + 0.70f * expf(-((float)i - mid) * ((float)i - mid) * 0.0016f);\n        wave *= glue;\n\n        uint8_t br = luminanceToBr(powf(wave, 1.18f), master);\n        uint8_t hue = (uint8_t)(ctx.gHue + (int)(open * 40.0f) + (int)(wave * 95.0f));\n\n        writeDualLocked(ctx, i, ctx.palette.getColor(hue, br));\n    }\n    lightwaveos::effects::cinema::apply(ctx, speedNorm);\n}\n\nvoid LGPRoseBloomEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPRoseBloomEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Rose Bloom\",\n        \"Rhodonea petals (geometric bloom)\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------\n// 7) Harmonograph Halo (Lissajous aura)\n// ---------------------------------------------\nLGPHarmonographHaloEffect::LGPHarmonographHaloEffect() : m_t(0.0f) {}\nbool LGPHarmonographHaloEffect::init(plugins::EffectContext& ctx) { (void)ctx; m_t = 0.0f; lightwaveos::effects::cinema::reset(); return true; }\n\nvoid LGPHarmonographHaloEffect::render(plugins::EffectContext& ctx) {\n    const float speedNorm = ctx.speed / 50.0f;\n    const float master = ctx.brightness / 255.0f;\n    m_t += (0.010f + 0.030f * speedNorm);\n\n    const float mid = (STRIP_LENGTH - 1) * 0.5f;\n    const float invMid = 1.0f / mid;\n\n    // Integer-ish frequency ratio drives Lissajous family \"feel\"\n    float a = 3.0f;\n    float b = 2.0f + (speedNorm > 0.5f ? 1.0f : 0.0f);\n    float delta = 0.7f + 0.3f * sinf(m_t * 0.22f);\n\n    float rot = m_t * 0.20f;\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float signedX = ((float)i - mid) * invMid;\n        float phi = signedX * SB_PI;\n\n        // \"Orbit radius\" derived from two perpendicular oscillations\n        float x = sinf(a * (phi + rot) + delta);\n        float y = sinf(b * (phi - rot));\n        float r = sqrtf(x * x + y * y);     // 0..~1.414\n        float rr = clamp01(r * 0.72f);\n\n        float distN = fabsf((float)i - mid) * invMid;\n\n        float bandW = 0.055f;\n        float wave = expf(-fabsf(distN - rr) / bandW);\n\n        // Gentle \"energy pulse\"\n        wave *= (0.85f + 0.15f * sinf(m_t * 0.65f + phi * 2.0f));\n\n        float glue = 0.30f + 0.70f * expf(-((float)i - mid) * ((float)i - mid) * 0.0013f);\n        wave *= glue;\n\n        uint8_t br = luminanceToBr(powf(wave, 1.15f), master);\n        uint8_t hue = (uint8_t)(ctx.gHue + (int)(rr * 70.0f) + (int)(wave * 85.0f));\n\n        writeDualLocked(ctx, i, ctx.palette.getColor(hue, br));\n    }\n    lightwaveos::effects::cinema::apply(ctx, speedNorm);\n}\n\nvoid LGPHarmonographHaloEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPHarmonographHaloEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Harmonograph Halo\",\n        \"Lissajous orbitals (aura loops, premium calm)\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------\n// 8) Rule 30 Cathedral\n// ---------------------------------------------\nLGPRule30CathedralEffect::LGPRule30CathedralEffect() : m_step(0) {}\n\nbool LGPRule30CathedralEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    lightwaveos::effects::cinema::reset();\n#ifndef NATIVE_BUILD\n    if (!m_ps) {\n        m_ps = static_cast<Rule30Psram*>(\n            heap_caps_malloc(sizeof(Rule30Psram), MALLOC_CAP_SPIRAM));\n        if (!m_ps) return false;\n    }\n    memset(m_ps, 0, sizeof(Rule30Psram));\n    m_ps->cells[STRIP_LENGTH / 2] = 1;\n#endif\n    m_step = 0;\n    return true;\n}\n\nstatic inline uint8_t rule30(uint8_t l, uint8_t c, uint8_t r) {\n    // Rule 30: new = l xor (c or r)\n    return (uint8_t)(l ^ (c | r));\n}\n\nvoid LGPRule30CathedralEffect::render(plugins::EffectContext& ctx) {\n    if (!m_ps) return;\n    const float speedNorm = ctx.speed / 50.0f;\n    const float master = ctx.brightness / 255.0f;\n\n    int steps = 1 + (int)(6.0f * speedNorm);\n\n    for (int s = 0; s < steps; s++) {\n        for (int i = 0; i < STRIP_LENGTH; i++) {\n            int im1 = (i == 0) ? (STRIP_LENGTH - 1) : (i - 1);\n            int ip1 = (i == STRIP_LENGTH - 1) ? 0 : (i + 1);\n            m_ps->next[i] = rule30(m_ps->cells[im1], m_ps->cells[i], m_ps->cells[ip1]);\n        }\n        for (int i = 0; i < STRIP_LENGTH; i++) m_ps->cells[i] = m_ps->next[i];\n        m_step++;\n    }\n\n    const float mid = (STRIP_LENGTH - 1) * 0.5f;\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float dmid = (float)i - mid;\n        float glue = 0.35f + 0.65f * expf(-(dmid * dmid) * 0.0019f);\n\n        int im1 = (i == 0) ? (STRIP_LENGTH - 1) : (i - 1);\n        int ip1 = (i == STRIP_LENGTH - 1) ? 0 : (i + 1);\n        float cell = (float)m_ps->cells[i];\n        float blur = (cell + 0.7f * (float)m_ps->cells[im1] + 0.7f * (float)m_ps->cells[ip1]) / (1.0f + 0.7f + 0.7f);\n\n        float wave = powf(clamp01(blur), 1.35f) * glue;\n\n        uint8_t br = luminanceToBr(wave, master);\n\n        uint8_t nb = (uint8_t)((m_ps->cells[im1] << 2) | (m_ps->cells[i] << 1) | (m_ps->cells[ip1]));\n        uint8_t hue = (uint8_t)(ctx.gHue + (int)(nb * 13) + (int)(wave * 55.0f));\n\n        writeDualLocked(ctx, i, ctx.palette.getColor(hue, br));\n    }\n    lightwaveos::effects::cinema::apply(ctx, speedNorm);\n}\n\nvoid LGPRule30CathedralEffect::cleanup() {\n#ifndef NATIVE_BUILD\n    if (m_ps) {\n        heap_caps_free(m_ps);\n        m_ps = nullptr;\n    }\n#endif\n}\n\nconst plugins::EffectMetadata& LGPRule30CathedralEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Rule 30 Cathedral\",\n        \"Elementary CA textile (triangles + chaos + ribs)\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------\n// 9) Langton Highway (2D ant projected onto 1D)\n// ---------------------------------------------\nLGPLangtonHighwayEffect::LGPLangtonHighwayEffect()\n    : m_x(W/2), m_y(H/2), m_dir(1), m_steps(0), m_scan(0)\n{\n}\n\nbool LGPLangtonHighwayEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    lightwaveos::effects::cinema::reset();\n    if (!m_grid) {\n        m_grid = static_cast<uint8_t*>(heap_caps_malloc(H * W, MALLOC_CAP_SPIRAM));\n        if (!m_grid) return false;\n    }\n    memset(m_grid, 0, H * W);\n    m_x = W/2; m_y = H/2; m_dir = 1; m_steps = 0; m_scan = 0;\n    return true;\n}\n\nstatic inline void antStep(uint8_t* grid,\n                           uint8_t& x, uint8_t& y, uint8_t& dir)\n{\n    constexpr uint8_t W = LGPLangtonHighwayEffect::W;\n    constexpr uint8_t H = LGPLangtonHighwayEffect::H;\n\n    // Classic Langton's ant:\n    // - On white(0): turn right, flip to black(1), move forward\n    // - On black(1): turn left, flip to white(0), move forward\n    uint8_t cell = grid[y * W + x];\n    if (cell == 0) {\n        dir = (uint8_t)((dir + 1) & 3);\n        grid[y * W + x] = 1;\n    } else {\n        dir = (uint8_t)((dir + 3) & 3);\n        grid[y * W + x] = 0;\n    }\n\n    if (dir == 0) y = (uint8_t)((y == 0) ? (H - 1) : (y - 1));\n    if (dir == 1) x = (uint8_t)((x + 1) & (W - 1));\n    if (dir == 2) y = (uint8_t)((y + 1) & (H - 1));\n    if (dir == 3) x = (uint8_t)((x == 0) ? (W - 1) : (x - 1));\n}\n\nvoid LGPLangtonHighwayEffect::render(plugins::EffectContext& ctx) {\n    if (!m_grid) return;\n\n    const float speedNorm = ctx.speed / 50.0f;\n    const float master = ctx.brightness / 255.0f;\n\n    // More steps = faster emergence into \"highway\"\n    int steps = 16 + (int)(140.0f * speedNorm);\n    for (int s = 0; s < steps; s++) {\n        antStep(m_grid, m_x, m_y, m_dir);\n        m_steps++;\n    }\n\n    // Projection: sample a drifting diagonal slice of the 2D grid\n    m_scan = (uint8_t)(m_scan + (1 + (int)(6.0f * speedNorm)));\n\n    const float mid = (STRIP_LENGTH - 1) * 0.5f;\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float dmid = (float)i - mid;\n        float glue = 0.35f + 0.65f * expf(-(dmid * dmid) * 0.0017f);\n\n        uint8_t gx = (uint8_t)((i * W) / STRIP_LENGTH);\n        uint8_t gy = (uint8_t)((((int)i + (int)m_scan) * H) / STRIP_LENGTH);\n        uint8_t cell = m_grid[(gy & (H - 1)) * W + (gx & (W - 1))];\n\n        // Soften a bit: local neighbourhood average\n        uint8_t gx1 = (uint8_t)((gx + 1) & (W - 1));\n        uint8_t gy1 = (uint8_t)((gy + 1) & (H - 1));\n        float blur = (cell + m_grid[gy * W + gx1] + m_grid[gy1 * W + gx] + m_grid[gy1 * W + gx1]) * 0.25f;\n\n        float wave = powf(clamp01(blur), 1.35f) * glue;\n\n        // Subtle \"ant spark\" when projection hits ant neighbourhood\n        if ((gx == m_x && gy == m_y) || (gx1 == m_x && gy == m_y) || (gx == m_x && gy1 == m_y)) {\n            wave = clamp01(wave + 0.35f);\n        }\n\n        uint8_t br = luminanceToBr(wave, master);\n        uint8_t hue = (uint8_t)(ctx.gHue + (int)(wave * 80.0f) + (int)((m_steps >> 7) & 31));\n\n        writeDualLocked(ctx, i, ctx.palette.getColor(hue, br));\n    }\n    lightwaveos::effects::cinema::apply(ctx, speedNorm);\n}\n\nvoid LGPLangtonHighwayEffect::cleanup() {\n    if (m_grid) { heap_caps_free(m_grid); m_grid = nullptr; }\n}\n\nconst plugins::EffectMetadata& LGPLangtonHighwayEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Langton Highway\",\n        \"Emergent order reveal (ant to chaos to highway) projected to 1D\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------\n// 10) Cymatic Ladder (standing waves)\n// ---------------------------------------------\nLGPCymaticLadderEffect::LGPCymaticLadderEffect() : m_t(0.0f) {}\nbool LGPCymaticLadderEffect::init(plugins::EffectContext& ctx) { (void)ctx; m_t = 0.0f; lightwaveos::effects::cinema::reset(); return true; }\n\nvoid LGPCymaticLadderEffect::render(plugins::EffectContext& ctx) {\n    const float speedNorm = ctx.speed / 50.0f;\n    const float master = ctx.brightness / 255.0f;\n    m_t += (0.010f + 0.020f * speedNorm);\n\n    const float mid = (STRIP_LENGTH - 1) * 0.5f;\n\n    // Mode number (standing wave harmonic)\n    int n = 2 + (int)(6.0f * speedNorm); // 2..8\n\n    float phase = m_t * (0.8f + 0.5f * speedNorm);\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float x = (float)i / (float)(STRIP_LENGTH - 1); // 0..1 along length\n\n        // Standing wave shape: sin(n*pi*x + phase) with nodes/antinodes\n        float s = fabsf(sinf((float)n * SB_PI * x + phase));\n\n        // Sharpen nodes and anti-nodes to \"sculpture\"\n        float wave = powf(s, 1.8f);\n\n        // LGP glue: centre continuity\n        float dmid = (float)i - mid;\n        float glue = 0.30f + 0.70f * expf(-(dmid * dmid) * 0.0016f);\n        wave *= glue;\n\n        uint8_t br = luminanceToBr(wave, master);\n\n        // Cymatic vibe: hue shifts mainly with harmonic, not position\n        uint8_t hue = (uint8_t)(ctx.gHue + n * 9 + (int)(wave * 60.0f));\n\n        writeDualLocked(ctx, i, ctx.palette.getColor(hue, br));\n    }\n    lightwaveos::effects::cinema::apply(ctx, speedNorm);\n}\n\nvoid LGPCymaticLadderEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPCymaticLadderEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Cymatic Ladder\",\n        \"Standing-wave nodes/antinodes sculpted into LGP glass\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n// ---------------------------------------------\n// 11) Mach Diamonds (shock diamonds)\n// ---------------------------------------------\nLGPMachDiamondsEffect::LGPMachDiamondsEffect() : m_t(0.0f) {}\nbool LGPMachDiamondsEffect::init(plugins::EffectContext& ctx) { (void)ctx; m_t = 0.0f; lightwaveos::effects::cinema::reset(); return true; }\n\nvoid LGPMachDiamondsEffect::render(plugins::EffectContext& ctx) {\n    const float speedNorm = ctx.speed / 50.0f;\n    const float master = ctx.brightness / 255.0f;\n    m_t += (0.010f + 0.040f * speedNorm);\n\n    const float mid = (STRIP_LENGTH - 1) * 0.5f;\n    const float invMid = 1.0f / mid;\n\n    // Shock-cell spacing in centre-distance space\n    float spacing = 0.13f;      // in distN units\n    float drift = m_t * (0.20f + 0.35f * speedNorm);\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        float dmid = (float)i - mid;\n        float distN = fabsf(dmid) * invMid;     // 0..1\n\n        // \"Shock diamonds\" as standing-wave-ish pulses along distance\n        float cellPhase = (distN / spacing) - drift;\n        float tri = tri01(cellPhase);           // 0..1 triangular peaks\n        float wave = powf(tri, 2.2f);           // jewel highlights\n\n        // Diamond \"breathing\" (very subtle)\n        wave *= (0.85f + 0.15f * cosf(SB_TAU * cellPhase + m_t * 0.6f));\n\n        // Glue so the middle melts into wings\n        float glue = 0.35f + 0.65f * expf(-(dmid * dmid) * 0.0013f);\n        wave *= glue;\n\n        uint8_t br = luminanceToBr(wave, master);\n\n        // Deep jewel tones: hue primarily tracks shock-cell rhythm\n        uint8_t hue = (uint8_t)(ctx.gHue + (int)(tri * 80.0f) + (int)(distN * 15.0f));\n\n        writeDualLocked(ctx, i, ctx.palette.getColor(hue, br));\n    }\n    lightwaveos::effects::cinema::apply(ctx, speedNorm);\n}\n\nvoid LGPMachDiamondsEffect::cleanup() {}\n\nconst plugins::EffectMetadata& LGPMachDiamondsEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Mach Diamonds\",\n        \"Shock-diamond jewellery (standing shock-cell pulses)\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
