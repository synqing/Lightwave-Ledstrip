{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_LGP_WAVE_COLLISION",
  "effectIdHex": "0x0204",
  "className": "LGPWaveCollisionEffect",
  "displayName": "LGP Wave Collision",
  "headerPath": "firmware/v2/src/effects/ieffect/LGPWaveCollisionEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/LGPWaveCollisionEffect.cpp",
  "renderRange": [
    45,
    238
  ],
  "phaseRanges": {
    "input": [
      [
        49,
        49
      ],
      [
        54,
        54
      ],
      [
        56,
        56
      ],
      [
        61,
        61
      ],
      [
        97,
        97
      ],
      [
        114,
        114
      ],
      [
        118,
        118
      ],
      [
        128,
        128
      ],
      [
        135,
        135
      ]
    ],
    "mapping": [
      [
        47,
        48
      ],
      [
        67,
        69
      ],
      [
        72,
        73
      ],
      [
        77,
        77
      ],
      [
        108,
        110
      ],
      [
        129,
        129
      ],
      [
        131,
        132
      ],
      [
        140,
        140
      ],
      [
        145,
        148
      ],
      [
        151,
        151
      ],
      [
        159,
        159
      ],
      [
        176,
        176
      ],
      [
        179,
        179
      ],
      [
        221,
        221
      ],
      [
        223,
        223
      ]
    ],
    "modulation": [
      [
        92,
        92
      ],
      [
        94,
        94
      ],
      [
        98,
        98
      ],
      [
        101,
        101
      ],
      [
        104,
        105
      ],
      [
        107,
        110
      ],
      [
        113,
        113
      ],
      [
        122,
        122
      ],
      [
        131,
        131
      ],
      [
        134,
        134
      ],
      [
        137,
        137
      ],
      [
        141,
        141
      ],
      [
        144,
        144
      ],
      [
        150,
        153
      ],
      [
        155,
        156
      ],
      [
        158,
        161
      ],
      [
        165,
        168
      ],
      [
        170,
        170
      ],
      [
        200,
        200
      ],
      [
        203,
        204
      ],
      [
        207,
        207
      ],
      [
        215,
        215
      ]
    ],
    "render": [
      [
        60,
        60
      ],
      [
        172,
        172
      ],
      [
        178,
        178
      ],
      [
        183,
        183
      ],
      [
        189,
        190
      ],
      [
        195,
        195
      ],
      [
        224,
        224
      ],
      [
        229,
        230
      ],
      [
        234,
        235
      ]
    ],
    "post": [
      [
        172,
        172
      ],
      [
        212,
        212
      ],
      [
        227,
        227
      ]
    ],
    "output": [
      [
        183,
        183
      ],
      [
        186,
        187
      ],
      [
        189,
        189
      ],
      [
        195,
        195
      ],
      [
        230,
        230
      ],
      [
        232,
        232
      ],
      [
        235,
        235
      ]
    ]
  },
  "mappingConfidence": "medium",
  "mappingWarnings": [],
  "sourceText": "/**\n * @file LGPWaveCollisionEffect.cpp\n * @brief LGP Wave Collision effect implementation\n */\n\n#include \"LGPWaveCollisionEffect.h\"\n#include \"../CoreEffects.h\"\n#include \"../../config/features.h\"\n#include \"../../validation/EffectValidationMacros.h\"\n#include <FastLED.h>\n#include <cmath>\n\nnamespace lightwaveos {\nnamespace effects {\nnamespace ieffect {\n\nbool LGPWaveCollisionEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    // CRITICAL FIX: Single phase for traveling waves\n    m_phase = 0.0f;\n    m_lastHopSeq = 0;\n    m_chromaEnergySum = 0.0f;\n    m_chromaHistIdx = 0;\n    for (uint8_t i = 0; i < CHROMA_HISTORY; ++i) {\n        m_chromaEnergyHist[i] = 0.0f;\n    }\n    m_energyAvg = 0.0f;\n    m_energyDelta = 0.0f;\n    m_chromaAngle = 0.0f;\n    m_collisionBoost = 0.0f;\n    m_speedTarget = 1.0f;\n\n    // Initialize enhancement utilities\n    m_speedSpring.init(50.0f, 1.0f);  // stiffness=50, mass=1 (critically damped)\n    m_speedSpring.reset(1.0f);         // Start at base speed\n    m_energyAvgFollower.reset(0.0f);\n    m_energyDeltaFollower.reset(0.0f);\n    \n    // Initialize EMA smoothing\n    m_energyDeltaEMASmooth = 0.0f;\n    m_energyDeltaEMAInitialized = false;\n    return true;\n}\n\nvoid LGPWaveCollisionEffect::render(plugins::EffectContext& ctx) {\n    // CENTRE ORIGIN WAVE COLLISION - Wave packets expand outward from centre and collide\n    float speedNorm = ctx.speed / 50.0f;\n    float intensityNorm = ctx.brightness / 255.0f;\n    const bool hasAudio = ctx.audio.available;\n    bool newHop = false;\n\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n        if (newHop) {\n            m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n\n            const float led_share = 255.0f / 12.0f;\n            float chromaEnergy = 0.0f;\n            for (uint8_t i = 0; i < 12; ++i) {\n                float bin = ctx.audio.controlBus.chroma[i];\n                float bright = bin * bin;\n                bright *= 1.5f;\n                if (bright > 1.0f) bright = 1.0f;\n                chromaEnergy += bright * led_share;\n            }\n            float energyNorm = chromaEnergy / 255.0f;\n            if (energyNorm < 0.0f) energyNorm = 0.0f;\n            if (energyNorm > 1.0f) energyNorm = 1.0f;\n\n            m_chromaEnergySum -= m_chromaEnergyHist[m_chromaHistIdx];\n            m_chromaEnergyHist[m_chromaHistIdx] = energyNorm;\n            m_chromaEnergySum += energyNorm;\n            m_chromaHistIdx = (m_chromaHistIdx + 1) % CHROMA_HISTORY;\n\n            m_energyAvg = m_chromaEnergySum / CHROMA_HISTORY;\n            m_energyDelta = energyNorm - m_energyAvg;\n            if (m_energyDelta < 0.0f) m_energyDelta = 0.0f;\n        }\n    } else\n#endif\n    {\n        // dt-corrected decay when audio unavailable (matches Enhanced version)\n        float dtFallback = enhancement::getSafeDeltaSeconds(ctx.rawDeltaTimeSeconds);\n        m_energyAvg *= powf(0.98f, dtFallback * 60.0f);\n        m_energyDelta = 0.0f;\n    }\n\n    float rawDt = enhancement::getSafeDeltaSeconds(ctx.rawDeltaTimeSeconds);\n    float dt = enhancement::getSafeDeltaSeconds(ctx.deltaTimeSeconds);\n\n    // EMA smoothing for energyDelta (prevents pops from spiky audio features)\n    const float tau = 0.05f;  // 50ms time constant\n    float alpha = 1.0f - expf(-rawDt / tau);\n    \n    // CRITICAL: Initialize to raw value on first frame (no ramp-from-zero)\n    if (!m_energyDeltaEMAInitialized && ctx.audio.available) {\n        m_energyDeltaEMASmooth = m_energyDelta;\n        m_energyDeltaEMAInitialized = true;\n    } else {\n        m_energyDeltaEMASmooth += (m_energyDelta - m_energyDeltaEMASmooth) * alpha;\n    }\n    \n    // Use EMA-smoothed energyDelta for further processing\n    float energyDeltaForSmoothing = m_energyDeltaEMASmooth;\n\n    // True exponential smoothing with AsymmetricFollower (frame-rate independent)\n    float moodNorm = ctx.mood / 255.0f;  // 0=reactive, 1=smooth\n    float energyAvgSmooth = m_energyAvgFollower.updateWithMood(m_energyAvg, rawDt, moodNorm);\n    float energyDeltaSmooth = m_energyDeltaFollower.updateWithMood(energyDeltaForSmoothing, rawDt, moodNorm);\n\n    // Circular chroma hue (replaces argmax + linear EMA to eliminate bin-flip rainbow sweeps)\n    uint8_t chromaHue = effects::chroma::circularChromaHueSmoothed(\n        ctx.audio.controlBus.chroma, m_chromaAngle, rawDt, 0.20f);\n\n    // Percussion-driven collision boost (snare = collision event!)\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio && ctx.audio.isSnareHit()) {\n        m_collisionBoost = 1.0f;  // Force max brightness on snare hit\n    } else {\n        // Fallback: energy delta still contributes, but weaker\n        m_collisionBoost += energyDeltaSmooth * 0.4f;\n    }\n    if (m_collisionBoost > 1.0f) m_collisionBoost = 1.0f;\n    m_collisionBoost = effects::chroma::dtDecay(m_collisionBoost, 0.88f, rawDt);  // dt-corrected decay for snappier response\n\n    // Hi-hat driven speed burst\n    if (hasAudio && ctx.audio.isHihatHit()) {\n        m_speedTarget = 1.6f;  // Temporary speed boost on hi-hat\n    }\n    // Decay speed target back to normal (exponential smoothing)\n    m_speedTarget = m_speedTarget * 0.95f + 1.0f * 0.05f;\n\n    // Use heavy_bands for smoother bass energy (replaces raw chroma energy)\n    float bassEnergy = ctx.audio.heavyBass();  // Already averages heavy_bands[0] + [1]\n#else\n    m_collisionBoost += energyDeltaSmooth * 0.4f;\n    if (m_collisionBoost > 1.0f) m_collisionBoost = 1.0f;\n    m_collisionBoost = effects::chroma::dtDecay(m_collisionBoost, 0.88f, rawDt);\n    m_speedTarget = m_speedTarget * 0.95f + 1.0f * 0.05f;\n    float bassEnergy = energyAvgSmooth;\n#endif\n\n    // Speed modulation with Spring physics (natural momentum, no jitter)\n    // Now modulated by bassEnergy (from heavy_bands) and speedTarget (from hi-hat)\n    float rawSpeedScale = (0.7f + 0.6f * bassEnergy) * m_speedTarget;  // Capture raw speed for validation\n    float speedTargetClamped = rawSpeedScale;\n    if (speedTargetClamped > 1.6f) speedTargetClamped = 1.6f;  // Allow higher speed with hi-hat boost\n\n    // Spring physics for speed modulation (replaces linear slew limiting)\n    float smoothedSpeed = m_speedSpring.update(speedTargetClamped, rawDt);\n    if (smoothedSpeed > 1.6f) smoothedSpeed = 1.6f;  // Hard clamp\n    if (smoothedSpeed < 0.3f) smoothedSpeed = 0.3f;  // Prevent stalling\n\n    // Capture phase before update for delta calculation\n    float prevPhase = m_phase;\n    // FIX: Use 240.0f multiplier like ChevronWaves (was 4.0f - 60x slower!)\n    // Fast phase accumulation makes forward motion perceptually dominant\n    m_phase += speedNorm * 240.0f * smoothedSpeed * dt;\n    if (m_phase > 628.3f) m_phase -= 628.3f;  // Wrap at 100*2Ï€ to prevent float overflow\n    float phaseDelta = m_phase - prevPhase;\n\n    // Validation instrumentation\n    VALIDATION_INIT(17);  // Effect ID 17\n    VALIDATION_PHASE(m_phase, phaseDelta);\n    VALIDATION_SPEED(rawSpeedScale, smoothedSpeed);\n    VALIDATION_AUDIO(m_chromaAngle, energyAvgSmooth, energyDeltaSmooth);\n    VALIDATION_REVERSAL_CHECK(m_prevPhaseDelta, phaseDelta);\n    VALIDATION_SUBMIT(::lightwaveos::validation::g_validationRing);\n    m_prevPhaseDelta = phaseDelta;\n\n    fadeToBlackBy(ctx.leds, ctx.ledCount, ctx.fadeAmount);\n\n    // Anti-aliased collision core at true center (79.5) using SubpixelRenderer\n    if (m_collisionBoost > 0.05f) {\n        float intensityNorm = ctx.brightness / 255.0f;\n        uint8_t baseHue = (uint8_t)(ctx.gHue + chromaHue);\n        CRGB collisionColor = ctx.palette.getColor(baseHue, 255);\n        uint8_t collisionBright = (uint8_t)(m_collisionBoost * 200.0f * intensityNorm);\n\n        // Render bright core at fractional center (between LED 79 and 80)\n        enhancement::SubpixelRenderer::renderPoint(\n            ctx.leds, STRIP_LENGTH, 79.5f, collisionColor, collisionBright\n        );\n\n        // Also render on strip 2\n        if (STRIP_LENGTH * 2 <= ctx.ledCount) {\n            enhancement::SubpixelRenderer::renderPoint(\n                ctx.leds + STRIP_LENGTH, STRIP_LENGTH, 79.5f,\n                ctx.palette.getColor(baseHue + 90, 255), collisionBright\n            );\n        }\n    }\n\n    for (int i = 0; i < STRIP_LENGTH; i++) {\n        // CENTRE ORIGIN: Calculate distance from centre pair\n        float distFromCenter = (float)centerPairDistance((uint16_t)i);\n\n        // WAVE COLLISION: Two counter-propagating wave packets that collide at centre\n        // sin(k*dist - phase) = OUTWARD motion, sin(k*dist + phase) = INWARD motion\n        // Their sum creates standing wave nodes with travelling collision events\n        const float freqBase = 0.15f;  // ~42 LED wavelength (vs Scanner's ~25-31)\n        float waveOutward = sinf(distFromCenter * freqBase - m_phase);\n        float waveInward = sinf(distFromCenter * freqBase + m_phase);\n\n        // Sum creates interference: constructive at nodes, destructive at antinodes\n        // The beating pattern appears to \"collide\" at the centre\n        float waveSum = (waveOutward + waveInward) * 0.5f;\n\n        // COLLISION FLASH: Center-focused explosion on snare hits\n        // collisionBoost decays from 1.0 (snare hit) with spatial falloff from center\n        float collisionFlash = m_collisionBoost * expf(-distFromCenter * 0.12f);  // Bright at center, fades out\n\n        // Base audio intensity (without uniform collision boost - moved to spatial flash)\n        float audioIntensity = 0.4f + 0.5f * energyAvgSmooth + 0.4f * energyDeltaSmooth;\n        float interference = waveSum * audioIntensity + collisionFlash * 0.8f;  // Collision adds separate layer\n\n        // CRITICAL: Use tanhf for uniform brightness (like ChevronWaves)\n        interference = tanhf(interference * 2.0f) * 0.5f + 0.5f;\n\n        uint8_t brightness = (uint8_t)(interference * 255.0f * intensityNorm);\n\n        // CENTRE ORIGIN colour mapping\n        uint8_t paletteIndex = (uint8_t)(distFromCenter * 2.0f + interference * 50.0f);\n        uint8_t baseHue = (uint8_t)(ctx.gHue + chromaHue);\n\n        // Blend with existing pixel (preserves trails from fadeToBlackBy)\n        // nblend uses 8-bit amount: 0=keep existing, 255=full replace\n        CRGB newColor = ctx.palette.getColor((uint8_t)(baseHue + paletteIndex), brightness);\n        nblend(ctx.leds[i], newColor, 180);  // ~70% new, ~30% existing\n        \n        if (i + STRIP_LENGTH < ctx.ledCount) {\n            // FIX: Hue offset +90 matches ChevronWaves pattern (was +128)\n            CRGB newColor2 = ctx.palette.getColor((uint8_t)(baseHue + paletteIndex + 90), brightness);\n            nblend(ctx.leds[i + STRIP_LENGTH], newColor2, 180);  // Apply same blend to BOTH strips\n        }\n    }\n}\n\nvoid LGPWaveCollisionEffect::cleanup() {\n    // No resources to free\n}\n\nconst plugins::EffectMetadata& LGPWaveCollisionEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"LGP Wave Collision\",\n        \"Colliding wave fronts creating standing nodes\",\n        plugins::EffectCategory::QUANTUM,\n        1\n    };\n    return meta;\n}\n\n} // namespace ieffect\n} // namespace effects\n} // namespace lightwaveos\n"
}
