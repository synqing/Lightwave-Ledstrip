{
  "schemaVersion": "2.0.0",
  "generatedAtUtc": "2026-02-25T01:16:03Z",
  "firmwareSourceHash": "867836f805a20b5903d4e8b8d260368364f51dd60a9b7208dc990b4103e4e30b",
  "effectId": "EID_RIPPLE_ES_TUNED",
  "effectIdHex": "0x1200",
  "className": "RippleEsTunedEffect",
  "displayName": "Ripple (ES tuned)",
  "headerPath": "firmware/v2/src/effects/ieffect/RippleEsTunedEffect.h",
  "sourcePath": "firmware/v2/src/effects/ieffect/RippleEsTunedEffect.cpp",
  "renderRange": [
    64,
    244
  ],
  "phaseRanges": {
    "input": [
      [
        67,
        68
      ],
      [
        73,
        73
      ],
      [
        86,
        86
      ],
      [
        88,
        88
      ],
      [
        94,
        94
      ],
      [
        108,
        108
      ],
      [
        115,
        115
      ],
      [
        130,
        130
      ],
      [
        149,
        150
      ],
      [
        163,
        163
      ],
      [
        192,
        192
      ]
    ],
    "mapping": [
      [
        85,
        113
      ]
    ],
    "modulation": [
      [
        115,
        117
      ],
      [
        119,
        120
      ],
      [
        122,
        122
      ],
      [
        128,
        128
      ],
      [
        131,
        131
      ],
      [
        145,
        145
      ],
      [
        147,
        147
      ],
      [
        149,
        150
      ],
      [
        152,
        153
      ],
      [
        155,
        155
      ],
      [
        165,
        166
      ],
      [
        183,
        186
      ],
      [
        192,
        192
      ],
      [
        198,
        199
      ]
    ],
    "render": [
      [
        93,
        93
      ],
      [
        107,
        107
      ],
      [
        195,
        195
      ],
      [
        207,
        207
      ],
      [
        228,
        228
      ],
      [
        241,
        241
      ]
    ],
    "post": [
      [
        71,
        71
      ],
      [
        79,
        79
      ],
      [
        81,
        81
      ],
      [
        217,
        219
      ]
    ],
    "output": [
      [
        235,
        244
      ]
    ]
  },
  "mappingConfidence": "medium",
  "mappingWarnings": [
    "Phase 'mapping' inferred from fallback segmentation.",
    "Phase 'output' inferred from fallback segmentation."
  ],
  "sourceText": "/**\n * @file RippleEsTunedEffect.cpp\n * @brief Ripple (ES tuned) effect implementation\n */\n\n#include \"RippleEsTunedEffect.h\"\n#include \"ChromaUtils.h\"\n\n#include \"../../config/features.h\"\n#include <FastLED.h>\n#include <cmath>\n#include <cstring>\n\n#ifndef NATIVE_BUILD\n#include <esp_heap_caps.h>\n#endif\n\nnamespace lightwaveos::effects::ieffect {\n\nRippleEsTunedEffect::RippleEsTunedEffect()\n    : m_ps(nullptr)\n{\n    for (uint8_t i = 0; i < MAX_RIPPLES; i++) {\n        m_ripples[i] = {};\n    }\n}\n\nbool RippleEsTunedEffect::init(plugins::EffectContext& ctx) {\n    (void)ctx;\n    for (uint8_t i = 0; i < MAX_RIPPLES; i++) {\n        m_ripples[i] = {};\n    }\n    m_lastHopSeq = 0;\n    m_spawnCooldown = 0;\n#ifndef NATIVE_BUILD\n    if (!m_ps) {\n        m_ps = static_cast<RippleEsTunedPsram*>(\n            heap_caps_malloc(sizeof(RippleEsTunedPsram), MALLOC_CAP_SPIRAM));\n        if (!m_ps) return false;\n    }\n    memset(m_ps, 0, sizeof(RippleEsTunedPsram));\n#endif\n    m_subBass = 0.0f;\n    m_treble = 0.0f;\n    m_fluxEnv = 0.0f;\n    m_chromaAngle = 0.0f;\n    m_baseHue = 0;\n    return true;\n}\n\nvoid RippleEsTunedEffect::spawnRipple(uint8_t hue, uint8_t intensity, float speed) {\n    for (uint8_t r = 0; r < MAX_RIPPLES; r++) {\n        if (!m_ripples[r].active) {\n            m_ripples[r].radius = 0.0f;\n            m_ripples[r].speed = speed;\n            m_ripples[r].hue = hue;\n            m_ripples[r].intensity = intensity;\n            m_ripples[r].active = true;\n            return;\n        }\n    }\n}\n\nvoid RippleEsTunedEffect::render(plugins::EffectContext& ctx) {\n    if (!m_ps) return;\n    const float rawDtEarly = ctx.getSafeRawDeltaSeconds();\n    const bool hasAudio = ctx.audio.available;\n    const bool tempoOk = hasAudio && (ctx.audio.tempoConfidence() >= 0.30f);\n\n    // Decay trails. Slightly louder music keeps more trail.\n    uint8_t fade = 42;\n    if (hasAudio) {\n        float rms = ctx.audio.rms();\n        if (rms < 0.0f) rms = 0.0f;\n        if (rms > 1.0f) rms = 1.0f;\n        float f = 52.0f - (18.0f * rms);\n        if (f < 28.0f) f = 28.0f;\n        if (f > 58.0f) f = 58.0f;\n        fade = static_cast<uint8_t>(f);\n    }\n    fadeToBlackBy(m_ps->radial, HALF_LENGTH, fade);\n\n    bool newHop = false;\n#if FEATURE_AUDIO_SYNC\n    if (hasAudio) {\n        newHop = (ctx.audio.controlBus.hop_seq != m_lastHopSeq);\n        if (newHop) {\n            m_lastHopSeq = ctx.audio.controlBus.hop_seq;\n\n            // FFT energy summaries (prefer adaptive bins when present).\n            // ES backend populates bins64 + bins64Adaptive; use adaptive for stability.\n            float subBassSum = 0.0f;\n            for (uint8_t i = 0; i < 6; i++) {\n                subBassSum += ctx.audio.binAdaptive(i);\n            }\n            float subBass = subBassSum * (1.0f / 6.0f);\n            if (subBass > 1.0f) subBass = 1.0f;\n            if (subBass < 0.0f) subBass = 0.0f;\n            // Fast attack / medium decay to feel punchy but stable.\n            if (subBass > m_subBass) {\n                m_subBass = subBass;\n            } else {\n                m_subBass = (m_subBass * 0.86f) + (subBass * 0.14f);\n            }\n\n            float trebleSum = 0.0f;\n            for (uint8_t i = 48; i < 64; i++) {\n                trebleSum += ctx.audio.binAdaptive(i);\n            }\n            float treble = trebleSum * (1.0f / 16.0f);\n            if (treble > 1.0f) treble = 1.0f;\n            if (treble < 0.0f) treble = 0.0f;\n            m_treble = (m_treble * 0.80f) + (treble * 0.20f);\n\n            float flux = ctx.audio.fastFlux();\n            if (flux < 0.0f) flux = 0.0f;\n            if (flux > 1.0f) flux = 1.0f;\n            // Transient envelope: instant-ish attack, fast-ish decay.\n            if (flux > m_fluxEnv) {\n                m_fluxEnv = flux;\n            } else {\n                m_fluxEnv = effects::chroma::dtDecay(m_fluxEnv, 0.82f, rawDtEarly);\n            }\n\n        }\n\n        // Circular chroma hue (prevents argmax discontinuities and wrapping artefacts).\n        // Runs every frame for smooth tracking, not just on hops.\n        float rawDt = ctx.getSafeRawDeltaSeconds();\n        const float* chroma = ctx.audio.controlBus.chroma;\n        m_baseHue = effects::chroma::circularChromaHueSmoothed(\n            chroma, m_chromaAngle, rawDt, 0.20f);\n    }\n#endif\n\n    if (m_spawnCooldown > 0) {\n        m_spawnCooldown--;\n    }\n\n    // Unified speed scaling from slider: 0..50 â†’ ~0.6..2.4\n    float speedScale = 0.6f + (1.8f * (ctx.speed / 50.0f));\n    if (speedScale < 0.25f) speedScale = 0.25f;\n\n    // Spawn logic:\n    // - Beat-locked spawns when tempo is reliable.\n    // - Kick + snare can force spawns.\n    // - Flux can add extra micro-spawns on sharp transients.\n    if (hasAudio && m_spawnCooldown == 0) {\n        const float beatStrength = tempoOk ? ctx.audio.beatStrength() : 0.0f;\n        const bool beatTick = tempoOk && ctx.audio.isOnBeat();\n\n        // Base intensity driven by sub-bass + flux. Beat strength boosts when tempo locked.\n        float intensity01 = 0.25f + (0.55f * m_subBass) + (0.45f * m_fluxEnv);\n        if (tempoOk) {\n            intensity01 *= 0.75f + (0.60f * beatStrength);\n        }\n        if (intensity01 > 1.0f) intensity01 = 1.0f;\n        if (intensity01 < 0.0f) intensity01 = 0.0f;\n        uint8_t intensity = static_cast<uint8_t>(intensity01 * 255.0f);\n\n        // Kick detection: lower threshold than legacy Ripple, tuned for ES adaptive bins.\n        const bool kick = (m_subBass > 0.35f);\n        const bool snare = ctx.audio.isSnareHit();\n\n        // Beat spawns: predictable pulse when locked.\n        if (beatTick && (beatStrength > 0.18f)) {\n            float spd = speedScale * (0.85f + (0.40f * m_subBass));\n            spawnRipple(static_cast<uint8_t>(m_baseHue + ctx.gHue), intensity, spd);\n            m_spawnCooldown = 1;\n        }\n\n        // Force spawns for kick/snare (even if tempo is poor).\n        if (kick) {\n            float spd = speedScale * (1.00f + (0.50f * m_subBass));\n            uint8_t hue = static_cast<uint8_t>(ctx.gHue + m_baseHue + (uint8_t)(m_subBass * 30.0f));\n            spawnRipple(hue, 255, spd);\n            m_spawnCooldown = 2;\n        } else if (snare) {\n            float spd = speedScale * 1.15f;\n            uint8_t hue = static_cast<uint8_t>(m_baseHue + 64);\n            spawnRipple(hue, 230, spd);\n            m_spawnCooldown = 1;\n        } else if (m_fluxEnv > 0.55f && (!tempoOk || !beatTick)) {\n            // Flux accent spawns (only when not already beat-spawning) to avoid overload.\n            float spd = speedScale * (0.75f + (0.35f * m_fluxEnv));\n            spawnRipple(static_cast<uint8_t>(m_baseHue + ctx.gHue), (uint8_t)(180 + (m_fluxEnv * 60.0f)), spd);\n            m_spawnCooldown = 1;\n        }\n    }\n\n    // Update and render ripples into radial history buffer.\n    const float beatStrengthNow = (tempoOk ? ctx.audio.beatStrength() : 0.0f);\n    const float thickness = 2.0f + (4.0f * m_treble);  // treble = thicker, brighter edge\n\n    for (uint8_t r = 0; r < MAX_RIPPLES; r++) {\n        if (!m_ripples[r].active) continue;\n\n        // Growth rate responds to beat strength + sub-bass.\n        float growth = m_ripples[r].speed * (0.85f + (0.35f * beatStrengthNow) + (0.25f * m_subBass));\n        m_ripples[r].radius += growth;\n\n        if (m_ripples[r].radius > HALF_LENGTH) {\n            m_ripples[r].active = false;\n            continue;\n        }\n\n        for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n            float wavePos = static_cast<float>(dist) - m_ripples[r].radius;\n            float waveAbs = fabsf(wavePos);\n            if (waveAbs < thickness) {\n                float front01 = 1.0f - (waveAbs / thickness);\n                if (front01 < 0.0f) front01 = 0.0f;\n                if (front01 > 1.0f) front01 = 1.0f;\n\n                uint8_t b = static_cast<uint8_t>(front01 * 255.0f);\n\n                // Edge fade to keep the centre clean.\n                uint8_t edgeFade = (uint8_t)((HALF_LENGTH - m_ripples[r].radius) * 255.0f / HALF_LENGTH);\n                b = scale8(b, edgeFade);\n                b = scale8(b, m_ripples[r].intensity);\n\n                // Treble shimmer: add sparkle to the leading edge.\n                if (m_treble > 0.08f) {\n                    uint8_t shimmerBoost = (uint8_t)(m_treble * front01 * 70.0f);\n                    b = qadd8(b, shimmerBoost);\n                }\n\n                CRGB color = ctx.palette.getColor((uint8_t)(m_ripples[r].hue + dist), b);\n                // Pre-scale so multiple overlapping ripples stay in range (colour corruption fix)\n                constexpr uint8_t RIPPLE_PRE_SCALE = 85;  // ~3 overlapping ripples sum to 255\n                color = color.nscale8(RIPPLE_PRE_SCALE);\n                m_ps->radial[dist].r = qadd8(m_ps->radial[dist].r, color.r);\n                m_ps->radial[dist].g = qadd8(m_ps->radial[dist].g, color.g);\n                m_ps->radial[dist].b = qadd8(m_ps->radial[dist].b, color.b);\n            }\n        }\n    }\n\n    memcpy(m_ps->radialAux, m_ps->radial, sizeof(m_ps->radial));\n\n    for (uint16_t dist = 0; dist < HALF_LENGTH; ++dist) {\n        SET_CENTER_PAIR(ctx, dist, m_ps->radialAux[dist]);\n    }\n}\n\nvoid RippleEsTunedEffect::cleanup() {\n#ifndef NATIVE_BUILD\n    if (m_ps) {\n        heap_caps_free(m_ps);\n        m_ps = nullptr;\n    }\n#endif\n}\n\nconst plugins::EffectMetadata& RippleEsTunedEffect::getMetadata() const {\n    static plugins::EffectMetadata meta{\n        \"Ripple (ES tuned)\",\n        \"Beat-locked ripples tuned for ES v1.1 audio backend\",\n        plugins::EffectCategory::WATER,\n        1\n    };\n    return meta;\n}\n\n} // namespace lightwaveos::effects::ieffect\n\n"
}
