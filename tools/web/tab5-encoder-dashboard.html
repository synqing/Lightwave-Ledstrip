<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tab5 Encoder Dashboard (Cyberpunk FastGauge Sim)</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #ccc;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }

        h1 { margin-bottom: 10px; font-weight: 300; }
        
        /* Container for the 1280x720 Display */
        #display-container {
            position: relative;
            width: 1280px;
            height: 720px;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border: 2px solid #333;
            background: #000;
            /* Scale down for smaller screens */
            transform-origin: top center;
            transform: scale(0.8); 
        }

        canvas {
            display: block;
        }

        /* Controls Area */
        #controls {
            margin-top: -120px; /* Adjust for scale transform */
            width: 1000px;
            background: #222;
            padding: 20px;
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            border: 1px solid #444;
        }

        .control-group {
            background: #333;
            padding: 10px;
            border-radius: 4px;
            text-align: center;
        }

        .control-group label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #aaa;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        .btn-row {
            margin-top: 20px;
            display: flex;
            gap: 20px;
        }

        button {
            padding: 10px 20px;
            background: #007acc;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button:hover { background: #005f9e; }
        button.stop { background: #cc3300; }
        button.stop:hover { background: #9e2700; }

    </style>
</head>
<body>

    <h1>Tab5 Encoder // FastGauge Simulation</h1>

    <div id="display-container">
        <canvas id="mainCanvas" width="1280" height="720"></canvas>
    </div>

    <div class="btn-row">
        <button id="btn-demo" onclick="toggleDemo()">Start Random Demo</button>
        <button onclick="resetAll()">Reset All</button>
    </div>

    <div id="controls">
        </div>

<script>
    // ==========================================
    // 1. STYLE & CONSTANTS (Ported from Theme.h)
    // ==========================================
    
    // Helper: Convert RGB565 to Hex String
    function rgb565toHex(val) {
        const r = (val >> 11) & 0x1F;
        const g = (val >> 5) & 0x3F;
        const b = val & 0x1F;
        
        // Scale to 8-bit
        const R = Math.round((r * 255) / 31);
        const G = Math.round((g * 255) / 63);
        const B = Math.round((b * 255) / 31);
        
        return `rgb(${R}, ${G}, ${B})`;
    }

    // Helper: Dim color (Integer math simulation)
    function scaleColor(rgbStr, scale) {
        // Parse rgb(r, g, b)
        const parts = rgbStr.match(/\d+/g).map(Number);
        const R = Math.floor(parts[0] * scale / 255);
        const G = Math.floor(parts[1] * scale / 255);
        const B = Math.floor(parts[2] * scale / 255);
        return `rgb(${R}, ${G}, ${B})`;
    }

    const COL_BG = rgb565toHex(0x0841); // #0a0a14
    const COL_OFF = rgb565toHex(0x18E3);
    const COL_TEXT = "#FFFFFF";

    const PARAM_COLORS_RAW = [
        0xF810, 0xFFE0, 0x07FF, 0xFA20, 0xF81F, 0x07F1, 0x901F, 0x047F, 
        0x07FF, 0x05DF, 0xFD20, 0xFBE0, 0x07E0, 0x47E0, 0xA01F, 0xC01F  
    ];
    
    const PARAM_NAMES = [
        "EFFECT", "BRIGHT", "PALETTE", "SPEED", "INTENS", "SATUR", "CMPLX", "VAR",
        "Z0-FX", "Z0-BRI", "Z1-FX", "Z1-BRI", "Z2-FX", "Z2-BRI", "Z3-FX", "Z3-BRI"
    ];

    const PARAM_COLORS = PARAM_COLORS_RAW.map(rgb565toHex);

    // ==========================================
    // 2. WIDGET LOGIC (Ported from FastGauge.cpp)
    // ==========================================

    class FastGauge {
        constructor(ctx, x, y, w, h, index) {
            this.ctx = ctx;
            this.x = x; 
            this.y = y; 
            this.w = w; 
            this.h = h;
            this.index = index;
            this.title = PARAM_NAMES[index];
            this.baseColor = PARAM_COLORS[index];
            
            // State
            this.targetValue = 0;
            this.curValue = 0.0;
            this.peakValue = 0;
            this.peakTimer = 0;
            this.highlighted = false;
            this.flashIntensity = 0;
            this.dirty = true;
        }

        setValue(val) {
            val = Math.max(0, Math.min(255, parseInt(val)));
            
            if (val !== this.targetValue) {
                // Flash Logic
                if (val === 0 || val === 255) {
                    this.flashIntensity = 200; // Hit limit
                } else if (Math.abs(val - this.curValue) > 10) {
                    this.flashIntensity = 100; // Fast turn
                }

                // Peak Logic
                if (val > this.peakValue) {
                    this.peakValue = val;
                    this.peakTimer = Date.now();
                }

                this.targetValue = val;
                this.dirty = true;
            }
        }

        setHighlight(active) {
            if (this.highlighted !== active) {
                this.highlighted = active;
                this.dirty = true;
            }
        }

        update(dt) {
            let needsRender = this.dirty;

            // 1. Smoothing (Lerp)
            if (Math.abs(this.curValue - this.targetValue) > 0.5) {
                this.curValue += (this.targetValue - this.curValue) * 0.3;
                needsRender = true;
            } else {
                this.curValue = this.targetValue;
            }

            // 2. Flash Decay
            if (this.flashIntensity > 0) {
                // Decay over ~400ms (assuming dt in ms)
                let decay = Math.floor((dt * 255) / 400); 
                this.flashIntensity = Math.max(0, this.flashIntensity - decay);
                needsRender = true;
            }

            // 3. Peak Decay
            const now = Date.now();
            if (this.peakValue > this.targetValue) {
                if (now - this.peakTimer > 1000) {
                    this.peakValue -= 1; // Slow fall
                    needsRender = true;
                }
            } else {
                this.peakValue = this.targetValue;
            }

            // Optimization: Only draw if something changed
            if (needsRender) {
                this.draw();
                this.dirty = false;
            }
        }

        draw() {
            const ctx = this.ctx;
            const cx = this.x + this.w / 2;
            const cy = this.y + this.h / 2 + 5;
            const r = Math.min(this.w, this.h) / 2 - 10; // Padding

            // Clear Rect
            ctx.fillStyle = COL_BG;
            // Flash Background effect
            if (this.flashIntensity > 0) {
                // Blend base color into BG based on intensity
                // Simple additive approximation
                ctx.fillStyle = scaleColor(this.baseColor, 20 + (this.flashIntensity * 0.3));
            }
            ctx.fillRect(this.x, this.y, this.w, this.h);

            // Highlight Border
            if (this.highlighted) {
                ctx.strokeStyle = this.baseColor;
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x + 1, this.y + 1, this.w - 2, this.h - 2);
            } else {
                // Dim Grid line
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 1;
                ctx.strokeRect(this.x, this.y, this.w, this.h);
            }

            // Gauge Constants
            const startAngle = 135 * (Math.PI / 180);
            const endAngle = 405 * (Math.PI / 180);
            
            // Canvas Arc: 0 is 3 o'clock. We need to rotate coordinates or map angles.
            // M5Stack 0 is top (usually), but code says 135-405.
            // Visual check: 135 is bottom left, 405 is bottom right.
            // Canvas: 90 is bottom. 
            // Let's map: 135deg -> (135+90) = 225? No.
            // Standard Math: 0=Right, 90=Down, 180=Left, 270=Up.
            // We want 135 (Left-Down) to 405 (Right-Down).
            // Canvas angles: 135 deg = 2.35 rad. 
            
            const startRad = (135 * Math.PI / 180); // Bottom Leftish
            const endRad = (405 * Math.PI / 180);   // Bottom Rightish (overlap 0)

            // 1. Draw Track (Dim)
            ctx.beginPath();
            ctx.arc(cx, cy, r, startRad, endRad);
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.strokeStyle = scaleColor(this.baseColor, 50); // Very dim version of base color
            ctx.stroke();

            // 2. Draw Value Arc (Bright)
            const valNorm = this.curValue / 255;
            const curRad = startRad + (valNorm * (endRad - startRad));
            
            ctx.beginPath();
            ctx.arc(cx, cy, r, startRad, curRad);
            ctx.lineWidth = 8;
            ctx.strokeStyle = this.baseColor;
            
            // Add Glow (Shadow)
            if (this.highlighted) {
                ctx.shadowBlur = 15;
                ctx.shadowColor = this.baseColor;
            } else {
                ctx.shadowBlur = 0;
            }
            
            ctx.stroke();
            ctx.shadowBlur = 0; // Reset

            // 3. Peak Indicator
            const peakNorm = this.peakValue / 255;
            const peakRad = startRad + (peakNorm * (endRad - startRad));
            ctx.beginPath();
            ctx.arc(cx, cy, r + 6, peakRad - 0.05, peakRad);
            ctx.lineWidth = 4;
            ctx.strokeStyle = "#fff";
            ctx.stroke();

            // 4. Text Value
            ctx.fillStyle = "#fff";
            ctx.font = "bold 32px 'Segoe UI', sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(Math.round(this.curValue), cx, cy - 10);

            // 5. Label
            ctx.fillStyle = scaleColor(this.baseColor, 180);
            ctx.font = "bold 14px 'Segoe UI', sans-serif";
            ctx.textBaseline = "bottom";
            ctx.fillText(this.title, cx, this.y + this.h - 10);
        }
    }

    // ==========================================
    // 3. MAIN SETUP & LOOP
    // ==========================================

    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d');
    const gauges = [];

    // Layout
    const TOP_MARGIN = 10;
    const GRID_COLS = 4;
    const GRID_ROWS = 4;
    const CELL_W = 1280 / GRID_COLS;
    const CELL_H = (720 - TOP_MARGIN) / GRID_ROWS;

    // Initialize Gauges
    for(let i=0; i<16; i++) {
        const r = Math.floor(i / GRID_COLS);
        const c = i % GRID_COLS;
        gauges.push(new FastGauge(
            ctx,
            c * CELL_W,
            TOP_MARGIN + (r * CELL_H),
            CELL_W,
            CELL_H,
            i
        ));
    }

    // Generate HTML Controls
    const controlsDiv = document.getElementById('controls');
    gauges.forEach((g, i) => {
        const div = document.createElement('div');
        div.className = 'control-group';
        div.innerHTML = `
            <label style="color:${g.baseColor}">${i}. ${g.title}</label>
            <input type="range" min="0" max="255" value="0" 
                   oninput="updateGauge(${i}, this.value)" 
                   onmousedown="highlightGauge(${i})"
            >
        `;
        controlsDiv.appendChild(div);
    });

    // Interaction Functions
    let highlightTimer = null;
    let currentHigh = -1;

    window.updateGauge = function(index, val) {
        gauges[index].setValue(val);
        highlightGauge(index);
    };

    window.highlightGauge = function(index) {
        // Clear old highlight
        if(currentHigh !== -1 && currentHigh !== index) {
            gauges[currentHigh].setHighlight(false);
        }
        
        currentHigh = index;
        gauges[index].setHighlight(true);

        // Reset timeout
        if(highlightTimer) clearTimeout(highlightTimer);
        highlightTimer = setTimeout(() => {
            if(currentHigh !== -1) {
                gauges[currentHigh].setHighlight(false);
                currentHigh = -1;
            }
        }, 2000);
    };
    
    window.resetAll = function() {
        gauges.forEach((g, i) => {
            g.setValue(0);
            // Reset slider
            document.querySelectorAll('input[type=range]')[i].value = 0;
        });
    }

    // Demo Mode
    let demoInterval = null;
    window.toggleDemo = function() {
        const btn = document.getElementById('btn-demo');
        if (demoInterval) {
            clearInterval(demoInterval);
            demoInterval = null;
            btn.textContent = "Start Random Demo";
            btn.classList.remove('stop');
        } else {
            btn.textContent = "Stop Demo";
            btn.classList.add('stop');
            demoInterval = setInterval(() => {
                // Pick random gauge
                const idx = Math.floor(Math.random() * 16);
                // Pick random value
                const val = Math.floor(Math.random() * 255);
                
                // Update slider and gauge
                const rangeInput = document.querySelectorAll('input[type=range]')[idx];
                rangeInput.value = val;
                updateGauge(idx, val);
            }, 100); // Fast updates
        }
    };

    // Main Loop
    let lastTime = Date.now();
    function loop() {
        requestAnimationFrame(loop);
        const now = Date.now();
        const dt = now - lastTime;
        lastTime = now;

        // Header Background
        ctx.fillStyle = COL_BG;
        ctx.fillRect(0, 0, 1280, TOP_MARGIN);
        ctx.fillStyle = "#444";
        ctx.fillRect(0, TOP_MARGIN-1, 1280, 1);

        gauges.forEach(g => g.update(dt));
    }

    // Start
    loop();

</script>
</body>
</html>

