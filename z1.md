## MODE: EXPLORATION — Audio pipeline audit (ESP32-S2 “Sensory Bridge” reference) + what to steal for K1

You’re right to flag this codebase. It contains a few **very “embedded-real” tricks** that are directly transferable to a mass-market visual music instrument—*but also a couple landmines you absolutely should not copy verbatim.*

Below is: **(1) the exact pipeline**, **(2) what each block buys you**, **(3) what’s broken / fragile**, and **(4) a locked recommendation for how to integrate the good parts into K1.**

---

# 1) What the reference pipeline actually does (call graph + dataflow)

### Init-time DSP prep (one-time)

From `init_system()`:

* `init_i2s()` sets I2S driver config and mic timing tweaks for ESP32-S2 (`i2s_audio.h`).
* `generate_a_weights()` builds per-bin A-weight ratios (`system.h:161+`).
* `generate_window_lookup()` builds a “Hann” lookup table (`system.h:197+`).
* `precompute_goertzel_constants()` builds **musically spaced Goertzel bins** + per-bin window length + fixed-point coefficient (`system.h:209+`).

You can see the order clearly in `system.h:315–320`.

### Runtime (every audio hop / frame)

The core “audio → features” path is:

1. **Capture + conditioning**
   `acquire_sample_chunk(t_now)` (`i2s_audio.h`)

   * reads `CONFIG.SAMPLES_PER_CHUNK` I2S samples
   * applies gain, clamps, subtracts DC offset
   * updates a **sample history window** (`sample_window[]`)
   * computes a simple loudness state and silence gating
   * converts to fixed-point `waveform_fixed_point[]` for later RMS

2. **Spectral transform (GDFT / Goertzel bank)**
   `process_GDFT()` (`GDFT.h`)

   * runs Goertzel across `NUM_FREQS=64` bins
   * bins are **semitone-spaced** (notes array) starting from `NOTE_OFFSET`
   * uses a **per-bin block_size** (window length) chosen from neighbor note spacing
   * produces `magnitudes_normalized_avg[]` then `spectrogram[]` (normalized by a follower AGC)

3. **Noise calibration / subtraction**
   Inside `process_GDFT()`

   * collects max noise per bin over 256 frames if calibration active
   * subtracts `noise_samples[i]*1.5` from magnitudes afterward

4. **Temporal smoothing + auto gain normalization**

   * `low_pass_array(...)` smooths `magnitudes_final` (not in provided files, but called at `GDFT.h:148–150`)
   * a global follower `goertzel_max_value` normalizes the whole spectrogram (AGC-ish)

5. **Novelty (onset-ish) feature**
   `calculate_novelty(t_now)` (`GDFT.h:202+`)

   * computes positive frame-to-frame change of spectrogram (a spectral flux variant)
   * writes `novelty_curve[]`

This is basically: **I2S → history buffer → Goertzel note-bank → noise gate → smoothing/AGC → novelty**.

---

# 2) The “good stuff” worth stealing for K1 (and why it matters at scale)

## A) Musically spaced Goertzel bins (note-aligned bank)

The notes array in `constants.h:56+` is equal-tempered note frequencies. Then:

* `frequencies[i].target_freq = notes[n + CONFIG.NOTE_OFFSET]` (`system.h:212`)
* `NUM_FREQS=64` gives 64 semitone bins (a very “musical” spectrum).

**Why this is gold for visuals:**
Note-aligned bins make **chroma**, **harmonic motion**, and “instrument-ish” visual layers much more stable than linear FFT bins—because your bins land where music actually lives.

## B) Per-bin window length selection

This is the clever bit:

* It measures max neighbor spacing in Hz and sets:
  `block_size = sample_rate / (max_distance_hz * 2)` (`system.h:228–239`)

Result:

* low notes → larger block_size (better frequency resolution)
* high notes → smaller block_size (better temporal responsiveness)

**Why this is gold:**
It’s a built-in tradeoff tuner that “feels musical” without needing a huge FFT. For mass users, it helps across genres because it naturally adapts the time/frequency compromise over pitch.

## C) Precomputed fixed-point Goertzel coefficients

They compute:

* `k = round((block_size * target_freq) / sample_rate)`
* `coeff = 2*cos(2πk/N)`
* store as **Q14** fixed-point: `coeff_q14` (`system.h:246–252`)

**Why this matters at scale:**
It keeps runtime deterministic and cheaper on MCU (especially if you later stagger banks). Precompute once, reuse forever.

## D) Noise calibration + subtraction per bin

Their noise calibration is crude but practical:

* “learn max noise per bin” then subtract `*1.5` (`GDFT.h:121–146`)

**Why it matters:**
Real homes = HVAC, fans, desk vibration. Per-bin noise subtraction is a huge usability win for “all humans.”

## E) Novelty curve from positive spectral change

`calculate_novelty()` is basically an onset function (spectral flux, half-wave rectified, averaged, sqrt).

**Why you care:**
That novelty curve is a better beat/onset evidence stream than raw waveform peaks for many genres—*as long as you guard against fast hats stealing the clock* (which ties directly back to your tempo tracker issues).

---

# 3) The “do NOT copy” parts (two big landmines)

## Landmine 1 — Their “Hann window lookup” is mathematically wrong for int16

They compute:

```c
weighing_factor = 0.54 * (1.0 - cos(2πx))
window_lookup[i] = 32767 * weighing_factor
```

At x≈0.5, `(1 - cos(π)) = 2`, so `weighing_factor = 1.08`, and `32767*1.08 ≈ 35388`, which **overflows int16** (max 32767).
So if you enable the window multiply (it’s currently commented out in `GDFT.h:91`), you can literally inject sign flips into your samples.

**Interpretation:** they probably disabled windowing because of this (or performance), but left the generator in.

✅ Takeaway: **Window LUT is a good idea, but this implementation is unsafe.**

## Landmine 2 — Their A-weighting conversion is not “correct” for amplitude

They convert dB to ratio using:

* `bels = dB/10` then `ratio = 10^bels` (`system.h:164–167`)

That corresponds to a **power ratio**, not an amplitude ratio (amplitude would use dB/20).
They also clamp ratios to ≤1.0 (`system.h:190–192`), so it only attenuates.

✅ Takeaway: **A-weighting as a concept is useful**, but don’t treat this as a reference implementation for correctness.

## Landmine 3 — Their sample history update does an O(N) shift every hop

In `acquire_sample_chunk()` they shift the `sample_window[]` by `SAMPLE_HISTORY_LENGTH - chunk` every call.

It’s probably “fine” on their settings, but for K1 (higher FPS targets + more layers + beat tracker) it’s wasted work and cache-unfriendly.

✅ Takeaway: use a **ring buffer**, not a shift buffer.

---

# 4) What this unlocks for K1 specifically (optimization + quality improvements)

Here are the concrete opportunities this reference suggests for your K1 stack:

## Opportunity 1 — Split your analysis into two banks (rhythm vs harmony)

This reference is **note bank from ~110 Hz up**. That’s great for harmony/chroma, but beat/kick often lives below that (and even when not, hats will dominate novelty).

For K1 quality:

* **Harmony bank:** semitone bins (like this)
* **Rhythm bank:** dedicated low-frequency bins (kick/snare emphasis), *not A-weighted*

This one change makes your tempo tracker far more robust across genres and rooms.

## Opportunity 2 — Staggered / interlaced computation (free performance)

They hint at this with `interlace_flip` (“switch field every frame on lower notes”) (`GDFT.h:65–67`) even though it’s not implemented in the snippet.

For K1:

* compute low bins every hop (rhythm-critical)
* compute high bins every other hop (visual texture tolerates it)
* maintain smoothing so visuals don’t alias

This buys you headroom for better beat tracking and rendering.

## Opportunity 3 — Per-band normalization + noise floor makes visuals portable

Their per-bin noise subtraction + global AGC follower creates a “self-leveling” spectrogram.
For mass-market, the big win is: **different mics / rooms don’t totally change the show.**

But for K1, you’ll want:

* separate AGC for rhythm evidence vs color/harmony (so hats don’t normalize away kicks)

## Opportunity 4 — Novelty curve becomes your “onset bus”… with the guardrail you already identified

Their novelty is a good onset stream—but your earlier failure case (fast ~0.12s onsets) is exactly the “hats steal the clock” problem.

So: novelty is great **if** your tempo tracker:

* candidate-gates intervals
* accumulates evidence (density buffer)
* doesn’t let every micro-onset reset the IOI clock

That aligns with the specialist agent’s “Path B + beat-candidate gating” recommendation.

---

# Decision Record (ADR-001)

**Decision:** Implement a **dual-bank analysis front-end** in K1:

* **Harmony bank:** musically spaced semitone Goertzel bins (borrow concept)
* **Rhythm bank:** low-frequency bins dedicated to beat evidence
* **Core infra:** ring buffer sample history, precomputed constants, optional correct windowing, separate normalization paths

**Why:** Maximizes perceptual quality + beat robustness while preserving MCU budget.

**Non-goals:** Copying the reference A-weighting/window code verbatim (both are flawed as implemented).

---
