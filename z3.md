## MODE: ENGINEERING

# Single-Page Engineering Spec — Dual-Bank Goertzel Front-End (K1)

### Locked parameters

* **Sample rate (Fs):** 16,000 Hz
* **Base hop / chunk:** 128 samples (**8.0 ms**, 125 Hz)
* **HarmonyBank:** **64 semitone bins** from **A2 (110 Hz)** upward (A2…≈C8 ~4186 Hz)
* **RhythmBank:** **24 bins** (low→high, transient-aware) computed every hop
* **Harmony cadence:** computed **every 2 hops** (every **16.0 ms**, 62.5 Hz)
* **Timebase:** **sample_counter** (no system timers in algorithmic time)

---

## 1) Module interfaces (C++ header-level contracts)

### 1.1 Core data types

```cpp
struct AudioChunk {
  int16_t  samples[128];     // mono
  uint32_t n = 128;
  uint64_t sample_counter_end; // inclusive end sample index
};

struct AudioFeatureFrame {
  uint64_t t_samples;        // end sample index of this frame
  uint32_t hop_index;        // increments each 128-sample chunk
  float    t_us;             // derived from t_samples and Fs

  // Rhythm (every hop)
  float    rhythm_bins[24];  // post-noise, post-AGC (see below)
  float    rhythm_energy;    // RMS (windowed)
  float    rhythm_novelty;   // flux-style novelty (rhythm bank only)

  // Harmony (every 2 hops)
  bool     harmony_valid;    // true only on harmony ticks
  float    harmony_bins[64]; // post-noise, post-AGC
  float    chroma12[12];     // sum-normalized
  float    chroma_stability; // rolling cosine mean/var metric
  float    key_clarity;      // simple “peakiness” metric for gating

  // Quality flags
  bool     is_silence;
  bool     is_clipping;
  bool     overload;         // compute overrun / dropped harmony tick
};
```

### 1.2 Audio capture

```cpp
class AudioCapture {
public:
  bool init(uint32_t sample_rate_hz);
  bool readChunk(AudioChunk& out); // blocks or non-blocking depending on driver
};
```

### 1.3 Ring buffer (history access, no memmove)

```cpp
class AudioRingBuffer {
public:
  bool init(size_t capacity_samples);
  void reset();
  void push(const int16_t* samples, size_t n, uint64_t end_sample_counter);

  // Copy the last N samples into dst (handles wrap); deterministic bounded copy.
  bool copyLast(size_t N, int16_t* dst) const;

  uint64_t sampleCounterEnd() const;
};
```

### 1.4 Goertzel bank (precomputed coefficients + per-bin N)

```cpp
struct GoertzelBinSpec {
  float    freq_hz;
  uint16_t N;          // window length (samples)
  int16_t  coeff_q14;  // 2*cos(2πk/N) in Q14
  uint16_t k;          // bin index used for coeff derivation
};

class GoertzelBank {
public:
  bool init(uint32_t Fs, const GoertzelBinSpec* specs, size_t num_bins,
            const int16_t* window_q15, size_t window_len_max);
  // Computes magnitudes into out_bins[] (linear power or amplitude; documented below)
  void process(const int16_t* windowed_samples, size_t N, float* out_bins);
};
```

### 1.5 Noise floor + AGC (separate instances per bank)

```cpp
class NoiseFloor {
public:
  void reset();
  void update(const float* mags, size_t n);  // slow leaky-min estimator
  void subtract(float* mags, size_t n, float k); // mags = max(0, mags - k*floor)
};

class AGC {
public:
  void reset();
  // Rhythm AGC: attenuation-only (never boosts), conservative.
  void applyAttenuationOnly(float* mags, size_t n, float target, float alpha);
  // Harmony AGC: mild normalization allowed (boost capped).
  void applyMild(float* mags, size_t n, float target, float alpha, float max_boost);
};
```

### 1.6 Novelty + Chroma + Stability

```cpp
class NoveltyFlux {
public:
  void reset();
  float update(const float* mags, size_t n); // half-wave positive deltas, normalized
};

class ChromaExtractor {
public:
  void binsToChroma12(const float harmony_bins[64], float chroma12_out[12]);
  float keyClarity(const float chroma12[12]); // peakiness measure 0..1
};

class ChromaStability {
public:
  void init(size_t W_frames);
  void reset();
  float update(const float chroma12[12]); // cosine similarity rolling stat
};
```

### 1.7 Publisher (single writer)

```cpp
class FeatureBus {
public:
  void publish(const AudioFeatureFrame& f); // lock-free swap or single-thread store
};
```

---

## 2) Exact per-hop schedule (deterministic)

### Constants

* Hop = 128 samples = 8.0 ms
* Harmony tick = every 2 hops = 16.0 ms
* Max window length clamp: **Nmax = 1536 samples (96 ms)**
* Min window length clamp: **Nmin = 256 samples (16 ms)**

### Per hop (every 8.0 ms)

1. **Capture**

* `AudioCapture::readChunk(chunk)`
* Update `sample_counter_end` and flags:

  * `is_clipping` if any sample hits near int16 rails
  * `is_silence` if RMS below threshold for M hops (configurable)

2. **Push into ring buffer**

* `ring.push(chunk.samples, 128, chunk.sample_counter_end)`

3. **RhythmBank compute (always)**

* For each rhythm bin `i`:

  * Determine its precomputed `N_i` (clamped)
  * `ring.copyLast(N_i, scratch_i16[N_i])`
  * Apply window LUT (Q15 multiply → Q-format intermediate)
  * Run Goertzel recurrence → magnitude `mag_i`
* `NoiseFloor_rhythm.update(mags)` then `subtract(mags, k=1.5)`
* `AGC_rhythm.applyAttenuationOnly(mags, target, alpha)`
* `rhythm_novelty = NoveltyFlux_rhythm.update(mags)`
* `rhythm_energy = RMS(last 256 samples)` (or same window as lowest rhythm bin)

4. **HarmonyBank compute (every 2 hops only)**

* If `(hop_index % 2 == 0)`:

  * Compute 64 semitone bins using the same history mechanism (per-bin `N_i`)
  * `NoiseFloor_harmony.update/subtract`
  * `AGC_harmony.applyMild`
  * `ChromaExtractor.binsToChroma12()`
  * `key_clarity = keyClarity(chroma12)`
  * `chroma_stability = ChromaStability.update(chroma12)`
  * Set `harmony_valid = true`
* Else:

  * `harmony_valid = false` (bins/chroma not updated)

5. **Publish**

* Fill `AudioFeatureFrame` with timestamps derived from `t_samples`
* Publish to bus

### Overrun policy (must be deterministic and human-safe)

* If compute time exceeds hop budget:

  * Set `overload=true`
  * **Drop HarmonyBank for that hop** (never drop RhythmBank)
  * Never “catch up” by running extra work later (avoids burst jitter)

---

## 3) Bank specs

### 3.1 HarmonyBank (64 semitone bins)

* Bin frequencies: `f[n] = 110.0 * 2^(n/12)` for n=0..63
* Window length policy (precompute at init):

  * `N_raw = round(Fs / (2 * max_neighbor_distance_hz))`
  * `N = clamp(N_raw, Nmin=256, Nmax=1536)`
  * Store `N`, compute `k`, compute `coeff_q14`

### 3.2 RhythmBank (24 bins, fixed list)

Designed to give beat evidence without letting hats dominate:

* **Low/kick:** 35, 45, 55, 70, 85, 100, 120 Hz
* **Low-mid/snare body:** 160, 200, 250, 315, 400 Hz
* **Presence:** 500, 630, 800, 1000, 1250 Hz
* **Transient/hat (lightweight):** 2000, 2500, 3150, 4000, 5000, 6300, 7500 Hz
  Window lengths:
* Low bins: N=1024–1536 (clamped)
* Mid: N=512
* High: N=256
  (All precomputed constants; no runtime math.)

---

## 4) Windowing spec (safe)

* Use **Hann** window in **Q15**, length = `Nmax` (1536)
* For bins with smaller `N`, index the first `N` entries (or regenerate per-N at init if preferred; still one-time)
* Must satisfy:

  * `0 ≤ w[n] ≤ 32767`
  * No overflow in multiply path (use 32-bit intermediate)

---

## 5) Normalization + noise floor spec (separate per bank)

### NoiseFloor (both banks)

* Estimator: leaky-min or percentile-approx with slow decay
* Subtraction:

  * `m[i] = max(0, m[i] - 1.5 * floor[i])`
* Freeze update when `is_clipping=true` to avoid “learning distortion”

### AGC Rhythm (attenuation-only)

* Compute aggregate level `L = mean(mags)`
* Gain `g = min(1.0, target / (L + eps))`
* Smooth: `g = lerp(g_prev, g, alpha)` with small alpha
* Apply: `mags *= g`
* Never boost (prevents raising noise in quiet rooms)

### AGC Harmony (mild)

* Similar but allow boost capped:

  * `g = clamp(target / (L+eps), 0.5, max_boost)`
* Purpose: stabilize chroma under different mic gains

---

## 6) Memory + CPU budget targets (ESP32-class, “all humans” reliability)

### Memory targets (static, no heap in hot path)

* Ring buffer: **4096 samples int16** (~8 KB)
* Scratch windows:

  * Rhythm scratch: up to Nmax int16 (~3 KB) reused per-bin
  * Harmony scratch: up to Nmax int16 (~3 KB) reused per-bin
* Window LUT Q15 (1536): ~3 KB
* Coeff tables:

  * Harmony 64 specs: <1 KB
  * Rhythm 24 specs: <0.5 KB
* Feature frame: ~ (24+64+12 floats) ~ 400 bytes

**Total working RAM target:** **< 32 KB** for this entire front-end.

### CPU budgets (per 8 ms hop at 16 kHz)

Target worst-case on audio core:

* **RhythmBank tick:** ≤ **0.6 ms**
* **HarmonyBank tick (every 16 ms):** ≤ **1.0 ms** when it runs
* **Total amortized:** ≤ **1.1 ms per hop** average
* **Hard ceiling:** ≤ **2.0 ms per hop** worst-case (with overload drop policy)

---

## 7) Acceptance checks (must pass before integrating into beat tracker)

1. **Idle room:** rhythm_novelty stays low; no periodic spikes; noise floor converges in <10s
2. **Kick loop:** rhythm_novelty peaks align with kick; hat-only loop does not dominate beat evidence
3. **Sustained chord:** chroma stability rises; key_clarity > threshold during steady harmony
4. **Stress:** no missed audio chunks; harmony drops gracefully under overload; rhythm continues

---